typedef unsigned char   undefined;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
float16
float2
float4
float8
typedef long long    longlong;
typedef unsigned long long    qword;
typedef int    sdword;
typedef long long    sqword;
typedef short    sword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    wchar16;
typedef unsigned int    wchar32;
typedef unsigned short    word;
typedef ushort sa_family_t;

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    struct _IO_marker *_markers;
    struct _IO_FILE *_chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t *_lock;
    __off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    size_t __pad5;
    int _mode;
    char _unused2[40];
};

struct _IO_marker {
    struct _IO_marker *_next;
    struct _IO_FILE *_sbuf;
    int _pos;
};

typedef struct pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool> pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool>, *Ppair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool>;

struct pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool> { // PlaceHolder Class Structure
};

typedef struct _Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_> _Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>, *P_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>;

struct _Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_> { // PlaceHolder Class Structure
};

typedef struct stat stat, *Pstat;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    ulong __unused4;
    ulong __unused5;
};

typedef float float_t;

typedef double double_t;

typedef uint wint_t;

typedef bool value_type;

typedef uchar UQItype;

typedef uint type.conflict;

typedef int __pid_t;

typedef undefined complex long double[32];

typedef int __gcc_CMPtype;


// WARNING! conflicting data type names: /DWARF/__blkcnt_t - /types.h/__blkcnt_t


// WARNING! conflicting data type names: /DWARF/size_t - /stddef.h/size_t

typedef int type;

typedef int _ssize_t;

typedef ushort UHWtype;

typedef uint u_long;

typedef uint clock_t;

typedef dword complex _Float16;

typedef int _fpos_t;

typedef bool type.conflict1;

typedef ulonglong UDItype;

typedef float8 _Float64;

typedef double DFtype;

typedef qword complex float;

typedef uchar __uint8_t;

typedef int mapped_type;

typedef int __suseconds_t;

typedef wchar16 char16_t;

typedef sdword __int32_t;

typedef bool _Bool;

typedef int ptrdiff_t;

typedef sqword __int_least64_t;

typedef word __uint16_t;

typedef dword __uint32_t;

typedef float2 _Float16;

typedef uint __ULong;


// WARNING! conflicting data type names: /DWARF/__blksize_t - /types.h/__blksize_t


// WARNING! conflicting data type names: /DWARF/__gid_t - /types.h/__gid_t

typedef qword __uint64_t;

typedef int key_type;

typedef float16 TFtype;

typedef float4 _Float32;


// WARNING! conflicting data type names: /DWARF/uint - /uint


// WARNING! conflicting data type names: /DWARF/__uid_t - /types.h/__uid_t

typedef undefined complex double[16];

typedef int _off_t;

typedef int SItype;

typedef char __int8_t;

typedef float16 _Float128;


// WARNING! conflicting data type names: /DWARF/__nlink_t - /types.h/__nlink_t

typedef sqword __int64_t;


// WARNING! conflicting data type names: /DWARF/__dev_t - /types.h/__dev_t

typedef int wchar_t;

typedef uint __uintptr_t;

typedef ushort u_short;

typedef wchar32 char32_t;

typedef uint USItype;

typedef int __intptr_t;

typedef int second_type;

typedef sword __int16_t;


// WARNING! conflicting data type names: /DWARF/__ino_t - /types.h/__ino_t

typedef longlong DItype;

typedef struct msc_csw_t msc_csw_t, *Pmsc_csw_t;

typedef __uint32_t uint32_t;

typedef __uint8_t uint8_t;

struct msc_csw_t {
    uint32_t signature;
    uint32_t tag;
    uint32_t data_residue;
    uint8_t status;
};

typedef struct scsi_prevent_allow_medium_removal_t scsi_prevent_allow_medium_removal_t, *Pscsi_prevent_allow_medium_removal_t;

struct scsi_prevent_allow_medium_removal_t {
    uint8_t cmd_code;
    uint8_t reserved[3];
    uint8_t prohibit_removal;
    uint8_t control;
};

typedef struct scsi_start_stop_unit_t scsi_start_stop_unit_t, *Pscsi_start_stop_unit_t;

struct scsi_start_stop_unit_t {
    uint8_t cmd_code;
    uint8_t immded:1;
    uint8_t reserved2;
    uint8_t power_condition_mod:4;
    uint8_t start:1;
    uint8_t load_eject:1;
    uint8_t no_flush:1;
    uint8_t power_condition:4;
    uint8_t control;
};

typedef struct scsi_inquiry_resp_t scsi_inquiry_resp_t, *Pscsi_inquiry_resp_t;

struct scsi_inquiry_resp_t {
    uint8_t peripheral_device_type:5;
    uint8_t peripheral_qualifier:3;
    uint8_t is_removable:1;
    uint8_t version;
    uint8_t response_data_format:4;
    uint8_t hierarchical_support:1;
    uint8_t normal_aca:1;
    uint8_t additional_length;
    uint8_t protect:1;
    uint8_t third_party_copy:1;
    uint8_t target_port_group_support:2;
    uint8_t access_control_coordinator:1;
    uint8_t scc_support:1;
    uint8_t addr16:1;
    uint8_t multi_port:1;
    uint8_t enclosure_service:1;
    uint8_t cmd_que:1;
    uint8_t sync:1;
    uint8_t wbus16:1;
    uint8_t vendor_id[8];
    uint8_t product_id[16];
    uint8_t product_rev[4];
};

typedef struct scsi_sense_fixed_resp_t scsi_sense_fixed_resp_t, *Pscsi_sense_fixed_resp_t;

struct scsi_sense_fixed_resp_t {
    uint8_t response_code:7;
    uint8_t valid:1;
    uint8_t reserved;
    uint8_t sense_key:4;
    uint8_t ili:1;
    uint8_t end_of_medium:1;
    uint8_t filemark:1;
    uint32_t information;
    uint8_t add_sense_len;
    uint32_t command_specific_info;
    uint8_t add_sense_code;
    uint8_t add_sense_qualifier;
    uint8_t field_replaceable_unit_code;
    uint8_t sense_key_specific[3];
};

typedef struct scsi_read_format_capacity_data_t scsi_read_format_capacity_data_t, *Pscsi_read_format_capacity_data_t;

typedef __uint16_t uint16_t;

struct scsi_read_format_capacity_data_t {
    uint8_t reserved[3];
    uint8_t list_length;
    uint32_t block_num;
    uint8_t descriptor_type;
    uint8_t reserved2;
    uint16_t block_size_u16;
};

typedef struct scsi_read_capacity10_resp_t scsi_read_capacity10_resp_t, *Pscsi_read_capacity10_resp_t;

struct scsi_read_capacity10_resp_t {
    uint32_t last_lba;
    uint32_t block_size;
};

typedef struct msc_cbw_t msc_cbw_t, *Pmsc_cbw_t;

struct msc_cbw_t {
    uint32_t signature;
    uint32_t tag;
    uint32_t total_bytes;
    uint8_t dir;
    uint8_t lun;
    uint8_t cmd_len;
    uint8_t command[16];
};

typedef struct scsi_mode_sense6_resp_t scsi_mode_sense6_resp_t, *Pscsi_mode_sense6_resp_t;

struct scsi_mode_sense6_resp_t {
    uint8_t data_len;
    uint8_t medium_type;
    uint8_t reserved:7;
    _Bool write_protected:1;
    uint8_t block_descriptor_len;
};

typedef struct HardwareI2C HardwareI2C, *PHardwareI2C;

typedef struct Stream Stream, *PStream;

typedef struct Print Print, *PPrint;

struct Print {
    int (**_vptr.Print)(...);
    int write_error;
};

struct Stream {
    struct Print super_Print;
    ulong _timeout;
    ulong _startMillis;
};

struct HardwareI2C {
    struct Stream super_Stream;
};

typedef struct timeval timeval, *Ptimeval;

typedef __int_least64_t time_t;

typedef __suseconds_t suseconds_t;

struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
    undefined field2_0xc;
    undefined field3_0xd;
    undefined field4_0xe;
    undefined field5_0xf;
};

typedef struct mscd_interface_t mscd_interface_t, *Pmscd_interface_t;

struct mscd_interface_t {
    struct msc_cbw_t cbw;
    undefined field1_0x1f;
    struct msc_csw_t csw;
    uint8_t itf_num;
    uint8_t ep_in;
    uint8_t ep_out;
    uint8_t stage;
    undefined field7_0x31;
    undefined field8_0x32;
    undefined field9_0x33;
    uint32_t total_len;
    uint32_t xferred_len;
    uint8_t sense_key;
    uint8_t add_sense_code;
    uint8_t add_sense_qualifier;
    undefined field15_0x3f;
};

typedef struct 8sio_hw_t 8sio_hw_t, *P8sio_hw_t;

typedef struct 8sio_hw_t sio_hw_t;

typedef uint32_t io_ro_32;

typedef uint32_t io_rw_32;

typedef uint32_t io_wo_32;

typedef struct 11interp_hw_t 11interp_hw_t, *P11interp_hw_t;

typedef struct 11interp_hw_t interp_hw_t;

struct 11interp_hw_t {
    io_rw_32 accum[2];
    io_rw_32 base[3];
    io_ro_32 pop[3];
    io_ro_32 peek[3];
    io_rw_32 ctrl[2];
    io_rw_32 add_raw[2];
    io_wo_32 base01;
};

struct 8sio_hw_t {
    io_ro_32 cpuid;
    io_ro_32 gpio_in;
    io_ro_32 gpio_hi_in;
    uint32_t _pad0;
    io_rw_32 gpio_out;
    io_rw_32 gpio_hi_out;
    io_wo_32 gpio_set;
    io_wo_32 gpio_hi_set;
    io_wo_32 gpio_clr;
    io_wo_32 gpio_hi_clr;
    io_wo_32 gpio_togl;
    io_wo_32 gpio_hi_togl;
    io_rw_32 gpio_oe;
    io_rw_32 gpio_hi_oe;
    io_wo_32 gpio_oe_set;
    io_wo_32 gpio_hi_oe_set;
    io_wo_32 gpio_oe_clr;
    io_wo_32 gpio_hi_oe_clr;
    io_wo_32 gpio_oe_togl;
    io_wo_32 gpio_hi_oe_togl;
    io_rw_32 fifo_st;
    io_wo_32 fifo_wr;
    io_ro_32 fifo_rd;
    io_ro_32 spinlock_st;
    uint32_t _pad1[8];
    interp_hw_t interp[2];
    io_rw_32 spinlock[32];
    io_rw_32 doorbell_out_set;
    io_rw_32 doorbell_out_clr;
    io_rw_32 doorbell_in_set;
    io_rw_32 doorbell_in_clr;
    io_rw_32 peri_nonsec;
    uint32_t _pad2[3];
    io_rw_32 riscv_softirq;
    io_rw_32 mtime_ctrl;
    uint32_t _pad3[2];
    io_rw_32 mtime;
    io_rw_32 mtimeh;
    io_rw_32 mtimecmp;
    io_rw_32 mtimecmph;
    io_rw_32 tmds_ctrl;
    io_wo_32 tmds_wdata;
    io_ro_32 tmds_peek_single;
    io_ro_32 tmds_pop_single;
    io_ro_32 tmds_peek_double_l0;
    io_ro_32 tmds_pop_double_l0;
    io_ro_32 tmds_peek_double_l1;
    io_ro_32 tmds_pop_double_l1;
    io_ro_32 tmds_peek_double_l2;
    io_ro_32 tmds_pop_double_l2;
};

typedef struct sio_hw_t.conflict sio_hw_t.conflict, *Psio_hw_t.conflict;

struct sio_hw_t.conflict {
    io_ro_32 cpuid;
    io_ro_32 gpio_in;
    io_ro_32 gpio_hi_in;
    uint32_t _pad0;
    io_rw_32 gpio_out;
    io_rw_32 gpio_hi_out;
    io_wo_32 gpio_set;
    io_wo_32 gpio_hi_set;
    io_wo_32 gpio_clr;
    io_wo_32 gpio_hi_clr;
    io_wo_32 gpio_togl;
    io_wo_32 gpio_hi_togl;
    io_rw_32 gpio_oe;
    io_rw_32 gpio_hi_oe;
    io_wo_32 gpio_oe_set;
    io_wo_32 gpio_hi_oe_set;
    io_wo_32 gpio_oe_clr;
    io_wo_32 gpio_hi_oe_clr;
    io_wo_32 gpio_oe_togl;
    io_wo_32 gpio_hi_oe_togl;
    io_rw_32 fifo_st;
    io_wo_32 fifo_wr;
    io_ro_32 fifo_rd;
    io_ro_32 spinlock_st;
    uint32_t _pad1[8];
    interp_hw_t interp[2];
    io_rw_32 spinlock[32];
    io_rw_32 doorbell_out_set;
    io_rw_32 doorbell_out_clr;
    io_rw_32 doorbell_in_set;
    io_rw_32 doorbell_in_clr;
    io_rw_32 peri_nonsec;
    uint32_t _pad2[3];
    io_rw_32 riscv_softirq;
    io_rw_32 mtime_ctrl;
    uint32_t _pad3[2];
    io_rw_32 mtime;
    io_rw_32 mtimeh;
    io_rw_32 mtimecmp;
    io_rw_32 mtimecmph;
    io_rw_32 tmds_ctrl;
    io_wo_32 tmds_wdata;
    io_ro_32 tmds_peek_single;
    io_ro_32 tmds_pop_single;
    io_ro_32 tmds_peek_double_l0;
    io_ro_32 tmds_pop_double_l0;
    io_ro_32 tmds_peek_double_l1;
    io_ro_32 tmds_pop_double_l1;
    io_ro_32 tmds_peek_double_l2;
    io_ro_32 tmds_pop_double_l2;
};

typedef struct io_bank0_irq_ctrl_hw_t.conflict io_bank0_irq_ctrl_hw_t.conflict, *Pio_bank0_irq_ctrl_hw_t.conflict;

struct io_bank0_irq_ctrl_hw_t.conflict {
    io_rw_32 inte[6];
    io_rw_32 intf[6];
    io_ro_32 ints[6];
};

typedef struct 22io_bank0_irq_ctrl_hw_t 22io_bank0_irq_ctrl_hw_t, *P22io_bank0_irq_ctrl_hw_t;

typedef struct 22io_bank0_irq_ctrl_hw_t io_bank0_irq_ctrl_hw_t;

struct 22io_bank0_irq_ctrl_hw_t {
    io_rw_32 inte[6];
    io_rw_32 intf[6];
    io_ro_32 ints[6];
};

typedef struct io_bank0_status_ctrl_hw_t.conflict io_bank0_status_ctrl_hw_t.conflict, *Pio_bank0_status_ctrl_hw_t.conflict;

struct io_bank0_status_ctrl_hw_t.conflict {
    io_ro_32 status;
    io_rw_32 ctrl;
};

typedef struct 25io_bank0_status_ctrl_hw_t 25io_bank0_status_ctrl_hw_t, *P25io_bank0_status_ctrl_hw_t;

struct 25io_bank0_status_ctrl_hw_t {
    io_ro_32 status;
    io_rw_32 ctrl;
};

typedef enum gpio_function_rp2350 {
    GPIO_FUNC_HSTX=0,
    GPIO_FUNC_SPI=1,
    GPIO_FUNC_UART=2,
    GPIO_FUNC_I2C=3,
    GPIO_FUNC_PWM=4,
    GPIO_FUNC_SIO=5,
    GPIO_FUNC_PIO0=6,
    GPIO_FUNC_PIO1=7,
    GPIO_FUNC_PIO2=8,
    GPIO_FUNC_CORESIGHT_TRACE=9,
    GPIO_FUNC_GPCK=9,
    GPIO_FUNC_XIP_CS1=9,
    GPIO_FUNC_USB=10,
    GPIO_FUNC_UART_AUX=11,
    GPIO_FUNC_NULL=31
} gpio_function_rp2350;

typedef enum gpio_function_rp2350 gpio_function_t;

typedef struct 13io_bank0_hw_t 13io_bank0_hw_t, *P13io_bank0_hw_t;

typedef struct 25io_bank0_status_ctrl_hw_t io_bank0_status_ctrl_hw_t;

typedef union anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10 anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10, *Panon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10;

typedef struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10_1 anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10_1, *Panon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10_1;

struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10_1 {
    io_bank0_irq_ctrl_hw_t proc0_irq_ctrl;
    io_bank0_irq_ctrl_hw_t proc1_irq_ctrl;
    io_bank0_irq_ctrl_hw_t dormant_wake_irq_ctrl;
};

union anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10 {
    struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10_1 field_0;
    io_bank0_irq_ctrl_hw_t irq_ctrl[3];
};

struct 13io_bank0_hw_t {
    io_bank0_status_ctrl_hw_t io[48];
    uint32_t _pad0[32];
    io_ro_32 irqsummary_proc0_secure[2];
    io_ro_32 irqsummary_proc0_nonsecure[2];
    io_ro_32 irqsummary_proc1_secure[2];
    io_ro_32 irqsummary_proc1_nonsecure[2];
    io_ro_32 irqsummary_dormant_wake_secure[2];
    io_ro_32 irqsummary_dormant_wake_nonsecure[2];
    io_rw_32 intr[6];
    union anon_union_216_2_95a08ed8_for_13io_bank0_hw_t_10 field_9;
};

typedef struct io_bank0_hw_t.conflict io_bank0_hw_t.conflict, *Pio_bank0_hw_t.conflict;

typedef union anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9 anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9, *Panon_union_216_2_95a08ed8_for_io_bank0_hw_t_9;

typedef struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9_0 anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9_0, *Panon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9_0;

struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9_0 {
    struct io_bank0_irq_ctrl_hw_t.conflict proc0_irq_ctrl;
    struct io_bank0_irq_ctrl_hw_t.conflict proc1_irq_ctrl;
    struct io_bank0_irq_ctrl_hw_t.conflict dormant_wake_irq_ctrl;
};

union anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9 {
    struct anon_struct_216_3_fc291a3b_for_anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9_0 field_0;
    io_bank0_irq_ctrl_hw_t irq_ctrl[3];
};

struct io_bank0_hw_t.conflict {
    io_bank0_status_ctrl_hw_t io[48];
    uint32_t _pad0[32];
    io_ro_32 irqsummary_proc0_secure[2];
    io_ro_32 irqsummary_proc0_nonsecure[2];
    io_ro_32 irqsummary_proc1_secure[2];
    io_ro_32 irqsummary_proc1_nonsecure[2];
    io_ro_32 irqsummary_dormant_wake_secure[2];
    io_ro_32 irqsummary_dormant_wake_nonsecure[2];
    io_rw_32 intr[6];
    union anon_union_216_2_95a08ed8_for_io_bank0_hw_t_9 field_9;
};

typedef struct 13io_bank0_hw_t io_bank0_hw_t;

typedef struct usb_device_dpram_ep_buf_ctrl usb_device_dpram_ep_buf_ctrl, *Pusb_device_dpram_ep_buf_ctrl;

struct usb_device_dpram_ep_buf_ctrl {
    io_rw_32 in;
    io_rw_32 out;
};

typedef struct usb_device_dpram_ep_ctrl usb_device_dpram_ep_ctrl, *Pusb_device_dpram_ep_ctrl;

struct usb_device_dpram_ep_ctrl {
    io_rw_32 in;
    io_rw_32 out;
};

typedef struct usb_device_dpram_t usb_device_dpram_t, *Pusb_device_dpram_t;

struct usb_device_dpram_t {
    uint8_t setup_packet[8];
    struct usb_device_dpram_ep_ctrl ep_ctrl[15];
    struct usb_device_dpram_ep_buf_ctrl ep_buf_ctrl[16];
    uint8_t ep0_buf_a[64];
    uint8_t ep0_buf_b[64];
    uint8_t epx_data[3712];
};

typedef void (*gpio_irq_callback_t)(uint, uint32_t);

typedef enum gpio_slew_rate {
    GPIO_SLEW_RATE_SLOW=0,
    GPIO_SLEW_RATE_FAST=1
} gpio_slew_rate;

typedef enum gpio_dir {
    GPIO_IN=0,
    GPIO_OUT=1
} gpio_dir;

typedef enum gpio_drive_strength {
    GPIO_DRIVE_STRENGTH_2MA=0,
    GPIO_DRIVE_STRENGTH_4MA=1,
    GPIO_DRIVE_STRENGTH_8MA=2,
    GPIO_DRIVE_STRENGTH_12MA=3
} gpio_drive_strength;

typedef struct SPISettings SPISettings, *PSPISettings;

typedef enum N7arduino7SPIModeE {
    SPI_MODE0=0,
    SPI_MODE1=1,
    SPI_MODE2=2,
    SPI_MODE3=3
} N7arduino7SPIModeE;

typedef enum N7arduino7SPIModeE SPIMode;

typedef enum 8BitOrder {
    LSBFIRST=0,
    MSBFIRST=1
} 8BitOrder;

typedef enum 8BitOrder BitOrder;

struct SPISettings {
    uint32_t clockFreq;
    SPIMode dataMode;
    BitOrder bitOrder;
};

typedef struct HardwareSPI HardwareSPI, *PHardwareSPI;

struct HardwareSPI {
    int (**_vptr.HardwareSPI)(...);
};

typedef __uint64_t uint64_t;

typedef uint64_t raw_irq_mask_type_t;

typedef struct tu_unaligned_uint32_t tu_unaligned_uint32_t, *Ptu_unaligned_uint32_t;

struct tu_unaligned_uint32_t {
    uint32_t val;
};

typedef struct tu_unaligned_uint16_t tu_unaligned_uint16_t, *Ptu_unaligned_uint16_t;

struct tu_unaligned_uint16_t {
    uint16_t val;
};

typedef struct u8g2_cb_struct u8g2_cb_struct, *Pu8g2_cb_struct;

typedef struct u8g2_cb_struct u8g2_cb_t;

typedef struct u8g2_struct u8g2_struct, *Pu8g2_struct;

typedef struct u8g2_struct u8g2_t;

typedef void (*u8g2_update_dimension_cb)(u8g2_t *);

typedef void (*u8g2_update_page_win_cb)(u8g2_t *);

typedef uint16_t u8g2_uint_t;

typedef void (*u8g2_draw_l90_cb)(u8g2_t *, u8g2_uint_t, u8g2_uint_t, u8g2_uint_t, uint8_t);

typedef struct u8x8_struct u8x8_struct, *Pu8x8_struct;

typedef struct u8x8_struct u8x8_t;

typedef void (*u8g2_draw_ll_hvline_cb)(u8g2_t *, u8g2_uint_t, u8g2_uint_t, u8g2_uint_t, uint8_t);

typedef u8g2_uint_t (*u8g2_font_calc_vref_fnptr)(u8g2_t *);

typedef struct _u8g2_font_decode_t _u8g2_font_decode_t, *P_u8g2_font_decode_t;

typedef struct _u8g2_font_decode_t u8g2_font_decode_t;

typedef struct _u8g2_font_info_t _u8g2_font_info_t, *P_u8g2_font_info_t;

typedef struct _u8g2_font_info_t u8g2_font_info_t;

typedef __int8_t int8_t;

typedef struct u8x8_display_info_struct u8x8_display_info_struct, *Pu8x8_display_info_struct;

typedef struct u8x8_display_info_struct u8x8_display_info_t;

typedef uint16_t (*u8x8_char_cb)(u8x8_t *, uint8_t);

typedef uint8_t (*u8x8_msg_cb)(u8x8_t *, uint8_t, uint8_t, void *);

struct u8x8_struct {
    u8x8_display_info_t *display_info;
    u8x8_char_cb next_cb;
    u8x8_msg_cb display_cb;
    u8x8_msg_cb cad_cb;
    u8x8_msg_cb byte_cb;
    u8x8_msg_cb gpio_and_delay_cb;
    uint32_t bus_clock;
    uint8_t *font;
    uint16_t encoding;
    uint8_t x_offset;
    uint8_t is_font_inverse_mode;
    uint8_t i2c_address;
    uint8_t i2c_started;
    uint8_t utf8_state;
    uint8_t gpio_result;
    uint8_t debounce_default_pin_state;
    uint8_t debounce_last_pin_state;
    uint8_t debounce_state;
    uint8_t debounce_result_msg;
    uint8_t pins[22];
};

struct _u8g2_font_info_t {
    uint8_t glyph_cnt;
    uint8_t bbx_mode;
    uint8_t bits_per_0;
    uint8_t bits_per_1;
    uint8_t bits_per_char_width;
    uint8_t bits_per_char_height;
    uint8_t bits_per_char_x;
    uint8_t bits_per_char_y;
    uint8_t bits_per_delta_x;
    int8_t max_char_width;
    int8_t max_char_height;
    int8_t x_offset;
    int8_t y_offset;
    int8_t ascent_A;
    int8_t descent_g;
    int8_t ascent_para;
    int8_t descent_para;
    uint16_t start_pos_upper_A;
    uint16_t start_pos_lower_a;
    uint16_t start_pos_unicode;
};

struct _u8g2_font_decode_t {
    uint8_t *decode_ptr;
    u8g2_uint_t target_x;
    u8g2_uint_t target_y;
    int8_t x;
    int8_t y;
    int8_t glyph_width;
    int8_t glyph_height;
    uint8_t decode_bit_pos;
    uint8_t is_transparent;
    uint8_t fg_color;
    uint8_t bg_color;
    uint8_t dir;
};

struct u8g2_struct {
    u8x8_t u8x8;
    u8g2_draw_ll_hvline_cb ll_hvline;
    u8g2_cb_t *cb;
    uint8_t *tile_buf_ptr;
    uint8_t tile_buf_height;
    uint8_t tile_curr_row;
    u8g2_uint_t pixel_buf_width;
    u8g2_uint_t pixel_buf_height;
    u8g2_uint_t pixel_curr_row;
    u8g2_uint_t buf_y0;
    u8g2_uint_t buf_y1;
    u8g2_uint_t width;
    u8g2_uint_t height;
    u8g2_uint_t user_x0;
    u8g2_uint_t user_x1;
    u8g2_uint_t user_y0;
    u8g2_uint_t user_y1;
    u8g2_uint_t clip_x0;
    u8g2_uint_t clip_x1;
    u8g2_uint_t clip_y0;
    u8g2_uint_t clip_y1;
    uint8_t *font;
    u8g2_font_calc_vref_fnptr font_calc_vref;
    u8g2_font_decode_t font_decode;
    u8g2_font_info_t font_info;
    uint8_t is_page_clip_window_intersection;
    uint8_t font_height_mode;
    int8_t font_ref_ascent;
    int8_t font_ref_descent;
    int8_t glyph_x_offset;
    uint8_t bitmap_transparency;
    uint8_t draw_color;
    uint8_t is_auto_page_clear;
};

struct u8x8_display_info_struct {
    uint8_t chip_enable_level;
    uint8_t chip_disable_level;
    uint8_t post_chip_enable_wait_ns;
    uint8_t pre_chip_disable_wait_ns;
    uint8_t reset_pulse_width_ms;
    uint8_t post_reset_wait_ms;
    uint8_t sda_setup_time_ns;
    uint8_t sck_pulse_width_ns;
    uint32_t sck_clock_hz;
    uint8_t spi_mode;
    uint8_t i2c_bus_clock_100kHz;
    uint8_t data_setup_time_ns;
    uint8_t write_pulse_width_ns;
    uint8_t tile_width;
    uint8_t tile_height;
    uint8_t default_x_offset;
    uint8_t flipmode_x_offset;
    uint16_t pixel_width;
    uint16_t pixel_height;
};

struct u8g2_cb_struct {
    u8g2_update_dimension_cb update_dimension;
    u8g2_update_page_win_cb update_page_win;
    u8g2_draw_l90_cb draw_l90;
};

typedef struct _u8g2_kerning_t _u8g2_kerning_t, *P_u8g2_kerning_t;

typedef struct _u8g2_kerning_t u8g2_kerning_t;

struct _u8g2_kerning_t {
    uint16_t first_table_cnt;
    uint16_t second_table_cnt;
    uint16_t *first_encoding_table;
    uint16_t *index_to_second_table;
    uint16_t *second_encoding_table;
    uint8_t *kerning_values;
};

typedef struct psm_hw_t psm_hw_t, *Ppsm_hw_t;

struct psm_hw_t {
    io_rw_32 frce_on;
    io_rw_32 frce_off;
    io_rw_32 wdsel;
    io_ro_32 done;
};

typedef struct pads_qspi_hw_t pads_qspi_hw_t, *Ppads_qspi_hw_t;

struct pads_qspi_hw_t {
    io_rw_32 voltage_select;
    io_rw_32 io[6];
};

typedef void *__gnuc_va_list;

typedef __gnuc_va_list va_list;

typedef enum anon_enum_32 {
    OCT=0,
    DEC=1,
    HEX=2
} anon_enum_32;

typedef union anon_union_8_2_0ec0e362 anon_union_8_2_0ec0e362, *Panon_union_8_2_0ec0e362;

union anon_union_8_2_0ec0e362 {
    int i;
    double fp;
};

typedef struct hidd_epbuf_t hidd_epbuf_t, *Phidd_epbuf_t;

typedef union anon_union_64_2_742871bc_for_hidd_epbuf_t_0 anon_union_64_2_742871bc_for_hidd_epbuf_t_0, *Panon_union_64_2_742871bc_for_hidd_epbuf_t_0;

typedef union anon_union_64_2_ea7ad672_for_hidd_epbuf_t_1 anon_union_64_2_ea7ad672_for_hidd_epbuf_t_1, *Panon_union_64_2_ea7ad672_for_hidd_epbuf_t_1;

typedef union anon_union_64_2_408980c8_for_hidd_epbuf_t_2 anon_union_64_2_408980c8_for_hidd_epbuf_t_2, *Panon_union_64_2_408980c8_for_hidd_epbuf_t_2;

union anon_union_64_2_742871bc_for_hidd_epbuf_t_0 {
    uint8_t ctrl[64];
    uint8_t ctrl_dcache_padding[64];
};

union anon_union_64_2_ea7ad672_for_hidd_epbuf_t_1 {
    uint8_t epin[64];
    uint8_t epin_dcache_padding[64];
};

union anon_union_64_2_408980c8_for_hidd_epbuf_t_2 {
    uint8_t epout[64];
    uint8_t epout_dcache_padding[64];
};

struct hidd_epbuf_t {
    union anon_union_64_2_742871bc_for_hidd_epbuf_t_0 field_0;
    union anon_union_64_2_ea7ad672_for_hidd_epbuf_t_1 field_1;
    union anon_union_64_2_408980c8_for_hidd_epbuf_t_2 field_2;
};

typedef struct hidd_interface_t hidd_interface_t, *Phidd_interface_t;

typedef struct tusb_hid_descriptor_hid_t tusb_hid_descriptor_hid_t, *Ptusb_hid_descriptor_hid_t;

struct tusb_hid_descriptor_hid_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t bcdHID;
    uint8_t bCountryCode;
    uint8_t bNumDescriptors;
    uint8_t bReportType;
    uint16_t wReportLength;
};

struct hidd_interface_t {
    uint8_t itf_num;
    uint8_t ep_in;
    uint8_t ep_out;
    uint8_t itf_protocol;
    uint16_t report_desc_len;
    uint8_t protocol_mode;
    uint8_t idle_rate;
    struct tusb_hid_descriptor_hid_t *hid_descriptor;
};

typedef enum dreq_num_rp2350 {
    DREQ_PIO0_TX0=0,
    DREQ_PIO0_TX1=1,
    DREQ_PIO0_TX2=2,
    DREQ_PIO0_TX3=3,
    DREQ_PIO0_RX0=4,
    DREQ_PIO0_RX1=5,
    DREQ_PIO0_RX2=6,
    DREQ_PIO0_RX3=7,
    DREQ_PIO1_TX0=8,
    DREQ_PIO1_TX1=9,
    DREQ_PIO1_TX2=10,
    DREQ_PIO1_TX3=11,
    DREQ_PIO1_RX0=12,
    DREQ_PIO1_RX1=13,
    DREQ_PIO1_RX2=14,
    DREQ_PIO1_RX3=15,
    DREQ_PIO2_TX0=16,
    DREQ_PIO2_TX1=17,
    DREQ_PIO2_TX2=18,
    DREQ_PIO2_TX3=19,
    DREQ_PIO2_RX0=20,
    DREQ_PIO2_RX1=21,
    DREQ_PIO2_RX2=22,
    DREQ_PIO2_RX3=23,
    DREQ_SPI0_TX=24,
    DREQ_SPI0_RX=25,
    DREQ_SPI1_TX=26,
    DREQ_SPI1_RX=27,
    DREQ_UART0_TX=28,
    DREQ_UART0_RX=29,
    DREQ_UART1_TX=30,
    DREQ_UART1_RX=31,
    DREQ_PWM_WRAP0=32,
    DREQ_PWM_WRAP1=33,
    DREQ_PWM_WRAP2=34,
    DREQ_PWM_WRAP3=35,
    DREQ_PWM_WRAP4=36,
    DREQ_PWM_WRAP5=37,
    DREQ_PWM_WRAP6=38,
    DREQ_PWM_WRAP7=39,
    DREQ_PWM_WRAP8=40,
    DREQ_PWM_WRAP9=41,
    DREQ_PWM_WRAP10=42,
    DREQ_PWM_WRAP11=43,
    DREQ_I2C0_TX=44,
    DREQ_I2C0_RX=45,
    DREQ_I2C1_TX=46,
    DREQ_I2C1_RX=47,
    DREQ_ADC=48,
    DREQ_XIP_STREAM=49,
    DREQ_XIP_QMITX=50,
    DREQ_XIP_QMIRX=51,
    DREQ_HSTX=52,
    DREQ_CORESIGHT=53,
    DREQ_SHA256=54,
    DREQ_DMA_TIMER0=59,
    DREQ_DMA_TIMER1=60,
    DREQ_DMA_TIMER2=61,
    DREQ_DMA_TIMER3=62,
    DREQ_FORCE=63,
    DREQ_COUNT=64
} dreq_num_rp2350;

typedef struct spi_inst spi_inst, *Pspi_inst;

typedef struct spi_inst spi_inst_t;

struct spi_inst {
};

typedef enum spi_cpha_t.conflict {
    SPI_CPHA_0=0,
    SPI_CPHA_1=1
} spi_cpha_t.conflict;

typedef enum 10spi_cpha_t {
    SPI_CPHA_0=0,
    SPI_CPHA_1=1
} 10spi_cpha_t;

typedef enum 10spi_cpha_t spi_cpha_t;

typedef struct 8spi_hw_t 8spi_hw_t, *P8spi_hw_t;

typedef struct 8spi_hw_t spi_hw_t;

struct 8spi_hw_t {
    io_rw_32 cr0;
    io_rw_32 cr1;
    io_rw_32 dr;
    io_ro_32 sr;
    io_rw_32 cpsr;
    io_rw_32 imsc;
    io_ro_32 ris;
    io_ro_32 mis;
    io_rw_32 icr;
    io_rw_32 dmacr;
};

typedef struct spi_hw_t.conflict spi_hw_t.conflict, *Pspi_hw_t.conflict;

struct spi_hw_t.conflict {
    io_rw_32 cr0;
    io_rw_32 cr1;
    io_rw_32 dr;
    io_ro_32 sr;
    io_rw_32 cpsr;
    io_rw_32 imsc;
    io_ro_32 ris;
    io_ro_32 mis;
    io_rw_32 icr;
    io_rw_32 dmacr;
};

typedef enum spi_cpol_t.conflict {
    SPI_CPOL_0=0,
    SPI_CPOL_1=1
} spi_cpol_t.conflict;

typedef enum spi_order_t.conflict {
    SPI_LSB_FIRST=0,
    SPI_MSB_FIRST=1
} spi_order_t.conflict;

typedef enum 11spi_order_t {
    SPI_LSB_FIRST=0,
    SPI_MSB_FIRST=1
} 11spi_order_t;

typedef enum 10spi_cpol_t {
    SPI_CPOL_0=0,
    SPI_CPOL_1=1
} 10spi_cpol_t;

typedef enum 10spi_cpol_t spi_cpol_t;

typedef enum 11spi_order_t spi_order_t;

typedef struct SPIClassRP2040 SPIClassRP2040, *PSPIClassRP2040;

typedef uint8_t pin_size_t;

typedef struct SPIHelper SPIHelper, *PSPIHelper;

typedef struct map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>, *Pmap<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>;

typedef struct _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>, *P_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>;

typedef struct _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> _Rep_type;

typedef struct _Rb_tree_impl<std::less<int>,_true> _Rb_tree_impl<std::less<int>,_true>, *P_Rb_tree_impl<std::less<int>,_true>;

typedef struct _Rb_tree_key_compare<std::less<int>_> _Rb_tree_key_compare<std::less<int>_>, *P_Rb_tree_key_compare<std::less<int>_>;

typedef struct allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>, *Pallocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>;

typedef struct _Rb_tree_header _Rb_tree_header, *P_Rb_tree_header;

typedef struct less<int> less<int>, *Pless<int>;

typedef struct __new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> __new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>, *P__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>;

typedef struct _Rb_tree_node_base _Rb_tree_node_base, *P_Rb_tree_node_base;

typedef struct binary_function<int,_int,_bool> binary_function<int,_int,_bool>, *Pbinary_function<int,_int,_bool>;

typedef enum _Rb_tree_color {
    _S_red=0,
    _S_black=1
} _Rb_tree_color;

typedef struct _Rb_tree_node_base *_Base_ptr;

struct _Rb_tree_node_base {
    enum _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;
};

struct _Rb_tree_header {
    struct _Rb_tree_node_base _M_header;
    size_t _M_node_count;
};

struct binary_function<int,_int,_bool> { // Original name: binary_function<int, int, bool>
};

struct less<int> {
    struct binary_function<int,_int,_bool> super_binary_function<int,_int,_bool>;
};

struct _Rb_tree_key_compare<std::less<int>_> { // Original name: _Rb_tree_key_compare<std::less<int> >
    struct less<int> _M_key_compare;
};

struct __new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> { // Original name: __new_allocator<std::_Rb_tree_node<std::pair<int const, int> > >
};

struct allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> { // Original name: allocator<std::_Rb_tree_node<std::pair<int const, int> > >
    struct __new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> super___new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>;
};

struct _Rb_tree_impl<std::less<int>,_true> { // Original name: _Rb_tree_impl<std::less<int>, true>
    struct _Rb_tree_key_compare<std::less<int>_> super__Rb_tree_key_compare<std::less<int>_>;
    struct allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> super_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>;
    undefined field2_0x0;
    undefined field3_0x1;
    undefined field4_0x2;
    undefined field5_0x3;
    struct _Rb_tree_header super__Rb_tree_header;
};

struct _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> { // Original name: _Rb_tree<int, std::pair<int const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>, std::allocator<std::pair<int const, int> > >
    struct _Rb_tree_impl<std::less<int>,_true> _M_impl;
};

struct map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> { // Original name: map<int, int, std::less<int>, std::allocator<std::pair<int const, int> > >
    _Rep_type _M_t;
};

struct SPIHelper {
    struct map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> _usingIRQs;
};

struct SPIClassRP2040 {
    struct HardwareSPI super_HardwareSPI;
    spi_inst_t *_spi;
    struct SPISettings _spis;
    pin_size_t _RX;
    pin_size_t _TX;
    pin_size_t _SCK;
    pin_size_t _CS;
    bool _hwCS;
    bool _running;
    bool _initted;
    int _channelDMA;
    int _channelSendDMA;
    uint8_t *_dmaBuffer;
    int _dmaBytes;
    uint8_t *_rxFinalBuffer;
    uint32_t _dummy;
    struct SPIHelper _helper;
};

typedef struct __locale_t __locale_t, *P__locale_t;

typedef struct _reent _reent, *P_reent;

typedef struct 10_mbstate_t 10_mbstate_t, *P10_mbstate_t;

typedef struct 10_mbstate_t _mbstate_t;

typedef _mbstate_t mbstate_t;

typedef struct __sFILE __sFILE, *P__sFILE;

typedef struct __sFILE __FILE;

typedef struct _mprec _mprec, *P_mprec;

typedef struct _rand48 _rand48, *P_rand48;

typedef struct __tm __tm, *P__tm;

typedef struct _misc_reent _misc_reent, *P_misc_reent;

typedef union anon_union_4_2_91654ee9_for___value anon_union_4_2_91654ee9_for___value, *Panon_union_4_2_91654ee9_for___value;

typedef struct lconv lconv, *Plconv;

typedef struct __sbuf __sbuf, *P__sbuf;

typedef struct __lock __lock, *P__lock;

typedef struct __lock _flock_t;

typedef struct _Bigint _Bigint, *P_Bigint;

union anon_union_4_2_91654ee9_for___value {
    wint_t __wch;
    uchar __wchb[4];
};

struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_p_sign_posn;
};

struct __lock {
    longlong x;
};

struct _Bigint {
    struct _Bigint *_next;
    int _k;
    int _maxwds;
    int _sign;
    int _wds;
    __ULong _x[1];
};

struct _rand48 {
    ushort _seed[3];
    ushort _mult[3];
    ushort _add;
    ulonglong _rand_next;
};

struct _reent {
    int _errno;
    __FILE *_stdin;
    __FILE *_stdout;
    __FILE *_stderr;
    int _inc;
    char *_emergency;
    struct __locale_t *_locale;
    struct _mprec *_mp;
    void (*__cleanup)(struct _reent *);
    int _gamma_signgam;
    int _cvtlen;
    char *_cvtbuf;
    struct _rand48 *_r48;
    struct __tm *_localtime_buf;
    char *_asctime_buf;
    void (**_sig_func)(int);
    __FILE *__sf;
    struct _misc_reent *_misc;
    char *_signal_buf;
};

struct __sbuf {
    uchar *_base;
    int _size;
};

struct 10_mbstate_t {
    int __count;
    union anon_union_4_2_91654ee9_for___value __value;
};

struct __sFILE {
    uchar *_p;
    int _r;
    int _w;
    short _flags;
    short _file;
    struct __sbuf _bf;
    int _lbfsize;
    struct _reent *_data;
    void *_cookie;
    _ssize_t (*_read)(struct _reent *, void *, char *, int);
    _ssize_t (*_write)(struct _reent *, void *, char *, int);
    _fpos_t (*_seek)(struct _reent *, void *, _fpos_t, int);
    int (*_close)(struct _reent *, void *);
    struct __sbuf _ub;
    uchar *_up;
    int _ur;
    uchar _ubuf[3];
    uchar _nbuf[1];
    struct __sbuf _lb;
    int _blksize;
    _off_t _offset;
    _flock_t _lock;
    _mbstate_t _mbstate;
    int _flags2;
    undefined field24_0x6c;
    undefined field25_0x6d;
    undefined field26_0x6e;
    undefined field27_0x6f;
};

struct _misc_reent {
    char *_strtok_last;
    _mbstate_t _mblen_state;
    _mbstate_t _wctomb_state;
    _mbstate_t _mbtowc_state;
    char _l64a_buf[8];
    int _getdate_err;
    _mbstate_t _mbrlen_state;
    _mbstate_t _mbrtowc_state;
    _mbstate_t _mbsrtowcs_state;
    _mbstate_t _wcrtomb_state;
    _mbstate_t _wcsrtombs_state;
};

struct __tm {
    int __tm_sec;
    int __tm_min;
    int __tm_hour;
    int __tm_mday;
    int __tm_mon;
    int __tm_year;
    int __tm_wday;
    int __tm_yday;
    int __tm_isdst;
};

struct __locale_t {
    char categories[7][32];
    int (*wctomb)(struct _reent *, char *, wchar_t, mbstate_t *);
    int (*mbtowc)(struct _reent *, wchar_t *, char *, size_t, mbstate_t *);
    int cjk_lang;
    char *ctype_ptr;
    struct lconv lconv;
    char mb_cur_max[2];
    char ctype_codeset[32];
    char message_codeset[32];
};

struct _mprec {
    struct _Bigint *_result;
    int _result_k;
    struct _Bigint *_p5s;
    struct _Bigint **_freelist;
};

typedef void (*_sig_func_ptr)(int);

typedef enum 16SEMIHOST_OPCODES {
    SEMIHOST_SYS_OPEN=1,
    SEMIHOST_SYS_CLOSE=2,
    SEMIHOST_SYS_WRITEC=3,
    SEMIHOST_SYS_WRITE0=4,
    SEMIHOST_SYS_WRITE=5,
    SEMIHOST_SYS_READ=6,
    SEMIHOST_SYS_READC=7,
    SEMIHOST_SYS_ISERROR=8,
    SEMIHOST_SYS_ISTTY=9,
    SEMIHOST_SYS_SEEK=10,
    SEMIHOST_SYS_FLEN=12,
    SEMIHOST_SYS_TMPNAM=13,
    SEMIHOST_SYS_REMOVE=14,
    SEMIHOST_SYS_RENAME=15,
    SEMIHOST_SYS_CLOCK=16,
    SEMIHOST_SYS_TIME=17,
    SEMIHOST_SYS_SYSTEM=18,
    SEMIHOST_SYS_ERRNO=19,
    SEMIHOST_SYS_GET_CMDLINE=21,
    SEMIHOST_SYS_HEAPINFO=22,
    SEMIHOST_SYS_ELAPSED=48,
    SEMIHOST_SYS_TICKFREQ=49
} 16SEMIHOST_OPCODES;

typedef enum 16SEMIHOST_OPCODES SEMIHOST_OPCODES;

typedef enum 24cdc_comm_sublcass_type_t {
    CDC_COMM_SUBCLASS_DIRECT_LINE_CONTROL_MODEL=1,
    CDC_COMM_SUBCLASS_ABSTRACT_CONTROL_MODEL=2,
    CDC_COMM_SUBCLASS_TELEPHONE_CONTROL_MODEL=3,
    CDC_COMM_SUBCLASS_MULTICHANNEL_CONTROL_MODEL=4,
    CDC_COMM_SUBCLASS_CAPI_CONTROL_MODEL=5,
    CDC_COMM_SUBCLASS_ETHERNET_CONTROL_MODEL=6,
    CDC_COMM_SUBCLASS_ATM_NETWORKING_CONTROL_MODEL=7,
    CDC_COMM_SUBCLASS_WIRELESS_HANDSET_CONTROL_MODEL=8,
    CDC_COMM_SUBCLASS_DEVICE_MANAGEMENT=9,
    CDC_COMM_SUBCLASS_MOBILE_DIRECT_LINE_MODEL=10,
    CDC_COMM_SUBCLASS_OBEX=11,
    CDC_COMM_SUBCLASS_ETHERNET_EMULATION_MODEL=12,
    CDC_COMM_SUBCLASS_NETWORK_CONTROL_MODEL=13
} 24cdc_comm_sublcass_type_t;

typedef enum 24cdc_comm_sublcass_type_t cdc_comm_sublcass_type_t;

typedef struct 17cdc_line_coding_t 17cdc_line_coding_t, *P17cdc_line_coding_t;

struct 17cdc_line_coding_t {
    uint32_t bit_rate;
    uint8_t stop_bits;
    uint8_t parity;
    uint8_t data_bits;
};

typedef struct 17cdc_line_coding_t cdc_line_coding_t;

typedef enum 24cdc_comm_protocol_type_t {
    CDC_COMM_PROTOCOL_NONE=0,
    CDC_COMM_PROTOCOL_ATCOMMAND=1,
    CDC_COMM_PROTOCOL_ATCOMMAND_PCCA_101=2,
    CDC_COMM_PROTOCOL_ATCOMMAND_PCCA_101_AND_ANNEXO=3,
    CDC_COMM_PROTOCOL_ATCOMMAND_GSM_707=4,
    CDC_COMM_PROTOCOL_ATCOMMAND_3GPP_27007=5,
    CDC_COMM_PROTOCOL_ATCOMMAND_CDMA=6,
    CDC_COMM_PROTOCOL_ETHERNET_EMULATION_MODEL=7
} 24cdc_comm_protocol_type_t;

typedef struct cdc_line_coding_t.conflict cdc_line_coding_t.conflict, *Pcdc_line_coding_t.conflict;

struct cdc_line_coding_t.conflict {
    uint32_t bit_rate;
    uint8_t stop_bits;
    uint8_t parity;
    uint8_t data_bits;
};

typedef enum 24cdc_comm_protocol_type_t cdc_comm_protocol_type_t;

typedef enum 20cdc_func_desc_type_t {
    CDC_FUNC_DESC_HEADER=0,
    CDC_FUNC_DESC_CALL_MANAGEMENT=1,
    CDC_FUNC_DESC_ABSTRACT_CONTROL_MANAGEMENT=2,
    CDC_FUNC_DESC_DIRECT_LINE_MANAGEMENT=3,
    CDC_FUNC_DESC_TELEPHONE_RINGER=4,
    CDC_FUNC_DESC_TELEPHONE_CALL_AND_LINE_STATE_REPORTING_CAPACITY=5,
    CDC_FUNC_DESC_UNION=6,
    CDC_FUNC_DESC_COUNTRY_SELECTION=7,
    CDC_FUNC_DESC_TELEPHONE_OPERATIONAL_MODES=8,
    CDC_FUNC_DESC_USB_TERMINAL=9,
    CDC_FUNC_DESC_NETWORK_CHANNEL_TERMINAL=10,
    CDC_FUNC_DESC_PROTOCOL_UNIT=11,
    CDC_FUNC_DESC_EXTENSION_UNIT=12,
    CDC_FUNC_DESC_MULTICHANEL_MANAGEMENT=13,
    CDC_FUNC_DESC_CAPI_CONTROL_MANAGEMENT=14,
    CDC_FUNC_DESC_ETHERNET_NETWORKING=15,
    CDC_FUNC_DESC_ATM_NETWORKING=16,
    CDC_FUNC_DESC_WIRELESS_HANDSET_CONTROL_MODEL=17,
    CDC_FUNC_DESC_MOBILE_DIRECT_LINE_MODEL=18,
    CDC_FUNC_DESC_MOBILE_DIRECT_LINE_MODEL_DETAIL=19,
    CDC_FUNC_DESC_DEVICE_MANAGEMENT_MODEL=20,
    CDC_FUNC_DESC_OBEX=21,
    CDC_FUNC_DESC_COMMAND_SET=22,
    CDC_FUNC_DESC_COMMAND_SET_DETAIL=23,
    CDC_FUNC_DESC_TELEPHONE_CONTROL_MODEL=24,
    CDC_FUNC_DESC_OBEX_SERVICE_IDENTIFIER=25,
    CDC_FUNC_DESC_NCM=26
} 20cdc_func_desc_type_t;

typedef enum 20cdc_func_desc_type_t cdc_func_desc_type_t;

typedef struct tu_edpt_state_t tu_edpt_state_t, *Ptu_edpt_state_t;

struct tu_edpt_state_t {
    uint8_t busy:1;
    uint8_t stalled:1;
    uint8_t claimed:1;
};

typedef struct tu_edpt_stream_t tu_edpt_stream_t, *Ptu_edpt_stream_t;

typedef struct anon_struct_1_2_e05f1c3f_for_tu_edpt_stream_t_0 anon_struct_1_2_e05f1c3f_for_tu_edpt_stream_t_0, *Panon_struct_1_2_e05f1c3f_for_tu_edpt_stream_t_0;

typedef struct tu_fifo_t tu_fifo_t, *Ptu_fifo_t;

typedef struct mutex mutex, *Pmutex;

typedef struct mutex osal_mutex_def_t;

typedef struct anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2 anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2, *Panon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2;

typedef struct mutex *osal_mutex_t;

typedef struct lock_core lock_core, *Plock_core;

typedef struct lock_core lock_core_t;

typedef uint8_t spin_lock_t;

struct anon_struct_1_2_e05f1c3f_for_tu_edpt_stream_t_0 {
    uint8_t is_host:1;
    uint8_t is_mps512:1;
};

struct anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2 {
    uint16_t item_size:15;
    _Bool overwritable:1;
};

struct lock_core {
    spin_lock_t *spin_lock;
};

struct mutex {
    lock_core_t core;
    int8_t owner;
};

struct tu_fifo_t {
    uint8_t *buffer;
    uint16_t depth;
    struct anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2 field_2;
    uint16_t wr_idx;
    uint16_t rd_idx;
    osal_mutex_t mutex_wr;
    osal_mutex_t mutex_rd;
};

struct tu_edpt_stream_t {
    struct anon_struct_1_2_e05f1c3f_for_tu_edpt_stream_t_0 field_0;
    uint8_t ep_addr;
    uint16_t ep_bufsize;
    uint8_t *ep_buf;
    struct tu_fifo_t ff;
    osal_mutex_def_t ff_mutexdef;
};

typedef struct 11pio_sm_hw_t 11pio_sm_hw_t, *P11pio_sm_hw_t;

typedef struct 11pio_sm_hw_t pio_sm_hw_t;

struct 11pio_sm_hw_t {
    io_rw_32 clkdiv;
    io_rw_32 execctrl;
    io_rw_32 shiftctrl;
    io_ro_32 addr;
    io_rw_32 instr;
    io_rw_32 pinctrl;
};

typedef struct 8pio_hw_t 8pio_hw_t, *P8pio_hw_t;

typedef struct 8pio_hw_t pio_hw_t;

typedef pio_hw_t *PIO;

typedef union anon_union_24_2_95a08ed8_for_8pio_hw_t_18 anon_union_24_2_95a08ed8_for_8pio_hw_t_18, *Panon_union_24_2_95a08ed8_for_8pio_hw_t_18;

typedef struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_8pio_hw_t_18_1 anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_8pio_hw_t_18_1, *Panon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_8pio_hw_t_18_1;

typedef struct 17pio_irq_ctrl_hw_t 17pio_irq_ctrl_hw_t, *P17pio_irq_ctrl_hw_t;

typedef struct 17pio_irq_ctrl_hw_t pio_irq_ctrl_hw_t;

struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_8pio_hw_t_18_1 {
    io_rw_32 inte0;
    io_rw_32 intf0;
    io_ro_32 ints0;
    io_rw_32 inte1;
    io_rw_32 intf1;
    io_ro_32 ints1;
};

struct 17pio_irq_ctrl_hw_t {
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

union anon_union_24_2_95a08ed8_for_8pio_hw_t_18 {
    struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_8pio_hw_t_18_1 field_0;
    pio_irq_ctrl_hw_t irq_ctrl[2];
};

struct 8pio_hw_t {
    io_rw_32 ctrl;
    io_ro_32 fstat;
    io_rw_32 fdebug;
    io_ro_32 flevel;
    io_wo_32 txf[4];
    io_ro_32 rxf[4];
    io_rw_32 irq;
    io_wo_32 irq_force;
    io_rw_32 input_sync_bypass;
    io_ro_32 dbg_padout;
    io_ro_32 dbg_padoe;
    io_ro_32 dbg_cfginfo;
    io_wo_32 instr_mem[32];
    pio_sm_hw_t sm[4];
    io_rw_32 rxf_putget[4][4];
    io_rw_32 gpiobase;
    io_ro_32 intr;
    union anon_union_24_2_95a08ed8_for_8pio_hw_t_18 field_17;
};

typedef struct pio_sm_hw_t.conflict pio_sm_hw_t.conflict, *Ppio_sm_hw_t.conflict;

struct pio_sm_hw_t.conflict {
    io_rw_32 clkdiv;
    io_rw_32 execctrl;
    io_rw_32 shiftctrl;
    io_ro_32 addr;
    io_rw_32 instr;
    io_rw_32 pinctrl;
};

typedef struct pio_program pio_program, *Ppio_program;

typedef struct pio_program pio_program_t;

struct pio_program {
    uint16_t *instructions;
    uint8_t length;
    int8_t origin;
    uint8_t pio_version;
    uint8_t used_gpio_ranges;
};

typedef struct pio_hw_t.conflict pio_hw_t.conflict, *Ppio_hw_t.conflict;

typedef union anon_union_24_2_95a08ed8_for_pio_hw_t_17 anon_union_24_2_95a08ed8_for_pio_hw_t_17, *Panon_union_24_2_95a08ed8_for_pio_hw_t_17;

typedef struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_pio_hw_t_17_0 anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_pio_hw_t_17_0, *Panon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_pio_hw_t_17_0;

struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_pio_hw_t_17_0 {
    io_rw_32 inte0;
    io_rw_32 intf0;
    io_ro_32 ints0;
    io_rw_32 inte1;
    io_rw_32 intf1;
    io_ro_32 ints1;
};

union anon_union_24_2_95a08ed8_for_pio_hw_t_17 {
    struct anon_struct_24_6_82a6b275_for_anon_union_24_2_95a08ed8_for_pio_hw_t_17_0 field_0;
    pio_irq_ctrl_hw_t irq_ctrl[2];
};

struct pio_hw_t.conflict {
    io_rw_32 ctrl;
    io_ro_32 fstat;
    io_rw_32 fdebug;
    io_ro_32 flevel;
    io_wo_32 txf[4];
    io_ro_32 rxf[4];
    io_rw_32 irq;
    io_wo_32 irq_force;
    io_rw_32 input_sync_bypass;
    io_ro_32 dbg_padout;
    io_ro_32 dbg_padoe;
    io_ro_32 dbg_cfginfo;
    io_wo_32 instr_mem[32];
    pio_sm_hw_t sm[4];
    io_wo_32 rxf_putget[4][4];
    io_rw_32 gpiobase;
    io_ro_32 intr;
    union anon_union_24_2_95a08ed8_for_pio_hw_t_17 field_17;
};

typedef struct pio_irq_ctrl_hw_t.conflict pio_irq_ctrl_hw_t.conflict, *Ppio_irq_ctrl_hw_t.conflict;

struct pio_irq_ctrl_hw_t.conflict {
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef struct 13pio_sm_config 13pio_sm_config, *P13pio_sm_config;

struct 13pio_sm_config {
    uint32_t clkdiv;
    uint32_t execctrl;
    uint32_t shiftctrl;
    uint32_t pinctrl;
    uint32_t pinhi;
};

typedef struct pio_sm_config.conflict pio_sm_config.conflict, *Ppio_sm_config.conflict;

struct pio_sm_config.conflict {
    uint32_t clkdiv;
    uint32_t execctrl;
    uint32_t shiftctrl;
    uint32_t pinctrl;
    uint32_t pinhi;
};

typedef struct 13pio_sm_config pio_sm_config;

typedef void (*hardware_alarm_callback_t)(uint);

typedef struct 10timer_hw_t 10timer_hw_t, *P10timer_hw_t;

typedef struct 10timer_hw_t timer_hw_t;

struct 10timer_hw_t {
    io_wo_32 timehw;
    io_wo_32 timelw;
    io_ro_32 timehr;
    io_ro_32 timelr;
    io_rw_32 alarm[4];
    io_rw_32 armed;
    io_ro_32 timerawh;
    io_ro_32 timerawl;
    io_rw_32 dbgpause;
    io_rw_32 pause;
    io_rw_32 locked;
    io_rw_32 source;
    io_rw_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef struct timer_hw_t.conflict timer_hw_t.conflict, *Ptimer_hw_t.conflict;

struct timer_hw_t.conflict {
    io_wo_32 timehw;
    io_wo_32 timelw;
    io_ro_32 timehr;
    io_ro_32 timelr;
    io_rw_32 alarm[4];
    io_rw_32 armed;
    io_ro_32 timerawh;
    io_ro_32 timerawl;
    io_rw_32 dbgpause;
    io_rw_32 pause;
    io_rw_32 locked;
    io_rw_32 source;
    io_rw_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef enum cache_op_t {
    XIP_CACHE_INVALIDATE_BY_SET_WAY=0,
    XIP_CACHE_CLEAN_BY_SET_WAY=1,
    XIP_CACHE_INVALIDATE_BY_ADDRESS=2,
    XIP_CACHE_CLEAN_BY_ADDRESS=3,
    XIP_CACHE_OP_MAX=7,
    XIP_CACHE_PIN_AT_ADDRESS=7
} cache_op_t;

typedef struct _Index_tuple<0> _Index_tuple<0>, *P_Index_tuple<0>;

struct _Index_tuple<0> {
};

typedef struct repeating_timer repeating_timer, *Prepeating_timer;

typedef struct repeating_timer repeating_timer_t;

typedef _Bool (*repeating_timer_callback_t)(repeating_timer_t *);

typedef __int64_t int64_t;

typedef struct alarm_pool alarm_pool, *Palarm_pool;

typedef struct alarm_pool alarm_pool_t;

typedef __int32_t int32_t;

typedef int32_t alarm_id_t;

typedef __int16_t int16_t;

typedef void alarm_pool_timer_t;

typedef struct alarm_pool_entry alarm_pool_entry, *Palarm_pool_entry;

typedef struct alarm_pool_entry alarm_pool_entry_t;

typedef int64_t (*alarm_callback_t)(alarm_id_t, void *);

struct alarm_pool {
    uint8_t timer_alarm_num;
    uint8_t core_num;
    int16_t free_head;
    int16_t new_head;
    _Bool has_pending_cancellations;
    int16_t ordered_head;
    uint16_t num_entries;
    alarm_pool_timer_t *timer;
    spin_lock_t *lock;
    alarm_pool_entry_t *entries;
};

struct alarm_pool_entry {
    int16_t next;
    uint16_t sequence;
    undefined field2_0x4;
    undefined field3_0x5;
    undefined field4_0x6;
    undefined field5_0x7;
    int64_t target;
    alarm_callback_t callback;
    void *user_data;
};

struct repeating_timer {
    int64_t delay_us;
    alarm_pool_t *pool;
    alarm_id_t alarm_id;
    repeating_timer_callback_t callback;
    void *user_data;
};

typedef struct timezone timezone, *Ptimezone;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef struct mallinfo mallinfo, *Pmallinfo;

struct mallinfo {
    size_t arena;
    size_t ordblks;
    size_t smblks;
    size_t hblks;
    size_t hblkhd;
    size_t usmblks;
    size_t fsmblks;
    size_t uordblks;
    size_t fordblks;
    size_t keepcost;
};

typedef enum 12tusb_speed_t {
    TUSB_SPEED_FULL=0,
    TUSB_SPEED_LOW=1,
    TUSB_SPEED_HIGH=2,
    TUSB_SPEED_AUTO=170,
    TUSB_SPEED_INVALID=255
} 12tusb_speed_t;

typedef enum 12tusb_speed_t tusb_speed_t;

typedef enum tusb_role_t.conflict {
    TUSB_ROLE_INVALID=0,
    TUSB_ROLE_DEVICE=1,
    TUSB_ROLE_HOST=2
} tusb_role_t.conflict;

typedef struct tusb_desc_configuration_t tusb_desc_configuration_t, *Ptusb_desc_configuration_t;

struct tusb_desc_configuration_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t wTotalLength;
    uint8_t bNumInterfaces;
    uint8_t bConfigurationValue;
    uint8_t iConfiguration;
    uint8_t bmAttributes;
    uint8_t bMaxPower;
};

typedef struct 18tusb_rhport_init_t 18tusb_rhport_init_t, *P18tusb_rhport_init_t;

typedef struct 18tusb_rhport_init_t tusb_rhport_init_t;

typedef enum 11tusb_role_t {
    TUSB_ROLE_INVALID=0,
    TUSB_ROLE_DEVICE=1,
    TUSB_ROLE_HOST=2
} 11tusb_role_t;

typedef enum 11tusb_role_t tusb_role_t;

struct 18tusb_rhport_init_t {
    tusb_role_t role;
    tusb_speed_t speed;
};

typedef struct 18tusb_desc_device_t 18tusb_desc_device_t, *P18tusb_desc_device_t;

struct 18tusb_desc_device_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint16_t bcdUSB;
    uint8_t bDeviceClass;
    uint8_t bDeviceSubClass;
    uint8_t bDeviceProtocol;
    uint8_t bMaxPacketSize0;
    uint16_t idVendor;
    uint16_t idProduct;
    uint16_t bcdDevice;
    uint8_t iManufacturer;
    uint8_t iProduct;
    uint8_t iSerialNumber;
    uint8_t bNumConfigurations;
};

typedef struct tusb_desc_interface_t tusb_desc_interface_t, *Ptusb_desc_interface_t;

struct tusb_desc_interface_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bInterfaceNumber;
    uint8_t bAlternateSetting;
    uint8_t bNumEndpoints;
    uint8_t bInterfaceClass;
    uint8_t bInterfaceSubClass;
    uint8_t bInterfaceProtocol;
    uint8_t iInterface;
};

typedef struct tusb_control_request_t tusb_control_request_t, *Ptusb_control_request_t;

typedef union anon_union_1_2_33686c6f_for_tusb_control_request_t_0 anon_union_1_2_33686c6f_for_tusb_control_request_t_0, *Panon_union_1_2_33686c6f_for_tusb_control_request_t_0;

typedef struct anon_struct_1_3_c2a4d91e_for_bmRequestType_bit anon_struct_1_3_c2a4d91e_for_bmRequestType_bit, *Panon_struct_1_3_c2a4d91e_for_bmRequestType_bit;

struct anon_struct_1_3_c2a4d91e_for_bmRequestType_bit {
    uint8_t recipient:5;
    uint8_t type:2;
    uint8_t direction:1;
};

union anon_union_1_2_33686c6f_for_tusb_control_request_t_0 {
    struct anon_struct_1_3_c2a4d91e_for_bmRequestType_bit bmRequestType_bit;
    uint8_t bmRequestType;
};

struct tusb_control_request_t {
    union anon_union_1_2_33686c6f_for_tusb_control_request_t_0 field_0;
    uint8_t bRequest;
    uint16_t wValue;
    uint16_t wIndex;
    uint16_t wLength;
};

typedef enum 17tusb_class_code_t {
    TUSB_CLASS_UNSPECIFIED=0,
    TUSB_CLASS_AUDIO=1,
    TUSB_CLASS_CDC=2,
    TUSB_CLASS_HID=3,
    TUSB_CLASS_RESERVED_4=4,
    TUSB_CLASS_PHYSICAL=5,
    TUSB_CLASS_IMAGE=6,
    TUSB_CLASS_PRINTER=7,
    TUSB_CLASS_MSC=8,
    TUSB_CLASS_HUB=9,
    TUSB_CLASS_CDC_DATA=10,
    TUSB_CLASS_SMART_CARD=11,
    TUSB_CLASS_RESERVED_12=12,
    TUSB_CLASS_CONTENT_SECURITY=13,
    TUSB_CLASS_VIDEO=14,
    TUSB_CLASS_PERSONAL_HEALTHCARE=15,
    TUSB_CLASS_AUDIO_VIDEO=16,
    TUSB_CLASS_DIAGNOSTIC=220,
    TUSB_CLASS_WIRELESS_CONTROLLER=224,
    TUSB_CLASS_MISC=239,
    TUSB_CLASS_APPLICATION_SPECIFIC=254,
    TUSB_CLASS_VENDOR_SPECIFIC=255
} 17tusb_class_code_t;

typedef enum 17tusb_class_code_t tusb_class_code_t;

typedef struct tusb_rhport_init_t.conflict tusb_rhport_init_t.conflict, *Ptusb_rhport_init_t.conflict;

typedef enum tusb_speed_t.conflict {
    TUSB_SPEED_FULL=0,
    TUSB_SPEED_LOW=1,
    TUSB_SPEED_HIGH=2,
    TUSB_SPEED_AUTO=170,
    TUSB_SPEED_INVALID=255
} tusb_speed_t.conflict;

struct tusb_rhport_init_t.conflict {
    enum tusb_role_t.conflict role;
    enum tusb_speed_t.conflict speed;
};

typedef enum 16tusb_desc_type_t {
    TUSB_DESC_DEVICE=1,
    TUSB_DESC_CONFIGURATION=2,
    TUSB_DESC_STRING=3,
    TUSB_DESC_INTERFACE=4,
    TUSB_DESC_ENDPOINT=5,
    TUSB_DESC_DEVICE_QUALIFIER=6,
    TUSB_DESC_OTHER_SPEED_CONFIG=7,
    TUSB_DESC_INTERFACE_POWER=8,
    TUSB_DESC_OTG=9,
    TUSB_DESC_DEBUG=10,
    TUSB_DESC_INTERFACE_ASSOCIATION=11,
    TUSB_DESC_BOS=15,
    TUSB_DESC_DEVICE_CAPABILITY=16,
    TUSB_DESC_CS_DEVICE=33,
    TUSB_DESC_FUNCTIONAL=33,
    TUSB_DESC_CS_CONFIGURATION=34,
    TUSB_DESC_CS_STRING=35,
    TUSB_DESC_CS_INTERFACE=36,
    TUSB_DESC_CS_ENDPOINT=37,
    TUSB_DESC_SUPERSPEED_ENDPOINT_COMPANION=48,
    TUSB_DESC_SUPERSPEED_ISO_ENDPOINT_COMPANION=49
} 16tusb_desc_type_t;

typedef enum 16tusb_desc_type_t tusb_desc_type_t;

typedef enum 16tusb_xfer_type_t {
    TUSB_XFER_CONTROL=0,
    TUSB_XFER_ISOCHRONOUS=1,
    TUSB_XFER_BULK=2,
    TUSB_XFER_INTERRUPT=3
} 16tusb_xfer_type_t;

typedef struct tusb_desc_interface_assoc_t tusb_desc_interface_assoc_t, *Ptusb_desc_interface_assoc_t;

struct tusb_desc_interface_assoc_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bFirstInterface;
    uint8_t bInterfaceCount;
    uint8_t bFunctionClass;
    uint8_t bFunctionSubClass;
    uint8_t bFunctionProtocol;
    uint8_t iFunction;
};

typedef struct tusb_desc_endpoint_t tusb_desc_endpoint_t, *Ptusb_desc_endpoint_t;

typedef struct anon_struct_1_3_651f31f1_for_bmAttributes anon_struct_1_3_651f31f1_for_bmAttributes, *Panon_struct_1_3_651f31f1_for_bmAttributes;

struct anon_struct_1_3_651f31f1_for_bmAttributes {
    uint8_t xfer:2;
    uint8_t sync:2;
    uint8_t usage:2;
};

struct tusb_desc_endpoint_t {
    uint8_t bLength;
    uint8_t bDescriptorType;
    uint8_t bEndpointAddress;
    struct anon_struct_1_3_651f31f1_for_bmAttributes bmAttributes;
    uint16_t wMaxPacketSize;
    uint8_t bInterval;
};

typedef struct 18tusb_desc_device_t tusb_desc_device_t;

typedef enum xfer_result_t {
    XFER_RESULT_SUCCESS=0,
    XFER_RESULT_FAILED=1,
    XFER_RESULT_STALLED=2,
    XFER_RESULT_TIMEOUT=3,
    XFER_RESULT_INVALID=4
} xfer_result_t;

typedef enum tusb_dir_t {
    TUSB_DIR_OUT=0,
    TUSB_DIR_IN=1,
    TUSB_DIR_IN_MASK=128
} tusb_dir_t;

typedef enum 16tusb_xfer_type_t tusb_xfer_type_t;

typedef enum tusb_desc_type_t.conflict {
    TUSB_DESC_DEVICE=1,
    TUSB_DESC_CONFIGURATION=2,
    TUSB_DESC_STRING=3,
    TUSB_DESC_INTERFACE=4,
    TUSB_DESC_ENDPOINT=5,
    TUSB_DESC_DEVICE_QUALIFIER=6,
    TUSB_DESC_OTHER_SPEED_CONFIG=7,
    TUSB_DESC_INTERFACE_POWER=8,
    TUSB_DESC_OTG=9,
    TUSB_DESC_DEBUG=10,
    TUSB_DESC_INTERFACE_ASSOCIATION=11,
    TUSB_DESC_BOS=15,
    TUSB_DESC_DEVICE_CAPABILITY=16,
    TUSB_DESC_CS_DEVICE=33,
    TUSB_DESC_FUNCTIONAL=33,
    TUSB_DESC_CS_CONFIGURATION=34,
    TUSB_DESC_CS_STRING=35,
    TUSB_DESC_CS_INTERFACE=36,
    TUSB_DESC_CS_ENDPOINT=37,
    TUSB_DESC_SUPERSPEED_ENDPOINT_COMPANION=48,
    TUSB_DESC_SUPERSPEED_ISO_ENDPOINT_COMPANION=49
} tusb_desc_type_t.conflict;

typedef struct tms tms, *Ptms;

struct tms {
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};

typedef struct _Select1st<std::pair<int_const,_int>_> _Select1st<std::pair<int_const,_int>_>, *P_Select1st<std::pair<int_const,_int>_>;

typedef struct unary_function<std::pair<int_const,_int>,_int_const> unary_function<std::pair<int_const,_int>,_int_const>, *Punary_function<std::pair<int_const,_int>,_int_const>;

struct unary_function<std::pair<int_const,_int>,_int_const> { // Original name: unary_function<std::pair<int const, int>, int const>
};

struct _Select1st<std::pair<int_const,_int>_> { // Original name: _Select1st<std::pair<int const, int> >
    struct unary_function<std::pair<int_const,_int>,_int_const> super_unary_function<std::pair<int_const,_int>,_int_const>;
};

typedef struct binary_function<const_pio_program*,_const_pio_program*,_bool> binary_function<const_pio_program*,_const_pio_program*,_bool>, *Pbinary_function<const_pio_program*,_const_pio_program*,_bool>;

struct binary_function<const_pio_program*,_const_pio_program*,_bool> { // Original name: binary_function<const pio_program*, const pio_program*, bool>
};

typedef struct less<const_pio_program*> less<const_pio_program*>, *Pless<const_pio_program*>;

struct less<const_pio_program*> { // Original name: less<const pio_program*>
    struct binary_function<const_pio_program*,_const_pio_program*,_bool> super_binary_function<const_pio_program*,_const_pio_program*,_bool>;
};

typedef struct _Select1st<std::pair<const_pio_program*_const,_int>_> _Select1st<std::pair<const_pio_program*_const,_int>_>, *P_Select1st<std::pair<const_pio_program*_const,_int>_>;

typedef struct unary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const> unary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const>, *Punary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const>;

struct unary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const> { // Original name: unary_function<std::pair<const pio_program* const, int>, const pio_program* const>
};

struct _Select1st<std::pair<const_pio_program*_const,_int>_> { // Original name: _Select1st<std::pair<const pio_program* const, int> >
    struct unary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const> super_unary_function<std::pair<const_pio_program*_const,_int>,_const_pio_program*_const>;
};

typedef struct critical_section critical_section, *Pcritical_section;

typedef struct critical_section critical_section_t;

struct critical_section {
    spin_lock_t *spin_lock;
    uint32_t save;
};

typedef struct flash_hardware_save_state flash_hardware_save_state, *Pflash_hardware_save_state;

typedef struct flash_hardware_save_state flash_hardware_save_state_t;

typedef struct flash_rp2350_qmi_save_state flash_rp2350_qmi_save_state, *Pflash_rp2350_qmi_save_state;

typedef struct flash_rp2350_qmi_save_state flash_rp2350_qmi_save_state_t;

struct flash_rp2350_qmi_save_state {
    uint32_t timing;
    uint32_t rcmd;
    uint32_t rfmt;
};

struct flash_hardware_save_state {
    flash_rp2350_qmi_save_state_t qmi_save;
    uint32_t qspi_pads[6];
};

typedef union anon_union_36_2_f8194b7f anon_union_36_2_f8194b7f, *Panon_union_36_2_f8194b7f;

union anon_union_36_2_f8194b7f {
    uint32_t words[9];
    uint8_t bytes[36];
};

typedef enum flash_devinfo_size_t {
    FLASH_DEVINFO_SIZE_NONE=0,
    FLASH_DEVINFO_SIZE_8K=1,
    FLASH_DEVINFO_SIZE_16K=2,
    FLASH_DEVINFO_SIZE_32K=3,
    FLASH_DEVINFO_SIZE_64K=4,
    FLASH_DEVINFO_SIZE_128K=5,
    FLASH_DEVINFO_SIZE_256K=6,
    FLASH_DEVINFO_SIZE_512K=7,
    FLASH_DEVINFO_SIZE_1M=8,
    FLASH_DEVINFO_SIZE_2M=9,
    FLASH_DEVINFO_SIZE_4M=10,
    FLASH_DEVINFO_SIZE_8M=11,
    FLASH_DEVINFO_SIZE_16M=12,
    FLASH_DEVINFO_SIZE_MAX=12
} flash_devinfo_size_t;

typedef struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> _Rb_tree_node<std::pair<const_pio_program*_const,_int>_>, *P_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>;

typedef struct __aligned_membuf<std::pair<const_pio_program*_const,_int>_> __aligned_membuf<std::pair<const_pio_program*_const,_int>_>, *P__aligned_membuf<std::pair<const_pio_program*_const,_int>_>;

struct __aligned_membuf<std::pair<const_pio_program*_const,_int>_> { // Original name: __aligned_membuf<std::pair<const pio_program* const, int> >
    uchar _M_storage[8];
};

struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> { // Original name: _Rb_tree_node<std::pair<const pio_program* const, int> >
    struct _Rb_tree_node_base super__Rb_tree_node_base;
    struct __aligned_membuf<std::pair<const_pio_program*_const,_int>_> _M_storage;
};

typedef struct _Rb_tree_key_compare<std::less<const_pio_program*>_> _Rb_tree_key_compare<std::less<const_pio_program*>_>, *P_Rb_tree_key_compare<std::less<const_pio_program*>_>;

struct _Rb_tree_key_compare<std::less<const_pio_program*>_> { // Original name: _Rb_tree_key_compare<std::less<const pio_program*> >
    struct less<const_pio_program*> _M_key_compare;
};

typedef struct _Rb_tree_const_iterator<std::pair<int_const,_int>_> _Rb_tree_const_iterator<std::pair<int_const,_int>_>, *P_Rb_tree_const_iterator<std::pair<int_const,_int>_>;


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/_Base_ptr - /DWARF/stl_tree.h/std/_Rb_tree_node_base/_Base_ptr

struct _Rb_tree_const_iterator<std::pair<int_const,_int>_> { // Original name: _Rb_tree_const_iterator<std::pair<int const, int> >
    _Base_ptr _M_node;
};

typedef struct _Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_> _Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>, *P_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>;

typedef struct _Rb_tree_impl<std::less<const_pio_program*>,_true> _Rb_tree_impl<std::less<const_pio_program*>,_true>, *P_Rb_tree_impl<std::less<const_pio_program*>,_true>;

typedef struct allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>, *Pallocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>;

typedef struct __new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> __new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>, *P__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>;

struct __new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> { // Original name: __new_allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > >
};

struct allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> { // Original name: allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > >
    struct __new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> super___new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>;
};

struct _Rb_tree_impl<std::less<const_pio_program*>,_true> { // Original name: _Rb_tree_impl<std::less<const pio_program*>, true>
    struct _Rb_tree_key_compare<std::less<const_pio_program*>_> super__Rb_tree_key_compare<std::less<const_pio_program*>_>;
    struct allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> super_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>;
    undefined field2_0x0;
    undefined field3_0x1;
    undefined field4_0x2;
    undefined field5_0x3;
    struct _Rb_tree_header super__Rb_tree_header;
};

struct _Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: _Rb_tree<const pio_program*, std::pair<const pio_program* const, int>, std::_Select1st<std::pair<const pio_program* const, int> >, std::less<const pio_program*>, std::allocator<std::pair<const pio_program* const, int> > >
    struct _Rb_tree_impl<std::less<const_pio_program*>,_true> _M_impl;
};

typedef struct _Rb_tree_iterator<std::pair<int_const,_int>_> _Rb_tree_iterator<std::pair<int_const,_int>_>, *P_Rb_tree_iterator<std::pair<int_const,_int>_>;


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/_Base_ptr - /DWARF/stl_tree.h/std/_Rb_tree_node_base/_Base_ptr

struct _Rb_tree_iterator<std::pair<int_const,_int>_> { // Original name: _Rb_tree_iterator<std::pair<int const, int> >
    _Base_ptr _M_node;
};

typedef struct _Rb_tree_node<std::pair<int_const,_int>_> _Rb_tree_node<std::pair<int_const,_int>_>, *P_Rb_tree_node<std::pair<int_const,_int>_>;

typedef struct __aligned_membuf<std::pair<int_const,_int>_> __aligned_membuf<std::pair<int_const,_int>_>, *P__aligned_membuf<std::pair<int_const,_int>_>;

struct __aligned_membuf<std::pair<int_const,_int>_> { // Original name: __aligned_membuf<std::pair<int const, int> >
    uchar _M_storage[8];
};

struct _Rb_tree_node<std::pair<int_const,_int>_> { // Original name: _Rb_tree_node<std::pair<int const, int> >
    struct _Rb_tree_node_base super__Rb_tree_node_base;
    struct __aligned_membuf<std::pair<int_const,_int>_> _M_storage;
};

typedef struct pair<int_const,_int> pair<int_const,_int>, *Ppair<int_const,_int>;

typedef struct pair<int_const,_int> *reference;

struct pair<int_const,_int> { // Original name: pair<int const, int>
Missing member super___pair_base<int_const,_int> : __pair_base<int_const,_int> at offset 0x0 [conflicting member at same offset]
    int first;
    int second;
};

typedef struct _Rb_tree_iterator<std::pair<int_const,_int>_> _Self;

typedef struct _Rb_tree_node<std::pair<int_const,_int>_> *_Link_type;

typedef struct pair<int_const,_int> *pointer;


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>/reference - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/reference


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>/_Link_type - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/_Link_type


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/_Self - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/_Self

typedef struct _Rb_tree_iterator<std::pair<int_const,_int>_> iterator;

typedef struct _Node_insert_return<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>_> _Node_insert_return<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>_>, *P_Node_insert_return<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>_>;

typedef struct _Node_insert_return<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>_> insert_return_type;

struct _Node_insert_return<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>_> { // Original name: _Node_insert_return<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> >, std::_Node_handle<const pio_program*, std::pair<const pio_program* const, int>, std::allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > > > >
};

typedef struct _Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_> _Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>, *P_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>;

typedef struct _Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_> const_iterator;

struct _Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_> { // Original name: _Rb_tree_const_iterator<std::pair<const pio_program* const, int> >
};


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/key_type - /DWARF/key_type

typedef struct allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> rebind_alloc;

typedef rebind_alloc other;

typedef other _Node_allocator;

typedef struct reverse_iterator<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> reverse_iterator<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>, *Preverse_iterator<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>;

typedef struct reverse_iterator<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> reverse_iterator;

struct reverse_iterator<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: reverse_iterator<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> > >
};

typedef struct _Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> _Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>, *P_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>;

typedef struct _Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> node_type;

typedef struct _Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> _Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>, *P_Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>;

typedef struct pio_program **rebind;

typedef rebind __ptr_rebind.conflict;

typedef __ptr_rebind.conflict __pointer;


// WARNING! conflicting data type names: /DWARF/ptr_traits.h/std/pointer_traits<std::_Rb_tree_node<std::pair<int_const,_int>_>*>/rebind - /DWARF/ptr_traits.h/std/pointer_traits<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*>/rebind

typedef rebind __ptr_rebind;

typedef __ptr_rebind __pointer.conflict;


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer

struct _Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> { // Original name: _Node_handle_common<std::pair<const pio_program* const, int>, std::allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > > >
Missing member _M_alloc : _Optional_alloc at offset 0x0 [conflicting member at same offset]
    pointer _M_ptr;
};

struct _Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> { // Original name: _Node_handle<const pio_program*, std::pair<const pio_program* const, int>, std::allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > > >
    struct _Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> super__Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>;
    __pointer _M_pkey;
    __pointer.conflict _M_pmapped;
};

typedef struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> *_Const_Link_type;

typedef struct _Alloc_node _Alloc_node, *P_Alloc_node;

struct _Alloc_node {
    struct _Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_> *_M_t;
};

typedef struct reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_> reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_>, *Preverse_iterator<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_>;

typedef struct reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_> const_reverse_iterator;

struct reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const pio_program* const, int> > >
};


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/_Link_type - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/_Link_type

typedef size_t size_type;

typedef struct _Rb_tree_node_base *_Const_Base_ptr;

typedef struct allocator<std::pair<const_pio_program*_const,_int>_> allocator<std::pair<const_pio_program*_const,_int>_>, *Pallocator<std::pair<const_pio_program*_const,_int>_>;

typedef struct allocator<std::pair<const_pio_program*_const,_int>_> allocator_type;

typedef struct __new_allocator<std::pair<const_pio_program*_const,_int>_> __new_allocator<std::pair<const_pio_program*_const,_int>_>, *P__new_allocator<std::pair<const_pio_program*_const,_int>_>;

struct __new_allocator<std::pair<const_pio_program*_const,_int>_> { // Original name: __new_allocator<std::pair<const pio_program* const, int> >
};

struct allocator<std::pair<const_pio_program*_const,_int>_> { // Original name: allocator<std::pair<const pio_program* const, int> >
    struct __new_allocator<std::pair<const_pio_program*_const,_int>_> super___new_allocator<std::pair<const_pio_program*_const,_int>_>;
};


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/const_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/_Node_allocator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/_Node_allocator


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/node_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/node_type


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/_Alloc_node - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/_Alloc_node

typedef struct _Auto_node _Auto_node, *P_Auto_node;

struct _Auto_node {
    struct _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> *_M_t;
    _Link_type _M_node;
};


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/_Const_Link_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/_Const_Link_type


// WARNING! conflicting data type names: /DWARF/stl_tree.h/std/_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type

typedef struct USBClass USBClass, *PUSBClass;

typedef struct mutex mutex_t;

typedef struct Entry Entry, *PEntry;

struct Entry {
    void (*cb)(int, uint8_t *, int, void *);
    void *param;
    uint len:12;
    uint interfaces:4;
    uint order:18;
    uint localid:6;
    uint32_t mask;
    struct Entry *next;
};

struct USBClass {
    mutex_t mutex;
    uint8_t usbTaskIRQ;
    undefined field2_0x9;
    undefined field3_0xa;
    undefined field4_0xb;
    struct Entry *_hids;
    struct Entry *_interfaces;
    char **usbd_desc_str;
    uint8_t usbd_desc_str_cnt;
    uint8_t usbd_desc_str_alloc;
    uint8_t _hid_interface;
    uint8_t _hid_endpoint;
    uint16_t _hid_report_len;
    undefined field13_0x1e;
    undefined field14_0x1f;
    uint8_t *_hid_report;
    uint8_t *usbd_desc_cfg;
    uint16_t usbd_desc_cfg_len;
    uint16_t _endpointIn;
    uint16_t _endpointOut;
    uint16_t _forceVID;
    uint16_t _forcePID;
    uint8_t _forceManuf;
    uint8_t _forceProd;
    uint8_t _forceSerial;
    tusb_desc_device_t usbd_desc_device;
    undefined field26_0x47;
};

typedef struct _MFIFO _MFIFO, *P_MFIFO;

struct _MFIFO {
    bool _multicore;
};

typedef struct RP2040 RP2040, *PRP2040;

typedef struct PIOProgram PIOProgram, *PPIOProgram;

struct RP2040 {
    uint64_t _epoch[2];
    struct _MFIFO fifo;
    undefined field2_0x11;
    undefined field3_0x12;
    undefined field4_0x13;
    PIO _pio;
    int _sm;
    struct PIOProgram *_ccountPgm;
    int memcpyDMAChannel;
    undefined field9_0x24;
    undefined field10_0x25;
    undefined field11_0x26;
    undefined field12_0x27;
};

struct PIOProgram {
    pio_program_t *_pgm;
    PIO _pio;
    int _sm;
};

typedef enum resetReason_t {
    UNKNOWN_RESET=0,
    PWRON_RESET=1,
    RUN_PIN_RESET=2,
    SOFT_RESET=3,
    WDT_RESET=4,
    DEBUG_RESET=5,
    GLITCH_RESET=6,
    BROWNOUT_RESET=7
} resetReason_t;

typedef union _FP_UNION_D _FP_UNION_D, *P_FP_UNION_D;

typedef struct anon_struct_8_4_92b423be_for_bits anon_struct_8_4_92b423be_for_bits, *Panon_struct_8_4_92b423be_for_bits;

struct anon_struct_8_4_92b423be_for_bits {
    uint frac0:32;
    uint frac1:20;
    uint exp:11;
    uint sign:1;
};

union _FP_UNION_D {
    DFtype flt;
    struct anon_struct_8_4_92b423be_for_bits bits;
};

typedef enum anon_enum_8 {
    START=0,
    ZERO=0,
    DIGIT=1,
    SFLAG=1,
    DOLLAR=2,
    WDIG=2,
    MODFR=3,
    WIDTH=3,
    SMOD=4,
    SPEC=4,
    DOT=5,
    SDOT=5,
    STAR=6,
    VARW=6,
    FLAG=7,
    VARP=7,
    OTHER=8,
    PREC=8,
    MAX_CH_CLASS=9,
    VWDIG=9,
    VPDIG=10,
    DONE=11,
    MAX_STATE=12
} anon_enum_8;

typedef enum pio_src_dest.conflict {
    pio_pins=0,
    pio_x=1,
    pio_y=2,
    pio_null=3,
    pio_exec_mov=4,
    pio_pindirs=4,
    pio_pc=5,
    pio_status=5,
    pio_isr=6,
    pio_exec_out=7,
    pio_osr=7
} pio_src_dest.conflict;

typedef enum pio_instr_bits {
    pio_instr_bits_jmp=0,
    pio_instr_bits_wait=8192,
    pio_instr_bits_in=16384,
    pio_instr_bits_out=24576,
    pio_instr_bits_push=32768,
    pio_instr_bits_pull=32896,
    pio_instr_bits_mov=40960,
    pio_instr_bits_irq=49152,
    pio_instr_bits_set=57344
} pio_instr_bits;

typedef enum pio_src_dest {
    pio_pins=0,
    pio_x=1,
    pio_y=2,
    pio_isr=38,
    pio_osr=55,
    pio_pc=109,
    pio_exec_mov=124,
    pio_null=163,
    pio_status=189,
    pio_pindirs=204,
    pio_exec_out=239
} pio_src_dest;

typedef struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false> __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false>, *P__ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false>;

struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false> { // Original name: __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const pio_program* const, int> >*, std::_Rb_tree_node<std::pair<const pio_program* const, int> >, false>
};

typedef struct pointer_traits<std::_Rb_tree_node<std::pair<int_const,_int>_>*> pointer_traits<std::_Rb_tree_node<std::pair<int_const,_int>_>*>, *Ppointer_traits<std::_Rb_tree_node<std::pair<int_const,_int>_>*>;

typedef struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false> __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false>, *P__ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false>;

struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false> { // Original name: __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int const, int> >*, std::_Rb_tree_node<std::pair<int const, int> >, false>
};

struct pointer_traits<std::_Rb_tree_node<std::pair<int_const,_int>_>*> { // Original name: pointer_traits<std::_Rb_tree_node<std::pair<int const, int> >*>
    struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false> super___ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false>;
};

typedef struct pointer_traits<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*> pointer_traits<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*>, *Ppointer_traits<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*>;

struct pointer_traits<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*> { // Original name: pointer_traits<std::_Rb_tree_node<std::pair<const pio_program* const, int> >*>
    struct __ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false> super___ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false>;
};

typedef struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> element_type;


// WARNING! conflicting data type names: /DWARF/ptr_traits.h/std/__ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*,_std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>,_false>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer


// WARNING! conflicting data type names: /DWARF/ptr_traits.h/std/__ptr_traits_ptr_to<std::_Rb_tree_node<std::pair<int_const,_int>_>*,_std::_Rb_tree_node<std::pair<int_const,_int>_>,_false>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer

typedef struct watchdog_hw_t watchdog_hw_t, *Pwatchdog_hw_t;

struct watchdog_hw_t {
    io_rw_32 ctrl;
    io_wo_32 load;
    io_ro_32 reason;
    io_rw_32 scratch[8];
};

typedef enum clock_num_rp2350 {
    clk_gpout0=0,
    clk_gpout1=1,
    clk_gpout2=2,
    clk_gpout3=3,
    clk_ref=4,
    clk_sys=5,
    clk_peri=6,
    clk_hstx=7,
    clk_usb=8,
    clk_adc=9,
    CLK_COUNT=10
} clock_num_rp2350;

typedef enum clock_num_rp2350 clock_num_t;

typedef struct clock_hw_t clock_hw_t, *Pclock_hw_t;

struct clock_hw_t {
    io_rw_32 ctrl;
    io_rw_32 div;
    io_ro_32 selected;
};

typedef struct fc_hw_t fc_hw_t, *Pfc_hw_t;

struct fc_hw_t {
    io_rw_32 ref_khz;
    io_rw_32 min_khz;
    io_rw_32 max_khz;
    io_rw_32 delay;
    io_rw_32 interval;
    io_rw_32 src;
    io_ro_32 status;
    io_ro_32 result;
};

typedef struct clocks_hw_t clocks_hw_t, *Pclocks_hw_t;

typedef struct clock_resus_hw_t clock_resus_hw_t, *Pclock_resus_hw_t;

typedef union anon_union_8_2_838e857c_for_clocks_hw_t_6 anon_union_8_2_838e857c_for_clocks_hw_t_6, *Panon_union_8_2_838e857c_for_clocks_hw_t_6;

typedef union anon_union_8_2_52e6ea07_for_clocks_hw_t_7 anon_union_8_2_52e6ea07_for_clocks_hw_t_7, *Panon_union_8_2_52e6ea07_for_clocks_hw_t_7;

typedef union anon_union_8_2_e0ff4399_for_clocks_hw_t_8 anon_union_8_2_e0ff4399_for_clocks_hw_t_8, *Panon_union_8_2_e0ff4399_for_clocks_hw_t_8;

typedef struct anon_struct_8_2_f605659e_for_anon_union_8_2_838e857c_for_clocks_hw_t_6_0 anon_struct_8_2_f605659e_for_anon_union_8_2_838e857c_for_clocks_hw_t_6_0, *Panon_struct_8_2_f605659e_for_anon_union_8_2_838e857c_for_clocks_hw_t_6_0;

typedef struct anon_struct_8_2_eef806c6_for_anon_union_8_2_52e6ea07_for_clocks_hw_t_7_0 anon_struct_8_2_eef806c6_for_anon_union_8_2_52e6ea07_for_clocks_hw_t_7_0, *Panon_struct_8_2_eef806c6_for_anon_union_8_2_52e6ea07_for_clocks_hw_t_7_0;

typedef struct anon_struct_8_2_0ae615fe_for_anon_union_8_2_e0ff4399_for_clocks_hw_t_8_0 anon_struct_8_2_0ae615fe_for_anon_union_8_2_e0ff4399_for_clocks_hw_t_8_0, *Panon_struct_8_2_0ae615fe_for_anon_union_8_2_e0ff4399_for_clocks_hw_t_8_0;

struct anon_struct_8_2_0ae615fe_for_anon_union_8_2_e0ff4399_for_clocks_hw_t_8_0 {
    io_ro_32 enabled0;
    io_ro_32 enabled1;
};

struct anon_struct_8_2_f605659e_for_anon_union_8_2_838e857c_for_clocks_hw_t_6_0 {
    io_rw_32 wake_en0;
    io_rw_32 wake_en1;
};

union anon_union_8_2_838e857c_for_clocks_hw_t_6 {
    struct anon_struct_8_2_f605659e_for_anon_union_8_2_838e857c_for_clocks_hw_t_6_0 field_0;
    io_rw_32 wake_en[2];
};

union anon_union_8_2_e0ff4399_for_clocks_hw_t_8 {
    struct anon_struct_8_2_0ae615fe_for_anon_union_8_2_e0ff4399_for_clocks_hw_t_8_0 field_0;
    io_ro_32 enabled[2];
};

struct clock_resus_hw_t {
    io_rw_32 ctrl;
    io_ro_32 status;
};

struct anon_struct_8_2_eef806c6_for_anon_union_8_2_52e6ea07_for_clocks_hw_t_7_0 {
    io_rw_32 sleep_en0;
    io_rw_32 sleep_en1;
};

union anon_union_8_2_52e6ea07_for_clocks_hw_t_7 {
    struct anon_struct_8_2_eef806c6_for_anon_union_8_2_52e6ea07_for_clocks_hw_t_7_0 field_0;
    io_rw_32 sleep_en[2];
};

struct clocks_hw_t {
    struct clock_hw_t clk[10];
    io_rw_32 dftclk_xosc_ctrl;
    io_rw_32 dftclk_rosc_ctrl;
    io_rw_32 dftclk_lposc_ctrl;
    struct clock_resus_hw_t resus;
    struct fc_hw_t fc0;
    union anon_union_8_2_838e857c_for_clocks_hw_t_6 field_6;
    union anon_union_8_2_52e6ea07_for_clocks_hw_t_7 field_7;
    union anon_union_8_2_e0ff4399_for_clocks_hw_t_8 field_8;
    io_ro_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef void (*resus_callback_t)(void);

typedef clock_num_t clock_handle_t;

typedef struct __uses_alloc_base __uses_alloc_base, *P__uses_alloc_base;

struct __uses_alloc_base {
};

typedef struct allocator_arg_t allocator_arg_t, *Pallocator_arg_t;

struct allocator_arg_t {
};

typedef struct __uses_alloc0 __uses_alloc0, *P__uses_alloc0;

typedef struct _Sink _Sink, *P_Sink;

struct _Sink {
};

struct __uses_alloc0 {
    struct __uses_alloc_base super___uses_alloc_base;
    struct _Sink _M_a;
};

typedef void (*osal_task_func_t)(void *);

typedef enum 7PinMode {
    INPUT=0,
    OUTPUT=1,
    INPUT_PULLUP=2,
    INPUT_PULLDOWN=3,
    OUTPUT_OPENDRAIN=4,
    OUTPUT_2MA=5,
    OUTPUT_4MA=6,
    OUTPUT_8MA=7,
    OUTPUT_12MA=8
} 7PinMode;

typedef void (*voidFuncPtrParam)(void *);


// WARNING! conflicting data type names: /DWARF/Common.h/byte - /byte

typedef enum 9PinStatus {
    LOW=0,
    HIGH=1,
    CHANGE=2,
    FALLING=3,
    RISING=4
} 9PinStatus;

typedef enum 7PinMode PinMode;

typedef void (*voidFuncPtr)(void);

typedef enum 9PinStatus PinStatus;

typedef struct 11max_align_t 11max_align_t, *P11max_align_t;

typedef struct 11max_align_t max_align_t;

struct 11max_align_t {
    longlong __max_align_ll;
    undefined field1_0x8;
    undefined field2_0x9;
    undefined field3_0xa;
    undefined field4_0xb;
    undefined field5_0xc;
    undefined field6_0xd;
    undefined field7_0xe;
    undefined field8_0xf;
    long double __max_align_ld;
};

typedef struct midid_interface_t midid_interface_t, *Pmidid_interface_t;

typedef struct midid_stream_t midid_stream_t, *Pmidid_stream_t;

struct midid_stream_t {
    uint8_t buffer[4];
    uint8_t index;
    uint8_t total;
};

struct midid_interface_t {
    uint8_t itf_num;
    uint8_t ep_in;
    uint8_t ep_out;
    struct midid_stream_t stream_write;
    struct midid_stream_t stream_read;
    struct tu_fifo_t rx_ff;
    struct tu_fifo_t tx_ff;
    uint8_t rx_ff_buf[64];
    uint8_t tx_ff_buf[64];
    osal_mutex_def_t rx_ff_mutex;
    osal_mutex_def_t tx_ff_mutex;
};

typedef struct anon_struct_128_2_23a6f806 anon_struct_128_2_23a6f806, *Panon_struct_128_2_23a6f806;

typedef union anon_union_64_2_ea7ad672_for_anon_struct_128_2_23a6f806_0 anon_union_64_2_ea7ad672_for_anon_struct_128_2_23a6f806_0, *Panon_union_64_2_ea7ad672_for_anon_struct_128_2_23a6f806_0;

typedef union anon_union_64_2_408980c8_for_anon_struct_128_2_23a6f806_1 anon_union_64_2_408980c8_for_anon_struct_128_2_23a6f806_1, *Panon_union_64_2_408980c8_for_anon_struct_128_2_23a6f806_1;

union anon_union_64_2_ea7ad672_for_anon_struct_128_2_23a6f806_0 {
    uint8_t epin[64];
    uint8_t epin_dcache_padding[64];
};

union anon_union_64_2_408980c8_for_anon_struct_128_2_23a6f806_1 {
    uint8_t epout[64];
    uint8_t epout_dcache_padding[64];
};

struct anon_struct_128_2_23a6f806 {
    union anon_union_64_2_ea7ad672_for_anon_struct_128_2_23a6f806_0 field_0;
    union anon_union_64_2_408980c8_for_anon_struct_128_2_23a6f806_1 field_1;
};

typedef struct cdcd_interface_t cdcd_interface_t, *Pcdcd_interface_t;

struct cdcd_interface_t {
    uint8_t itf_num;
    uint8_t ep_notif;
    uint8_t ep_in;
    uint8_t ep_out;
    uint8_t line_state;
    char wanted_char;
    undefined field6_0x6;
    undefined field7_0x7;
    struct cdc_line_coding_t.conflict line_coding;
    undefined field9_0xf;
    struct tu_fifo_t rx_ff;
    struct tu_fifo_t tx_ff;
    uint8_t rx_ff_buf[256];
    uint8_t tx_ff_buf[256];
    osal_mutex_def_t rx_ff_mutex;
    osal_mutex_def_t tx_ff_mutex;
};

typedef struct cdcd_epbuf_t cdcd_epbuf_t, *Pcdcd_epbuf_t;

typedef union anon_union_64_2_408980c8_for_cdcd_epbuf_t_0 anon_union_64_2_408980c8_for_cdcd_epbuf_t_0, *Panon_union_64_2_408980c8_for_cdcd_epbuf_t_0;

typedef union anon_union_64_2_ea7ad672_for_cdcd_epbuf_t_1 anon_union_64_2_ea7ad672_for_cdcd_epbuf_t_1, *Panon_union_64_2_ea7ad672_for_cdcd_epbuf_t_1;

union anon_union_64_2_408980c8_for_cdcd_epbuf_t_0 {
    uint8_t epout[64];
    uint8_t epout_dcache_padding[64];
};

union anon_union_64_2_ea7ad672_for_cdcd_epbuf_t_1 {
    uint8_t epin[64];
    uint8_t epin_dcache_padding[64];
};

struct cdcd_epbuf_t {
    union anon_union_64_2_408980c8_for_cdcd_epbuf_t_0 field_0;
    union anon_union_64_2_ea7ad672_for_cdcd_epbuf_t_1 field_1;
};

typedef struct tud_cdc_configure_fifo_t tud_cdc_configure_fifo_t, *Ptud_cdc_configure_fifo_t;

struct tud_cdc_configure_fifo_t {
    uint8_t rx_persistent:1;
    uint8_t tx_persistent:1;
};

typedef struct xosc_hw_t xosc_hw_t, *Pxosc_hw_t;

struct xosc_hw_t {
    io_rw_32 ctrl;
    io_rw_32 status;
    io_rw_32 dormant;
    io_rw_32 startup;
    io_rw_32 count;
};

typedef union double_union double_union, *Pdouble_union;

union double_union {
    double d;
    __uint32_t i[2];
};

typedef struct usb_hw_t usb_hw_t, *Pusb_hw_t;

struct usb_hw_t {
    io_rw_32 dev_addr_ctrl;
    io_rw_32 int_ep_addr_ctrl[15];
    io_rw_32 main_ctrl;
    io_wo_32 sof_wr;
    io_ro_32 sof_rd;
    io_rw_32 sie_ctrl;
    io_rw_32 sie_status;
    io_rw_32 int_ep_ctrl;
    io_rw_32 buf_status;
    io_ro_32 buf_cpu_should_handle;
    io_rw_32 abort;
    io_rw_32 abort_done;
    io_rw_32 ep_stall_arm;
    io_rw_32 nak_poll;
    io_rw_32 ep_nak_stall_status;
    io_rw_32 muxing;
    io_rw_32 pwr;
    io_rw_32 phy_direct;
    io_rw_32 phy_direct_override;
    io_rw_32 phy_trim;
    io_rw_32 linestate_tuning;
    io_ro_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
    uint32_t _pad0[25];
    io_ro_32 sof_timestamp_raw;
    io_ro_32 sof_timestamp_last;
    io_ro_32 sm_state;
    io_rw_32 ep_tx_error;
    io_rw_32 ep_rx_error;
    io_rw_32 dev_sm_watchdog;
};

typedef struct 11resets_hw_t 11resets_hw_t, *P11resets_hw_t;

struct 11resets_hw_t {
    io_rw_32 reset;
    io_rw_32 wdsel;
    io_ro_32 reset_done;
};

typedef struct resets_hw_t.conflict resets_hw_t.conflict, *Presets_hw_t.conflict;

struct resets_hw_t.conflict {
    io_rw_32 reset;
    io_rw_32 wdsel;
    io_ro_32 reset_done;
};

typedef enum reset_num_rp2350 {
    RESET_ADC=0,
    RESET_BUSCTRL=1,
    RESET_DMA=2,
    RESET_HSTX=3,
    RESET_I2C0=4,
    RESET_I2C1=5,
    RESET_IO_BANK0=6,
    RESET_IO_QSPI=7,
    RESET_JTAG=8,
    RESET_PADS_BANK0=9,
    RESET_PADS_QSPI=10,
    RESET_PIO0=11,
    RESET_PIO1=12,
    RESET_PIO2=13,
    RESET_PLL_SYS=14,
    RESET_PLL_USB=15,
    RESET_PWM=16,
    RESET_SHA256=17,
    RESET_SPI0=18,
    RESET_SPI1=19,
    RESET_SYSCFG=20,
    RESET_SYSINFO=21,
    RESET_TBMAN=22,
    RESET_TIMER0=23,
    RESET_TIMER1=24,
    RESET_TRNG=25,
    RESET_UART0=26,
    RESET_UART1=27,
    RESET_USBCTRL=28,
    RESET_COUNT=29
} reset_num_rp2350;

typedef struct 11resets_hw_t resets_hw_t;


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/__allocator_traits_base/__rebind<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>,_std::pair<int_const,_int>,_void>/type - /DWARF/type

typedef type __alloc_rebind;

typedef struct allocator_traits<std::allocator<std::pair<int_const,_int>_>_> allocator_traits<std::allocator<std::pair<int_const,_int>_>_>, *Pallocator_traits<std::allocator<std::pair<int_const,_int>_>_>;

struct allocator_traits<std::allocator<std::pair<int_const,_int>_>_> { // Original name: allocator_traits<std::allocator<std::pair<int const, int> > >
};

typedef struct allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_> allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_>, *Pallocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_>;

struct allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: allocator_traits<std::allocator<std::pair<const pio_program* const, int> > >
};

typedef struct __allocator_traits_base __allocator_traits_base, *P__allocator_traits_base;

struct __allocator_traits_base {
};

typedef struct allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>, *Pallocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>;

struct allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> { // Original name: allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int const, int> > > >
};

typedef struct allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>, *Pallocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>;

struct allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_> { // Original name: allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > > >
};

typedef struct __rebind<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>,_std::pair<const_pio_program*_const,_int>,_void> __rebind<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>,_std::pair<const_pio_program*_const,_int>,_void>, *P__rebind<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>,_std::pair<const_pio_program*_const,_int>,_void>;

struct __rebind<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>,_std::pair<const_pio_program*_const,_int>,_void> { // Original name: __rebind<std::allocator<std::_Rb_tree_node<std::pair<const pio_program* const, int> > >, std::pair<const pio_program* const, int>, void>
};

typedef struct __rebind<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>,_std::pair<int_const,_int>,_void> __rebind<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>,_std::pair<int_const,_int>,_void>, *P__rebind<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>,_std::pair<int_const,_int>,_void>;

struct __rebind<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>,_std::pair<int_const,_int>,_void> { // Original name: __rebind<std::allocator<std::_Rb_tree_node<std::pair<int const, int> > >, std::pair<int const, int>, void>
};


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/__allocator_traits_base/__rebind<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>,_std::pair<const_pio_program*_const,_int>,_void>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer

typedef void *const_void_pointer;


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::pair<int_const,_int>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::pair<int_const,_int>_>_>/rebind_alloc - /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_>/rebind_alloc


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/std/allocator_traits<std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type

typedef struct __alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_> __alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_>, *P__alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_>;

struct __alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_> { // Original name: __alloc_traits<std::allocator<std::pair<const pio_program* const, int> >, std::pair<const pio_program* const, int> >
    struct allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_> super_allocator_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>_>;
};

typedef struct __alloc_traits<std::allocator<std::pair<int_const,_int>_>,_std::pair<int_const,_int>_> __alloc_traits<std::allocator<std::pair<int_const,_int>_>,_std::pair<int_const,_int>_>, *P__alloc_traits<std::allocator<std::pair<int_const,_int>_>,_std::pair<int_const,_int>_>;

struct __alloc_traits<std::allocator<std::pair<int_const,_int>_>,_std::pair<int_const,_int>_> { // Original name: __alloc_traits<std::allocator<std::pair<int const, int> >, std::pair<int const, int> >
    struct allocator_traits<std::allocator<std::pair<int_const,_int>_>_> super_allocator_traits<std::allocator<std::pair<int_const,_int>_>_>;
};

typedef struct rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>, *Prebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>;

struct rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> { // Original name: rebind<std::_Rb_tree_node<std::pair<const pio_program* const, int> > >
};

typedef struct rebind<std::_Rb_tree_node<std::pair<int_const,_int>_>_> rebind<std::_Rb_tree_node<std::pair<int_const,_int>_>_>, *Prebind<std::_Rb_tree_node<std::pair<int_const,_int>_>_>;

struct rebind<std::_Rb_tree_node<std::pair<int_const,_int>_>_> { // Original name: rebind<std::_Rb_tree_node<std::pair<int const, int> > >
};


// WARNING! conflicting data type names: /DWARF/alloc_traits.h/__gnu_cxx/__alloc_traits<std::allocator<std::pair<int_const,_int>_>,_std::pair<int_const,_int>_>/rebind<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/other - /DWARF/alloc_traits.h/__gnu_cxx/__alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_>/rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/other

typedef _Bool (*usbd_control_xfer_cb_t)(uint8_t, uint8_t, struct tusb_control_request_t *);

typedef struct usbd_class_driver_t usbd_class_driver_t, *Pusbd_class_driver_t;

struct usbd_class_driver_t {
    char *name;
    void (*init)(void);
    _Bool (*deinit)(void);
    void (*reset)(uint8_t);
    uint16_t (*open)(uint8_t, struct tusb_desc_interface_t *, uint16_t);
    _Bool (*control_xfer_cb)(uint8_t, uint8_t, struct tusb_control_request_t *);
    _Bool (*xfer_cb)(uint8_t, uint8_t, enum xfer_result_t, uint32_t);
    void (*sof)(uint8_t, uint32_t);
};

typedef enum sof_consumer_t {
    SOF_CONSUMER_USER=0,
    SOF_CONSUMER_AUDIO=1
} sof_consumer_t;

typedef struct qmi_mem_hw_t qmi_mem_hw_t, *Pqmi_mem_hw_t;

struct qmi_mem_hw_t {
    io_rw_32 timing;
    io_rw_32 rfmt;
    io_rw_32 rcmd;
    io_rw_32 wfmt;
    io_rw_32 wcmd;
};

typedef struct qmi_hw_t qmi_hw_t, *Pqmi_hw_t;

struct qmi_hw_t {
    io_rw_32 direct_csr;
    io_wo_32 direct_tx;
    io_ro_32 direct_rx;
    struct qmi_mem_hw_t m[2];
    io_rw_32 atrans[8];
};

typedef struct malloc_chunk malloc_chunk, *Pmalloc_chunk;

typedef struct malloc_chunk *mbinptr;

struct malloc_chunk {
    size_t prev_size;
    size_t size;
    struct malloc_chunk *fd;
    struct malloc_chunk *bk;
};

typedef struct malloc_chunk *mchunkptr;

typedef union _FP_UNION_Q _FP_UNION_Q, *P_FP_UNION_Q;

typedef struct anon_struct_16_6_893b96bd_for_bits anon_struct_16_6_893b96bd_for_bits, *Panon_struct_16_6_893b96bd_for_bits;

struct anon_struct_16_6_893b96bd_for_bits {
    ulong frac0:32;
    ulong frac1:32;
    ulong frac2:32;
    ulong frac3:16;
    uint exp:15;
    uint sign:1;
};

union _FP_UNION_Q {
    TFtype flt;
    struct anon_struct_16_6_893b96bd_for_bits bits;
};

typedef struct __lock *_LOCK_T;

typedef struct glue_with_file glue_with_file, *Pglue_with_file;

typedef struct _glue _glue, *P_glue;

typedef __FILE FILE;

struct _glue {
    struct _glue *_next;
    int _niobs;
    __FILE *_iobs;
};

struct glue_with_file {
    struct _glue glue;
    undefined field1_0xc;
    undefined field2_0xd;
    undefined field3_0xe;
    undefined field4_0xf;
    FILE file;
};

typedef enum irq_num_rp2350 {
    TIMER0_IRQ_0=0,
    TIMER0_IRQ_1=1,
    TIMER0_IRQ_2=2,
    TIMER0_IRQ_3=3,
    TIMER1_IRQ_0=4,
    TIMER1_IRQ_1=5,
    TIMER1_IRQ_2=6,
    TIMER1_IRQ_3=7,
    PWM_IRQ_WRAP_0=8,
    PWM_IRQ_WRAP_1=9,
    DMA_IRQ_0=10,
    DMA_IRQ_1=11,
    DMA_IRQ_2=12,
    DMA_IRQ_3=13,
    USBCTRL_IRQ=14,
    PIO0_IRQ_0=15,
    PIO0_IRQ_1=16,
    PIO1_IRQ_0=17,
    PIO1_IRQ_1=18,
    PIO2_IRQ_0=19,
    PIO2_IRQ_1=20,
    IO_IRQ_BANK0=21,
    IO_IRQ_BANK0_NS=22,
    IO_IRQ_QSPI=23,
    IO_IRQ_QSPI_NS=24,
    SIO_IRQ_FIFO=25,
    SIO_IRQ_BELL=26,
    SIO_IRQ_FIFO_NS=27,
    SIO_IRQ_BELL_NS=28,
    SIO_IRQ_MTIMECMP=29,
    CLOCKS_IRQ=30,
    SPI0_IRQ=31,
    SPI1_IRQ=32,
    UART0_IRQ=33,
    UART1_IRQ=34,
    ADC_IRQ_FIFO=35,
    I2C0_IRQ=36,
    I2C1_IRQ=37,
    OTP_IRQ=38,
    TRNG_IRQ=39,
    PROC0_IRQ_CTI=40,
    PROC1_IRQ_CTI=41,
    PLL_SYS_IRQ=42,
    PLL_USB_IRQ=43,
    POWMAN_IRQ_POW=44,
    POWMAN_IRQ_TIMER=45,
    SPARE_IRQ_0=46,
    SPARE_IRQ_1=47,
    SPARE_IRQ_2=48,
    SPARE_IRQ_3=49,
    SPARE_IRQ_4=50,
    SPARE_IRQ_5=51,
    IRQ_COUNT=52
} irq_num_rp2350;

typedef enum LookaheadMode {
    SKIP_ALL=0,
    SKIP_NONE=1,
    SKIP_WHITESPACE=2
} LookaheadMode;

typedef struct MultiTarget MultiTarget, *PMultiTarget;

struct MultiTarget {
    char *str;
    size_t len;
    size_t index;
};

typedef struct U8X8LOG U8X8LOG, *PU8X8LOG;

typedef struct u8log_struct u8log_struct, *Pu8log_struct;

typedef struct u8log_struct u8log_t;

typedef void (*u8log_cb)(u8log_t *);

struct u8log_struct {
    void *aux_data;
    uint8_t width;
    uint8_t height;
    u8log_cb cb;
    uint8_t *screen_buffer;
    uint8_t is_redraw_line_for_each_char;
    int8_t line_height_offset;
    uint8_t cursor_x;
    uint8_t cursor_y;
    uint8_t redraw_line;
    uint8_t is_redraw_line;
    uint8_t is_redraw_all;
    uint8_t is_redraw_all_required_for_next_nl;
};

struct U8X8LOG {
    struct Print super_Print;
    u8log_t u8log;
};

typedef struct U8X8 U8X8, *PU8X8;

struct U8X8 {
    struct Print super_Print;
    u8x8_t u8x8;
    uint8_t tx;
    uint8_t ty;
    undefined field4_0x4e;
    undefined field5_0x4f;
};

typedef struct pt pt, *Ppt;

typedef struct anon_struct_3_3_fca49eb4_for_pt_0 anon_struct_3_3_fca49eb4_for_pt_0, *Panon_struct_3_3_fca49eb4_for_pt_0;

typedef struct resident_partition_t resident_partition_t, *President_partition_t;

struct anon_struct_3_3_fca49eb4_for_pt_0 {
    uint8_t partition_count;
    uint8_t permission_partition_count;
    _Bool loaded;
};

struct resident_partition_t {
    uint32_t permissions_and_location;
    uint32_t permissions_and_flags;
};

struct pt {
    struct anon_struct_3_3_fca49eb4_for_pt_0 field_0;
    uint32_t unpartitioned_space_permissions_and_flags;
    struct resident_partition_t partitions[16];
};

typedef enum vreg_voltage {
    VREG_VOLTAGE_0_55=0,
    VREG_VOLTAGE_0_60=1,
    VREG_VOLTAGE_0_65=2,
    VREG_VOLTAGE_0_70=3,
    VREG_VOLTAGE_0_75=4,
    VREG_VOLTAGE_0_80=5,
    VREG_VOLTAGE_0_85=6,
    VREG_VOLTAGE_MIN=6,
    VREG_VOLTAGE_0_90=7,
    VREG_VOLTAGE_0_95=8,
    VREG_VOLTAGE_1_00=9,
    VREG_VOLTAGE_1_05=10,
    VREG_VOLTAGE_1_10=11,
    VREG_VOLTAGE_DEFAULT=11,
    VREG_VOLTAGE_1_15=12,
    VREG_VOLTAGE_1_20=13,
    VREG_VOLTAGE_1_25=14,
    VREG_VOLTAGE_1_30=15,
    VREG_VOLTAGE_MAX=15,
    VREG_VOLTAGE_1_35=16,
    VREG_VOLTAGE_1_40=17,
    VREG_VOLTAGE_1_50=18,
    VREG_VOLTAGE_1_60=19,
    VREG_VOLTAGE_1_65=20,
    VREG_VOLTAGE_1_70=21,
    VREG_VOLTAGE_1_80=22,
    VREG_VOLTAGE_1_90=23,
    VREG_VOLTAGE_2_00=24,
    VREG_VOLTAGE_2_35=25,
    VREG_VOLTAGE_2_50=26,
    VREG_VOLTAGE_2_65=27,
    VREG_VOLTAGE_2_80=28,
    VREG_VOLTAGE_3_00=29,
    VREG_VOLTAGE_3_15=30,
    VREG_VOLTAGE_3_30=31
} vreg_voltage;

typedef void (*rom_flash_enter_cmd_xip_fn)(void);

typedef int (*rom_pick_ab_partition_fn)(uint8_t *, uint32_t, uint, uint32_t);

typedef void (*rom_flash_flush_cache_fn)(void);

typedef struct boot_info_t boot_info_t, *Pboot_info_t;

typedef union anon_union_4_2_5b3b584f_for_boot_info_t_0 anon_union_4_2_5b3b584f_for_boot_info_t_0, *Panon_union_4_2_5b3b584f_for_boot_info_t_0;

typedef struct anon_struct_4_4_b785f949_for_anon_union_4_2_5b3b584f_for_boot_info_t_0_0 anon_struct_4_4_b785f949_for_anon_union_4_2_5b3b584f_for_boot_info_t_0_0, *Panon_struct_4_4_b785f949_for_anon_union_4_2_5b3b584f_for_boot_info_t_0_0;

struct anon_struct_4_4_b785f949_for_anon_union_4_2_5b3b584f_for_boot_info_t_0_0 {
    int8_t diagnostic_partition_index;
    uint8_t boot_type;
    int8_t partition;
    uint8_t tbyb_and_update_info;
};

union anon_union_4_2_5b3b584f_for_boot_info_t_0 {
    struct anon_struct_4_4_b785f949_for_anon_union_4_2_5b3b584f_for_boot_info_t_0_0 field_0;
    uint32_t boot_word;
};

struct boot_info_t {
    union anon_union_4_2_5b3b584f_for_boot_info_t_0 field_0;
    uint32_t boot_diagnostic;
    uint32_t reboot_params[2];
};

typedef void (*rom_flash_exit_xip_fn)(void);

typedef void (*rom_flash_range_program_fn)(uint32_t, uint8_t *, size_t);

typedef void (*rom_flash_range_erase_fn)(uint32_t, size_t, uint32_t, uint8_t);

typedef int (*rom_get_sys_info_fn)(uint32_t *, uint32_t, uint32_t);

typedef void (*rom_connect_internal_flash_fn)(void);

typedef void (*rom_bootrom_state_reset_fn)(uint32_t);

typedef int (*rom_reboot_fn)(uint32_t, uint32_t, uint32_t, uint32_t);

typedef void * (*rom_table_lookup_fn)(uint32_t, uint32_t);

typedef void *nullptr_t;

typedef struct allocator<std::pair<int_const,_int>_> allocator<std::pair<int_const,_int>_>, *Pallocator<std::pair<int_const,_int>_>;

typedef struct __new_allocator<std::pair<int_const,_int>_> __new_allocator<std::pair<int_const,_int>_>, *P__new_allocator<std::pair<int_const,_int>_>;

struct __new_allocator<std::pair<int_const,_int>_> { // Original name: __new_allocator<std::pair<int const, int> >
};

struct allocator<std::pair<int_const,_int>_> { // Original name: allocator<std::pair<int const, int> >
    struct __new_allocator<std::pair<int_const,_int>_> super___new_allocator<std::pair<int_const,_int>_>;
};

typedef struct rebind<std::pair<const_pio_program*_const,_int>_> rebind<std::pair<const_pio_program*_const,_int>_>, *Prebind<std::pair<const_pio_program*_const,_int>_>;

struct rebind<std::pair<const_pio_program*_const,_int>_> { // Original name: rebind<std::pair<const pio_program* const, int> >
};


// WARNING! conflicting data type names: /DWARF/allocator.h/std/allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/rebind<std::pair<const_pio_program*_const,_int>_>/other - /DWARF/alloc_traits.h/__gnu_cxx/__alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_>/rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/other

typedef struct rebind<std::pair<int_const,_int>_> rebind<std::pair<int_const,_int>_>, *Prebind<std::pair<int_const,_int>_>;

struct rebind<std::pair<int_const,_int>_> { // Original name: rebind<std::pair<int const, int> >
};


// WARNING! conflicting data type names: /DWARF/allocator.h/std/allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/rebind<std::pair<int_const,_int>_>/other - /DWARF/alloc_traits.h/__gnu_cxx/__alloc_traits<std::allocator<std::pair<const_pio_program*_const,_int>_>,_std::pair<const_pio_program*_const,_int>_>/rebind<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/other

typedef struct EEPROMClass EEPROMClass, *PEEPROMClass;

struct EEPROMClass {
    uint8_t *_sector;
    uint8_t *_data;
    size_t _size;
    bool _dirty;
};

typedef __ino_t ino_t;

typedef __uid_t uid_t;

typedef uint64_t absolute_time_t;

typedef __nlink_t nlink_t;

typedef __gid_t gid_t;

typedef __blkcnt_t blkcnt_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__mode_t - /types.h/__mode_t

typedef __mode_t mode_t;

typedef __dev_t dev_t;

typedef __pid_t pid_t;

typedef __blksize_t blksize_t;

typedef struct anon_struct_8_2_97b3200e anon_struct_8_2_97b3200e, *Panon_struct_8_2_97b3200e;

struct anon_struct_8_2_97b3200e {
    int value;
    int original_index;
};

typedef struct 8adc_hw_t 8adc_hw_t, *P8adc_hw_t;

struct 8adc_hw_t {
    io_rw_32 cs;
    io_ro_32 result;
    io_rw_32 fcs;
    io_ro_32 fifo;
    io_rw_32 div;
    io_ro_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef struct 8adc_hw_t adc_hw_t;


// WARNING! conflicting data type names: /DWARF/_timespec.h/timespec - /time.h/timespec

typedef struct timeout_state timeout_state, *Ptimeout_state;

typedef struct timeout_state timeout_state_t;

struct timeout_state {
    absolute_time_t next_timeout;
    uint64_t param;
};

typedef _Bool (*check_timeout_fn)(timeout_state_t *, _Bool);

typedef union ieee_double_shape_type ieee_double_shape_type, *Pieee_double_shape_type;

typedef struct anon_struct_8_2_43e447a6_for_parts anon_struct_8_2_43e447a6_for_parts, *Panon_struct_8_2_43e447a6_for_parts;

struct anon_struct_8_2_43e447a6_for_parts {
    __uint32_t lsw;
    __uint32_t msw;
};

union ieee_double_shape_type {
    double value;
    struct anon_struct_8_2_43e447a6_for_parts parts;
};

typedef struct pads_bank0_hw_t pads_bank0_hw_t, *Ppads_bank0_hw_t;

struct pads_bank0_hw_t {
    io_rw_32 voltage_select;
    io_rw_32 io[48];
};

typedef struct TwoWire TwoWire, *PTwoWire;

typedef struct i2c_inst i2c_inst, *Pi2c_inst;

typedef struct i2c_inst i2c_inst_t;

typedef struct 8i2c_hw_t 8i2c_hw_t, *P8i2c_hw_t;

typedef struct 8i2c_hw_t i2c_hw_t;

struct i2c_inst {
    i2c_hw_t *hw;
    bool restart_on_next;
};

struct 8i2c_hw_t {
    io_rw_32 con;
    io_rw_32 tar;
    io_rw_32 sar;
    uint32_t _pad0;
    io_rw_32 data_cmd;
    io_rw_32 ss_scl_hcnt;
    io_rw_32 ss_scl_lcnt;
    io_rw_32 fs_scl_hcnt;
    io_rw_32 fs_scl_lcnt;
    uint32_t _pad1[2];
    io_ro_32 intr_stat;
    io_rw_32 intr_mask;
    io_ro_32 raw_intr_stat;
    io_rw_32 rx_tl;
    io_rw_32 tx_tl;
    io_ro_32 clr_intr;
    io_ro_32 clr_rx_under;
    io_ro_32 clr_rx_over;
    io_ro_32 clr_tx_over;
    io_ro_32 clr_rd_req;
    io_ro_32 clr_tx_abrt;
    io_ro_32 clr_rx_done;
    io_ro_32 clr_activity;
    io_ro_32 clr_stop_det;
    io_ro_32 clr_start_det;
    io_ro_32 clr_gen_call;
    io_rw_32 enable;
    io_ro_32 status;
    io_ro_32 txflr;
    io_ro_32 rxflr;
    io_rw_32 sda_hold;
    io_ro_32 tx_abrt_source;
    io_rw_32 slv_data_nack_only;
    io_rw_32 dma_cr;
    io_rw_32 dma_tdlr;
    io_rw_32 dma_rdlr;
    io_rw_32 sda_setup;
    io_rw_32 ack_general_call;
    io_ro_32 enable_status;
    io_rw_32 fs_spklen;
    uint32_t _pad2;
    io_ro_32 clr_restart_det;
    uint32_t _pad3[18];
    io_ro_32 comp_param_1;
    io_ro_32 comp_version;
    io_ro_32 comp_type;
};

struct TwoWire {
    struct HardwareI2C super_HardwareI2C;
    i2c_inst_t *_i2c;
    pin_size_t _sda;
    pin_size_t _scl;
    int _clkHz;
    bool _running;
    bool _slave;
    uint8_t _addr;
    bool _txBegun;
    bool _timeoutFlag;
    bool _reset_with_timeout;
    uint8_t *_buff;
    size_t _buffSize;
    int _buffLen;
    int _buffOff;
    void (*_onRequestCallback)(void);
    void (*_onReceiveCallback)(int);
    bool _slaveStartDet;
    bool _dmaRunning;
    int _dmaChannelReceive;
    int _dmaChannelSend;
    uint16_t *_dmaSendBuffer;
    size_t _dmaSendBufferLen;
    bool _dmaFinished;
    void (*_dmaOnFinished)(void);
};

typedef struct StringSumHelper StringSumHelper, *PStringSumHelper;

typedef struct String String, *PString;

struct String {
    char *buffer;
    uint capacity;
    uint len;
};

struct StringSumHelper {
    struct String super_String;
};

typedef dword offset_in_String_to_subr;

typedef offset_in_String_to_subr StringIfHelperType;

typedef __intptr_t intptr_t;

typedef __uintptr_t uintptr_t;

typedef struct __type_identity<std::allocator<std::pair<int_const,_int>_>_> __type_identity<std::allocator<std::pair<int_const,_int>_>_>, *P__type_identity<std::allocator<std::pair<int_const,_int>_>_>;

struct __type_identity<std::allocator<std::pair<int_const,_int>_>_> { // Original name: __type_identity<std::allocator<std::pair<int const, int> > >
};

typedef struct __nonesuchbase __nonesuchbase, *P__nonesuchbase;

struct __nonesuchbase {
};

typedef struct integral_constant<bool,_false> integral_constant<bool,_false>, *Pintegral_constant<bool,_false>;

struct integral_constant<bool,_false> { // Original name: integral_constant<bool, false>
};

typedef struct remove_reference<std::pair<const_pio_program*_const,_int>_> remove_reference<std::pair<const_pio_program*_const,_int>_>, *Premove_reference<std::pair<const_pio_program*_const,_int>_>;

struct remove_reference<std::pair<const_pio_program*_const,_int>_> { // Original name: remove_reference<std::pair<const pio_program* const, int> >
};

typedef struct integral_constant<bool,_false> __bool_constant;

typedef __bool_constant true_type;

typedef struct remove_reference<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&> remove_reference<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&>, *Premove_reference<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&>;

struct remove_reference<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&> { // Original name: remove_reference<std::_Rb_tree_node<std::pair<const pio_program* const, int> >*&>
};

typedef struct remove_reference<int> remove_reference<int>, *Premove_reference<int>;

struct remove_reference<int> {
};

typedef struct remove_reference<long_unsigned_int&> remove_reference<long_unsigned_int&>, *Premove_reference<long_unsigned_int&>;

struct remove_reference<long_unsigned_int&> { // Original name: remove_reference<long unsigned int&>
};

typedef struct remove_reference<int&> remove_reference<int&>, *Premove_reference<int&>;

struct remove_reference<int&> {
};

typedef struct __nonesuch __nonesuch, *P__nonesuch;

struct __nonesuch {
    struct __nonesuchbase super___nonesuchbase;
};


// WARNING! conflicting data type names: /DWARF/type_traits/std/__conditional<true>/type - /DWARF/type

typedef type __conditional_t;

typedef struct remove_reference<std::tuple<long_unsigned_int&>_> remove_reference<std::tuple<long_unsigned_int&>_>, *Premove_reference<std::tuple<long_unsigned_int&>_>;

struct remove_reference<std::tuple<long_unsigned_int&>_> { // Original name: remove_reference<std::tuple<long unsigned int&> >
};

typedef struct remove_reference<bool> remove_reference<bool>, *Premove_reference<bool>;

struct remove_reference<bool> {
};

typedef struct remove_reference<std::pair<int_const,_int>_> remove_reference<std::pair<int_const,_int>_>, *Premove_reference<std::pair<int_const,_int>_>;

struct remove_reference<std::pair<int_const,_int>_> { // Original name: remove_reference<std::pair<int const, int> >
};

typedef struct remove_reference<std::tuple<int_const&>_> remove_reference<std::tuple<int_const&>_>, *Premove_reference<std::tuple<int_const&>_>;

struct remove_reference<std::tuple<int_const&>_> { // Original name: remove_reference<std::tuple<int const&> >
};

typedef struct remove_reference<std::_Rb_tree_node<std::pair<int_const,_int>_>*&> remove_reference<std::_Rb_tree_node<std::pair<int_const,_int>_>*&>, *Premove_reference<std::_Rb_tree_node<std::pair<int_const,_int>_>*&>;

struct remove_reference<std::_Rb_tree_node<std::pair<int_const,_int>_>*&> { // Original name: remove_reference<std::_Rb_tree_node<std::pair<int const, int> >*&>
};

typedef struct pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>, *Ppair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>;

typedef struct pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> *type.conflict2;

typedef type.conflict2 __conditional_t.conflict3;

struct pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> { // Original name: pair<std::_Rb_tree_iterator<std::pair<int const, int> >, std::_Rb_tree_iterator<std::pair<int const, int> > >
Missing member super___pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> : __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> at offset 0x0 [conflicting member at same offset]
    struct _Rb_tree_iterator<std::pair<int_const,_int>_> first;
    struct _Rb_tree_iterator<std::pair<int_const,_int>_> second;
};


// WARNING! conflicting data type names: /DWARF/type_traits/std/__conditional<true>/type.conflict1 - /DWARF/type.conflict1

typedef type.conflict1 __conditional_t.conflict2;


// WARNING! conflicting data type names: /DWARF/type_traits/std/__conditional<true>/type.conflict - /DWARF/type.conflict

typedef type.conflict __conditional_t.conflict1;


// WARNING! conflicting data type names: /DWARF/type_traits/std/__conditional<false>/type - /DWARF/type

typedef type __conditional_t.conflict;

typedef struct remove_reference<std::_Rb_tree_node_base*&> remove_reference<std::_Rb_tree_node_base*&>, *Premove_reference<std::_Rb_tree_node_base*&>;

struct remove_reference<std::_Rb_tree_node_base*&> {
};

typedef struct remove_reference<std::pair<const_pio_program*_const,_int>&> remove_reference<std::pair<const_pio_program*_const,_int>&>, *Premove_reference<std::pair<const_pio_program*_const,_int>&>;

struct remove_reference<std::pair<const_pio_program*_const,_int>&> { // Original name: remove_reference<std::pair<const pio_program* const, int>&>
};

typedef struct remove_reference<const_pio_program*&> remove_reference<const_pio_program*&>, *Premove_reference<const_pio_program*&>;

struct remove_reference<const_pio_program*&> { // Original name: remove_reference<const pio_program*&>
};

typedef struct remove_reference<int_const&> remove_reference<int_const&>, *Premove_reference<int_const&>;

struct remove_reference<int_const&> { // Original name: remove_reference<int const&>
};

typedef struct remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&> remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&>, *Premove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&>;

struct remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&> { // Original name: remove_reference<std::_Rb_tree_iterator<std::pair<int const, int> >&>
};

typedef struct remove_reference<const_std::piecewise_construct_t&> remove_reference<const_std::piecewise_construct_t&>, *Premove_reference<const_std::piecewise_construct_t&>;

struct remove_reference<const_std::piecewise_construct_t&> { // Original name: remove_reference<const std::piecewise_construct_t&>
};

typedef __bool_constant false_type;

typedef struct __conditional<false> __conditional<false>, *P__conditional<false>;

struct __conditional<false> {
};

typedef struct __type_identity<std::allocator<std::pair<const_pio_program*_const,_int>_>_> __type_identity<std::allocator<std::pair<const_pio_program*_const,_int>_>_>, *P__type_identity<std::allocator<std::pair<const_pio_program*_const,_int>_>_>;

struct __type_identity<std::allocator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: __type_identity<std::allocator<std::pair<const pio_program* const, int> > >
};

typedef struct integral_constant<bool,_true> integral_constant<bool,_true>, *Pintegral_constant<bool,_true>;

struct integral_constant<bool,_true> { // Original name: integral_constant<bool, true>
};

typedef struct remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>, *Premove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>;

struct remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> { // Original name: remove_reference<std::_Rb_tree_iterator<std::pair<int const, int> > >
};

typedef struct __conditional<true> __conditional<true>, *P__conditional<true>;

struct __conditional<true> {
};

typedef struct remove_reference<std::pair<int_const,_int>&> remove_reference<std::pair<int_const,_int>&>, *Premove_reference<std::pair<int_const,_int>&>;

struct remove_reference<std::pair<int_const,_int>&> { // Original name: remove_reference<std::pair<int const, int>&>
};


// WARNING! conflicting data type names: /DWARF/type_traits/std/__type_identity<std::allocator<std::pair<int_const,_int>_>_>/type - /DWARF/type

typedef type __type_identity_t;

typedef struct remove_reference<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> remove_reference<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>, *Premove_reference<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>;

struct remove_reference<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: remove_reference<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> > >
};

typedef struct remove_reference<unsigned_int&> remove_reference<unsigned_int&>, *Premove_reference<unsigned_int&>;

struct remove_reference<unsigned_int&> { // Original name: remove_reference<unsigned int&>
};


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_node_base*&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::pair<const_pio_program*_const,_int>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<const_pio_program*&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::pair<const_pio_program*_const,_int>&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<const_std::piecewise_construct_t&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/__type_identity<std::allocator<std::pair<const_pio_program*_const,_int>_>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::tuple<long_unsigned_int&>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::pair<int_const,_int>&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::pair<int_const,_int>_>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::_Rb_tree_node<std::pair<int_const,_int>_>*&>/type - /DWARF/type


// WARNING! conflicting data type names: /DWARF/type_traits/std/remove_reference<std::tuple<int_const&>_>/type - /DWARF/type

typedef struct _mbstate_t.conflict _mbstate_t.conflict, *P_mbstate_t.conflict;

struct _mbstate_t.conflict {
    int __count;
    union anon_union_4_2_91654ee9_for___value __value;
};


// WARNING! conflicting data type names: /DWARF/_types.h/__off_t - /types.h/__off_t

typedef struct 19dma_mpu_region_hw_t 19dma_mpu_region_hw_t, *P19dma_mpu_region_hw_t;

typedef struct 19dma_mpu_region_hw_t dma_mpu_region_hw_t;

struct 19dma_mpu_region_hw_t {
    io_rw_32 bar;
    io_rw_32 lar;
};

typedef struct 8dma_hw_t 8dma_hw_t, *P8dma_hw_t;

typedef struct 8dma_hw_t dma_hw_t;

typedef struct 16dma_channel_hw_t 16dma_channel_hw_t, *P16dma_channel_hw_t;

typedef struct 16dma_channel_hw_t dma_channel_hw_t;

typedef union anon_union_64_2_95a08ed8_for_8dma_hw_t_2 anon_union_64_2_95a08ed8_for_8dma_hw_t_2, *Panon_union_64_2_95a08ed8_for_8dma_hw_t_2;

typedef struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_8dma_hw_t_2_1 anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_8dma_hw_t_2_1, *Panon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_8dma_hw_t_2_1;

typedef struct 17dma_irq_ctrl_hw_t 17dma_irq_ctrl_hw_t, *P17dma_irq_ctrl_hw_t;

typedef struct 17dma_irq_ctrl_hw_t dma_irq_ctrl_hw_t;

struct 16dma_channel_hw_t {
    io_rw_32 read_addr;
    io_rw_32 write_addr;
    io_rw_32 transfer_count;
    io_rw_32 ctrl_trig;
    io_rw_32 al1_ctrl;
    io_rw_32 al1_read_addr;
    io_rw_32 al1_write_addr;
    io_rw_32 al1_transfer_count_trig;
    io_rw_32 al2_ctrl;
    io_rw_32 al2_transfer_count;
    io_rw_32 al2_read_addr;
    io_rw_32 al2_write_addr_trig;
    io_rw_32 al3_ctrl;
    io_rw_32 al3_write_addr;
    io_rw_32 al3_transfer_count;
    io_rw_32 al3_read_addr_trig;
};

struct 17dma_irq_ctrl_hw_t {
    io_rw_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_rw_32 ints;
};

struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_8dma_hw_t_2_1 {
    io_rw_32 intr;
    io_rw_32 inte0;
    io_rw_32 intf0;
    io_rw_32 ints0;
    uint32_t __pad0;
    io_rw_32 inte1;
    io_rw_32 intf1;
    io_rw_32 ints1;
    uint32_t __pad1;
    io_rw_32 inte2;
    io_rw_32 intf2;
    io_rw_32 ints2;
    uint32_t __pad2;
    io_rw_32 inte3;
    io_rw_32 intf3;
    io_rw_32 ints3;
};

union anon_union_64_2_95a08ed8_for_8dma_hw_t_2 {
    struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_8dma_hw_t_2_1 field_0;
    dma_irq_ctrl_hw_t irq_ctrl[4];
};

struct 8dma_hw_t {
    dma_channel_hw_t ch[16];
    union anon_union_64_2_95a08ed8_for_8dma_hw_t_2 field_1;
    io_rw_32 timer[4];
    io_wo_32 multi_channel_trigger;
    io_rw_32 sniff_ctrl;
    io_rw_32 sniff_data;
    uint32_t _pad0;
    io_ro_32 fifo_levels;
    io_wo_32 abort;
    io_ro_32 n_channels;
    uint32_t _pad1[5];
    io_rw_32 seccfg_ch[16];
    io_rw_32 seccfg_irq[4];
    io_rw_32 seccfg_misc;
    uint32_t _pad2[11];
    io_rw_32 mpu_ctrl;
    dma_mpu_region_hw_t mpu_region[8];
};

typedef enum dma_channel_transfer_size {
    DMA_SIZE_8=0,
    DMA_SIZE_16=1,
    DMA_SIZE_32=2
} dma_channel_transfer_size;

typedef enum dma_channel_transfer_size dma_channel_transfer_size_t;

typedef struct 20dma_channel_config_t 20dma_channel_config_t, *P20dma_channel_config_t;

struct 20dma_channel_config_t {
    uint32_t ctrl;
};

typedef struct 20dma_channel_config_t dma_channel_config_t;

typedef struct dma_channel_hw_t.conflict dma_channel_hw_t.conflict, *Pdma_channel_hw_t.conflict;

struct dma_channel_hw_t.conflict {
    io_rw_32 read_addr;
    io_rw_32 write_addr;
    io_rw_32 transfer_count;
    io_rw_32 ctrl_trig;
    io_rw_32 al1_ctrl;
    io_rw_32 al1_read_addr;
    io_rw_32 al1_write_addr;
    io_rw_32 al1_transfer_count_trig;
    io_rw_32 al2_ctrl;
    io_rw_32 al2_transfer_count;
    io_rw_32 al2_read_addr;
    io_rw_32 al2_write_addr_trig;
    io_rw_32 al3_ctrl;
    io_rw_32 al3_write_addr;
    io_rw_32 al3_transfer_count;
    io_rw_32 al3_read_addr_trig;
};

typedef struct dma_mpu_region_hw_t.conflict dma_mpu_region_hw_t.conflict, *Pdma_mpu_region_hw_t.conflict;

struct dma_mpu_region_hw_t.conflict {
    io_rw_32 bar;
    io_rw_32 lar;
};

typedef struct dma_hw_t.conflict dma_hw_t.conflict, *Pdma_hw_t.conflict;

typedef union anon_union_64_2_95a08ed8_for_dma_hw_t_1 anon_union_64_2_95a08ed8_for_dma_hw_t_1, *Panon_union_64_2_95a08ed8_for_dma_hw_t_1;

typedef struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_dma_hw_t_1_0 anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_dma_hw_t_1_0, *Panon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_dma_hw_t_1_0;

struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_dma_hw_t_1_0 {
    io_rw_32 intr;
    io_rw_32 inte0;
    io_rw_32 intf0;
    io_rw_32 ints0;
    uint32_t __pad0;
    io_rw_32 inte1;
    io_rw_32 intf1;
    io_rw_32 ints1;
    uint32_t __pad1;
    io_rw_32 inte2;
    io_rw_32 intf2;
    io_rw_32 ints2;
    uint32_t __pad2;
    io_rw_32 inte3;
    io_rw_32 intf3;
    io_rw_32 ints3;
};

union anon_union_64_2_95a08ed8_for_dma_hw_t_1 {
    struct anon_struct_64_16_360f5796_for_anon_union_64_2_95a08ed8_for_dma_hw_t_1_0 field_0;
    dma_irq_ctrl_hw_t irq_ctrl[4];
};

struct dma_hw_t.conflict {
    dma_channel_hw_t ch[16];
    union anon_union_64_2_95a08ed8_for_dma_hw_t_1 field_1;
    io_rw_32 timer[4];
    io_wo_32 multi_channel_trigger;
    io_rw_32 sniff_ctrl;
    io_rw_32 sniff_data;
    uint32_t _pad0;
    io_ro_32 fifo_levels;
    io_wo_32 abort;
    io_ro_32 n_channels;
    uint32_t _pad1[5];
    io_rw_32 seccfg_ch[16];
    io_rw_32 seccfg_irq[4];
    io_rw_32 seccfg_misc;
    uint32_t _pad2[11];
    io_rw_32 mpu_ctrl;
    dma_mpu_region_hw_t mpu_region[8];
};

typedef enum dma_address_update_type {
    DMA_ADDRESS_UPDATE_NONE=0,
    DMA_ADDRESS_UPDATE_INCREMENT=1,
    DMA_ADDRESS_UPDATE_INCREMENT_BY_TWO=2,
    DMA_ADDRESS_UPDATE_DECREMENT=3
} dma_address_update_type;

typedef dma_channel_config_t dma_channel_config;

typedef enum dma_address_update_type dma_address_update_type_t;

typedef struct dma_irq_ctrl_hw_t.conflict dma_irq_ctrl_hw_t.conflict, *Pdma_irq_ctrl_hw_t.conflict;

struct dma_irq_ctrl_hw_t.conflict {
    io_rw_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_rw_32 ints;
};

typedef uint32_t boot_lock_t;

typedef struct _Tuple_impl<0,_int_const&> _Tuple_impl<0,_int_const&>, *P_Tuple_impl<0,_int_const&>;

typedef struct _Head_base<0,_int_const&,_false> _Head_base<0,_int_const&,_false>, *P_Head_base<0,_int_const&,_false>;

struct _Head_base<0,_int_const&,_false> { // Original name: _Head_base<0, int const&, false>
    int *_M_head_impl;
};

struct _Tuple_impl<0,_int_const&> { // Original name: _Tuple_impl<0, int const&>
    struct _Head_base<0,_int_const&,_false> super__Head_base<0,_int_const&,_false>;
};

typedef struct _Head_base<0,_long_unsigned_int&,_false> _Head_base<0,_long_unsigned_int&,_false>, *P_Head_base<0,_long_unsigned_int&,_false>;

struct _Head_base<0,_long_unsigned_int&,_false> { // Original name: _Head_base<0, long unsigned int&, false>
    ulong *_M_head_impl;
};

typedef struct tuple<long_unsigned_int&> tuple<long_unsigned_int&>, *Ptuple<long_unsigned_int&>;

typedef struct _Tuple_impl<0,_long_unsigned_int&> _Tuple_impl<0,_long_unsigned_int&>, *P_Tuple_impl<0,_long_unsigned_int&>;

struct _Tuple_impl<0,_long_unsigned_int&> { // Original name: _Tuple_impl<0, long unsigned int&>
    struct _Head_base<0,_long_unsigned_int&,_false> super__Head_base<0,_long_unsigned_int&,_false>;
};

struct tuple<long_unsigned_int&> { // Original name: tuple<long unsigned int&>
    struct _Tuple_impl<0,_long_unsigned_int&> super__Tuple_impl<0,_long_unsigned_int&>;
};

typedef struct tuple<int_const&> tuple<int_const&>, *Ptuple<int_const&>;

struct tuple<int_const&> { // Original name: tuple<int const&>
    struct _Tuple_impl<0,_int_const&> super__Tuple_impl<0,_int_const&>;
};

typedef _ssize_t ssize_t;

typedef __off_t off_t;

typedef _fpos_t fpos_t;

typedef enum 29hid_interface_protocol_enum_t {
    HID_ITF_PROTOCOL_NONE=0,
    HID_ITF_PROTOCOL_KEYBOARD=1,
    HID_ITF_PROTOCOL_MOUSE=2
} 29hid_interface_protocol_enum_t;

typedef enum hid_report_type_t.conflict {
    HID_REPORT_TYPE_INVALID=0,
    HID_REPORT_TYPE_INPUT=1,
    HID_REPORT_TYPE_OUTPUT=2,
    HID_REPORT_TYPE_FEATURE=3
} hid_report_type_t.conflict;

typedef enum 21hid_descriptor_enum_t {
    HID_DESC_TYPE_HID=33,
    HID_DESC_TYPE_REPORT=34,
    HID_DESC_TYPE_PHYSICAL=35
} 21hid_descriptor_enum_t;

typedef enum 17hid_report_type_t {
    HID_REPORT_TYPE_INVALID=0,
    HID_REPORT_TYPE_INPUT=1,
    HID_REPORT_TYPE_OUTPUT=2,
    HID_REPORT_TYPE_FEATURE=3
} 17hid_report_type_t;

typedef enum 17hid_report_type_t hid_report_type_t;

typedef enum 29hid_interface_protocol_enum_t hid_interface_protocol_enum_t;

typedef struct hid_mouse_report_t hid_mouse_report_t, *Phid_mouse_report_t;

struct hid_mouse_report_t {
    uint8_t buttons;
    int8_t x;
    int8_t y;
    int8_t wheel;
    int8_t pan;
};

typedef struct hid_keyboard_report_t hid_keyboard_report_t, *Phid_keyboard_report_t;

struct hid_keyboard_report_t {
    uint8_t modifier;
    uint8_t reserved;
    uint8_t keycode[6];
};

typedef enum 19hid_subclass_enum_t {
    HID_SUBCLASS_NONE=0,
    HID_SUBCLASS_BOOT=1
} 19hid_subclass_enum_t;

typedef enum 19hid_subclass_enum_t hid_subclass_enum_t;

typedef enum 21hid_descriptor_enum_t hid_descriptor_enum_t;

typedef struct hid_abs_mouse_report_t hid_abs_mouse_report_t, *Phid_abs_mouse_report_t;

struct hid_abs_mouse_report_t {
    uint8_t buttons;
    int16_t x;
    int16_t y;
    int8_t wheel;
    int8_t pan;
};

typedef struct hid_gamepad_report_t hid_gamepad_report_t, *Phid_gamepad_report_t;

struct hid_gamepad_report_t {
    int8_t x;
    int8_t y;
    int8_t z;
    int8_t rz;
    int8_t rx;
    int8_t ry;
    uint8_t hat;
    uint32_t buttons;
};

typedef struct u8x8_tile_struct u8x8_tile_struct, *Pu8x8_tile_struct;

typedef struct u8x8_tile_struct u8x8_tile_t;

struct u8x8_tile_struct {
    uint8_t *tile_ptr;
    uint8_t cnt;
    uint8_t x_pos;
    uint8_t y_pos;
};

typedef struct _atexit _atexit, *P_atexit;

typedef struct _on_exit_args _on_exit_args, *P_on_exit_args;

struct _atexit {
    struct _atexit *_next;
    int _ind;
    void (*_fns[32])(void);
    struct _on_exit_args *_on_exit_args_ptr;
};

struct _on_exit_args {
    void *_fnargs[32];
    void *_dso_handle[32];
    __ULong _fntypes;
    __ULong _is_cxa;
};

typedef struct map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_> map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>, *Pmap<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>;


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/_Rep_type - /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/_Rep_type

struct map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: map<const pio_program*, int, std::less<const pio_program*>, std::allocator<std::pair<const pio_program* const, int> > >
    _Rep_type _M_t;
};


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/insert_return_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/insert_return_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/value_type - /DWARF/value_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/const_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/reverse_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/reverse_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/node_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/node_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/iterator - /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/iterator

typedef struct less<int> key_compare;


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/const_reverse_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_reverse_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/size_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/size_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/insert_return_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/insert_return_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_reverse_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_reverse_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/value_type - /DWARF/value_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/key_type - /DWARF/key_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/size_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/size_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/reverse_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/reverse_iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/node_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/node_type


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/iterator - /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/iterator


// WARNING! conflicting data type names: /DWARF/stl_map.h/std/map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/key_compare - /DWARF/stl_map.h/std/map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>/key_compare

typedef struct HardwareSerial HardwareSerial, *PHardwareSerial;

struct HardwareSerial {
    struct Stream super_Stream;
};

typedef struct usbd_device_t usbd_device_t, *Pusbd_device_t;

typedef struct anon_struct_1_6_aaf8013d_for_usbd_device_t_0 anon_struct_1_6_aaf8013d_for_usbd_device_t_0, *Panon_struct_1_6_aaf8013d_for_usbd_device_t_0;

struct anon_struct_1_6_aaf8013d_for_usbd_device_t_0 {
    uint8_t connected:1;
    uint8_t addressed:1;
    uint8_t suspended:1;
    uint8_t remote_wakeup_en:1;
    uint8_t remote_wakeup_support:1;
    uint8_t self_powered:1;
};

struct usbd_device_t {
    struct anon_struct_1_6_aaf8013d_for_usbd_device_t_0 field_0;
    uint8_t cfg_num;
    uint8_t speed;
    uint8_t sof_consumer;
    uint8_t itf2drv[16];
    uint8_t ep2drv[16][2];
    struct tu_edpt_state_t ep_status[16][2];
};

typedef struct U8G2_SSD1306_128X64_NONAME_F_HW_I2C U8G2_SSD1306_128X64_NONAME_F_HW_I2C, *PU8G2_SSD1306_128X64_NONAME_F_HW_I2C;

typedef struct U8G2 U8G2, *PU8G2;

struct U8G2 {
    struct Print super_Print;
    u8g2_t u8g2;
    u8x8_char_cb cpp_next_cb;
    u8g2_uint_t tx;
    u8g2_uint_t ty;
};

struct U8G2_SSD1306_128X64_NONAME_F_HW_I2C {
    struct U8G2 super_U8G2;
};

typedef struct U8G2LOG U8G2LOG, *PU8G2LOG;

struct U8G2LOG {
    struct Print super_Print;
    u8log_t u8log;
};


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat


// WARNING! conflicting data type names: /DWARF/CoreMutex.h/anon_enum_32 - /DWARF/vfprintf.c/_vfiprintf_r/anon_enum_32

typedef struct CoreMutex CoreMutex, *PCoreMutex;

struct CoreMutex {
    mutex_t *_mutex;
    bool _acquired;
    uint8_t _option;
};

typedef struct pico_unique_board_id_t pico_unique_board_id_t, *Ppico_unique_board_id_t;

struct pico_unique_board_id_t {
    uint8_t id[8];
};

typedef struct osal_queue_def_t osal_queue_def_t, *Posal_queue_def_t;

struct osal_queue_def_t {
    struct tu_fifo_t ff;
    struct critical_section critsec;
};

typedef struct osal_queue_def_t *osal_queue_t;

typedef uint8_t io_wo_8;

typedef uint16_t io_ro_16;

typedef uint16_t io_rw_16;

typedef struct _Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> _Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>, *P_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>;

typedef struct _Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> _Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>, *P_Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>;


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/__pointer - /DWARF/node_handle.h/std/_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/__pointer

struct _Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> { // Original name: _Node_handle_common<std::pair<int const, int>, std::allocator<std::_Rb_tree_node<std::pair<int const, int> > > >
Missing member _M_alloc : _Optional_alloc at offset 0x0 [conflicting member at same offset]
    pointer _M_ptr;
};

struct _Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> { // Original name: _Node_handle<int, std::pair<int const, int>, std::allocator<std::_Rb_tree_node<std::pair<int const, int> > > >
    struct _Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_> super__Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>;
    __pointer _M_pkey;
    __pointer _M_pmapped;
};


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/key_type - /DWARF/key_type


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/mapped_type - /DWARF/mapped_type

typedef union _Optional_alloc _Optional_alloc, *P_Optional_alloc;

union _Optional_alloc {
    struct allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> _M_alloc;
};


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/mapped_type - /DWARF/mapped_type


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/_Optional_alloc - /DWARF/node_handle.h/std/_Node_handle_common<std::pair<const_pio_program*_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>_>/_Optional_alloc


// WARNING! conflicting data type names: /DWARF/node_handle.h/std/_Node_handle_common<std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>/allocator_type - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/allocator_type

typedef struct SerialUSB SerialUSB, *PSerialUSB;

typedef struct N9SerialUSB14SyntheticStateE N9SerialUSB14SyntheticStateE, *PN9SerialUSB14SyntheticStateE;

typedef struct N9SerialUSB14SyntheticStateE SyntheticState;

struct N9SerialUSB14SyntheticStateE {
    uint rebooting:1;
    uint ignoreFlowControl:1;
    uint dtr:1;
    uint rts:1;
    uint bps:28;
};

struct SerialUSB {
    struct HardwareSerial super_HardwareSerial;
    bool _running;
    uint8_t _id;
    uint8_t _epIn;
    uint8_t _epOut;
    uint8_t _epIn2;
    uint8_t _strID;
    SyntheticState _ss;
};

typedef struct tm tm, *Ptm;

struct tm {
};

typedef struct Printable Printable, *PPrintable;

struct Printable {
};

typedef struct UDP UDP, *PUDP;

struct UDP {
};

typedef struct __FlashStringHelper __FlashStringHelper, *P__FlashStringHelper;

struct __FlashStringHelper {
};

typedef struct pair<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_> pair<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_>, *Ppair<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_>;

struct pair<std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: pair<std::_Rb_tree_const_iterator<std::pair<const pio_program* const, int> >, std::_Rb_tree_const_iterator<std::pair<const pio_program* const, int> > >
};

typedef struct _Node_insert_return<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>_> _Node_insert_return<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>_>, *P_Node_insert_return<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>_>;

struct _Node_insert_return<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Node_handle<int,_std::pair<int_const,_int>,_std::allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>_>_> { // Original name: _Node_insert_return<std::_Rb_tree_iterator<std::pair<int const, int> >, std::_Node_handle<int, std::pair<int const, int>, std::allocator<std::_Rb_tree_node<std::pair<int const, int> > > > >
};

typedef struct bad_alloc bad_alloc, *Pbad_alloc;

struct bad_alloc {
};

typedef struct type_info type_info, *Ptype_info;

struct type_info {
};

typedef struct reverse_iterator<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_> reverse_iterator<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_>, *Preverse_iterator<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_>;

struct reverse_iterator<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_> { // Original name: reverse_iterator<std::_Rb_tree_const_iterator<std::pair<int const, int> > >
};

typedef struct pair<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_> pair<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_>, *Ppair<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_>;

struct pair<std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_const_iterator<std::pair<int_const,_int>_>_> { // Original name: pair<std::_Rb_tree_const_iterator<std::pair<int const, int> >, std::_Rb_tree_const_iterator<std::pair<int const, int> > >
};

typedef struct pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>, *Ppair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_>;

struct pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>_> { // Original name: pair<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> >, std::_Rb_tree_iterator<std::pair<const pio_program* const, int> > >
};

typedef struct reverse_iterator<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> reverse_iterator<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>, *Preverse_iterator<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>;

struct reverse_iterator<std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> { // Original name: reverse_iterator<std::_Rb_tree_iterator<std::pair<int const, int> > >
};

typedef struct value_compare value_compare, *Pvalue_compare;

struct value_compare {
};

typedef enum riscv_vector_num {
    RISCV_VEC_MACHINE_EXCEPTION=0,
    RISCV_VEC_MACHINE_SOFTWARE_IRQ=3,
    RISCV_VEC_MACHINE_TIMER_IRQ=7,
    RISCV_VEC_MACHINE_EXTERNAL_IRQ=11
} riscv_vector_num;

typedef void (*irq_handler_t)(void);

typedef struct irq_handler_chain_slot irq_handler_chain_slot, *Pirq_handler_chain_slot;

typedef union anon_union_2_2_65aad746_for_irq_handler_chain_slot_3 anon_union_2_2_65aad746_for_irq_handler_chain_slot_3, *Panon_union_2_2_65aad746_for_irq_handler_chain_slot_3;

typedef struct anon_struct_2_2_3efb522a_for_anon_union_2_2_65aad746_for_irq_handler_chain_slot_3_0 anon_struct_2_2_3efb522a_for_anon_union_2_2_65aad746_for_irq_handler_chain_slot_3_0, *Panon_struct_2_2_3efb522a_for_anon_union_2_2_65aad746_for_irq_handler_chain_slot_3_0;

struct anon_struct_2_2_3efb522a_for_anon_union_2_2_65aad746_for_irq_handler_chain_slot_3_0 {
    int8_t link;
    uint8_t priority;
};

union anon_union_2_2_65aad746_for_irq_handler_chain_slot_3 {
    struct anon_struct_2_2_3efb522a_for_anon_union_2_2_65aad746_for_irq_handler_chain_slot_3_0 field_0;
    uint16_t inst4;
};

struct irq_handler_chain_slot {
    uint32_t inst1;
    uint32_t inst2;
    uint16_t inst3;
    union anon_union_2_2_65aad746_for_irq_handler_chain_slot_3 field_3;
};

typedef struct 14pwm_slice_hw_t 14pwm_slice_hw_t, *P14pwm_slice_hw_t;

typedef struct 14pwm_slice_hw_t pwm_slice_hw_t;

struct 14pwm_slice_hw_t {
    io_rw_32 csr;
    io_rw_32 div;
    io_rw_32 ctr;
    io_rw_32 cc;
    io_rw_32 top;
};

typedef struct 8pwm_hw_t 8pwm_hw_t, *P8pwm_hw_t;

typedef struct 8pwm_hw_t pwm_hw_t;

typedef union anon_union_24_2_95a08ed8_for_8pwm_hw_t_4 anon_union_24_2_95a08ed8_for_8pwm_hw_t_4, *Panon_union_24_2_95a08ed8_for_8pwm_hw_t_4;

typedef struct anon_struct_24_6_2b3a2369_for_anon_union_24_2_95a08ed8_for_8pwm_hw_t_4_1 anon_struct_24_6_2b3a2369_for_anon_union_24_2_95a08ed8_for_8pwm_hw_t_4_1, *Panon_struct_24_6_2b3a2369_for_anon_union_24_2_95a08ed8_for_8pwm_hw_t_4_1;

typedef struct 17pwm_irq_ctrl_hw_t 17pwm_irq_ctrl_hw_t, *P17pwm_irq_ctrl_hw_t;

typedef struct 17pwm_irq_ctrl_hw_t pwm_irq_ctrl_hw_t;

struct anon_struct_24_6_2b3a2369_for_anon_union_24_2_95a08ed8_for_8pwm_hw_t_4_1 {
    io_rw_32 inte;
    io_rw_32 intf;
    io_rw_32 ints;
    io_rw_32 inte1;
    io_rw_32 intf1;
    io_rw_32 ints1;
};

struct 17pwm_irq_ctrl_hw_t {
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

union anon_union_24_2_95a08ed8_for_8pwm_hw_t_4 {
    struct anon_struct_24_6_2b3a2369_for_anon_union_24_2_95a08ed8_for_8pwm_hw_t_4_1 field_0;
    pwm_irq_ctrl_hw_t irq_ctrl[2];
};

struct 8pwm_hw_t {
    pwm_slice_hw_t slice[12];
    io_rw_32 en;
    io_rw_32 intr;
    union anon_union_24_2_95a08ed8_for_8pwm_hw_t_4 field_3;
};

typedef enum pwm_clkdiv_mode {
    PWM_DIV_FREE_RUNNING=0,
    PWM_DIV_B_HIGH=1,
    PWM_DIV_B_RISING=2,
    PWM_DIV_B_FALLING=3
} pwm_clkdiv_mode;

typedef struct 10pwm_config 10pwm_config, *P10pwm_config;

struct 10pwm_config {
    uint32_t csr;
    uint32_t div;
    uint32_t top;
};

typedef struct 10pwm_config pwm_config;

typedef enum align_val_t {
} align_val_t;

typedef void (*new_handler)(void);

typedef struct nothrow_t nothrow_t, *Pnothrow_t;

struct nothrow_t {
};

typedef struct pll_hw_t pll_hw_t, *Ppll_hw_t;

struct pll_hw_t {
    io_rw_32 cs;
    io_rw_32 pwr;
    io_rw_32 fbdiv_int;
    io_rw_32 prim;
    io_rw_32 intr;
    io_rw_32 inte;
    io_rw_32 intf;
    io_ro_32 ints;
};

typedef struct pll_hw_t *PLL;

typedef struct usbd_control_xfer_t usbd_control_xfer_t, *Pusbd_control_xfer_t;

struct usbd_control_xfer_t {
    struct tusb_control_request_t request;
    uint8_t *buffer;
    uint16_t data_len;
    uint16_t total_xferred;
    usbd_control_xfer_cb_t complete_cb;
};

typedef struct anon_struct_64_1_2f67eb89 anon_struct_64_1_2f67eb89, *Panon_struct_64_1_2f67eb89;

typedef union anon_union_64_2_2e94c8e8_for_anon_struct_64_1_2f67eb89_0 anon_union_64_2_2e94c8e8_for_anon_struct_64_1_2f67eb89_0, *Panon_union_64_2_2e94c8e8_for_anon_struct_64_1_2f67eb89_0;

union anon_union_64_2_2e94c8e8_for_anon_struct_64_1_2f67eb89_0 {
    uint8_t buf[64];
    uint8_t buf_dcache_padding[64];
};

struct anon_struct_64_1_2f67eb89 {
    union anon_union_64_2_2e94c8e8_for_anon_struct_64_1_2f67eb89_0 field_0;
};

typedef struct 6ldiv_t 6ldiv_t, *P6ldiv_t;

typedef struct 6ldiv_t ldiv_t;

struct 6ldiv_t {
    long quot;
    long rem;
};

typedef struct 7lldiv_t 7lldiv_t, *P7lldiv_t;

struct 7lldiv_t {
    longlong quot;
    longlong rem;
};

typedef struct 5div_t 5div_t, *P5div_t;

struct 5div_t {
    int quot;
    int rem;
};

typedef struct 5div_t div_t;

typedef int (*__compar_fn_t)(void *, void *);

typedef struct 7lldiv_t lldiv_t;


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/reference - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer

typedef struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> *const_reference;

typedef struct _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> *const_pointer;


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<int_const,_int>_>/const_reference - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<int_const,_int>_>/const_pointer - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_pointer


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<const_pio_program*_const,_int>_>/reference - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<const_pio_program*_const,_int>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<const_pio_program*_const,_int>_>/const_reference - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::pair<const_pio_program*_const,_int>_>/const_pointer - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_pointer


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/reference - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/pointer - /DWARF/stl_tree.h/std/_Rb_tree_iterator<std::pair<int_const,_int>_>/pointer


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/const_reference - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_reference


// WARNING! conflicting data type names: /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_>/const_pointer - /DWARF/new_allocator.h/std/__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_>/const_pointer

typedef struct initializer_list<std::pair<int_const,_int>_> initializer_list<std::pair<int_const,_int>_>, *Pinitializer_list<std::pair<int_const,_int>_>;


// WARNING! conflicting data type names: /DWARF/initializer_list/std/initializer_list<std::pair<int_const,_int>_>/iterator - /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/iterator

struct initializer_list<std::pair<int_const,_int>_> { // Original name: initializer_list<std::pair<int const, int> >
    iterator _M_array;
    size_type _M_len;
};

typedef struct initializer_list<std::pair<const_pio_program*_const,_int>_> initializer_list<std::pair<const_pio_program*_const,_int>_>, *Pinitializer_list<std::pair<const_pio_program*_const,_int>_>;


// WARNING! conflicting data type names: /DWARF/initializer_list/std/initializer_list<std::pair<const_pio_program*_const,_int>_>/iterator - /DWARF/stl_tree.h/std/_Rb_tree_const_iterator<std::pair<int_const,_int>_>/iterator

struct initializer_list<std::pair<const_pio_program*_const,_int>_> { // Original name: initializer_list<std::pair<const pio_program* const, int> >
    iterator _M_array;
    size_type _M_len;
};


// WARNING! conflicting data type names: /DWARF/initializer_list/std/initializer_list<std::pair<int_const,_int>_>/const_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator


// WARNING! conflicting data type names: /DWARF/initializer_list/std/initializer_list<std::pair<const_pio_program*_const,_int>_>/const_iterator - /DWARF/stl_tree.h/std/_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>/const_iterator

typedef struct exception_ptr exception_ptr, *Pexception_ptr;

struct exception_ptr {
    void *_M_exception_object;
};

typedef union anon_union_2_2_77b30818 anon_union_2_2_77b30818, *Panon_union_2_2_77b30818;

typedef struct anon_struct_2_2_43b9fe83_for_anon_union_2_2_77b30818_6 anon_struct_2_2_43b9fe83_for_anon_union_2_2_77b30818_6, *Panon_struct_2_2_43b9fe83_for_anon_union_2_2_77b30818_6;

struct anon_struct_2_2_43b9fe83_for_anon_union_2_2_77b30818_6 {
    uint8_t lsb;
    uint8_t msb;
};

union anon_union_2_2_77b30818 {
    uint16_t val;
    struct anon_struct_2_2_43b9fe83_for_anon_union_2_2_77b30818_6 field_1;
};

typedef enum tu_fifo_copy_mode_t {
    TU_FIFO_COPY_INC=0
} tu_fifo_copy_mode_t;

typedef union DWunion DWunion, *PDWunion;

typedef struct DWstruct DWstruct, *PDWstruct;

struct DWstruct {
    SItype low;
    SItype high;
};

union DWunion {
    struct DWstruct s;
    DItype ll;
};

typedef struct i2c_hw_t.conflict i2c_hw_t.conflict, *Pi2c_hw_t.conflict;

struct i2c_hw_t.conflict {
    io_rw_32 con;
    io_rw_32 tar;
    io_rw_32 sar;
    uint32_t _pad0;
    io_rw_32 data_cmd;
    io_rw_32 ss_scl_hcnt;
    io_rw_32 ss_scl_lcnt;
    io_rw_32 fs_scl_hcnt;
    io_rw_32 fs_scl_lcnt;
    uint32_t _pad1[2];
    io_ro_32 intr_stat;
    io_rw_32 intr_mask;
    io_ro_32 raw_intr_stat;
    io_rw_32 rx_tl;
    io_rw_32 tx_tl;
    io_ro_32 clr_intr;
    io_ro_32 clr_rx_under;
    io_ro_32 clr_rx_over;
    io_ro_32 clr_tx_over;
    io_ro_32 clr_rd_req;
    io_ro_32 clr_tx_abrt;
    io_ro_32 clr_rx_done;
    io_ro_32 clr_activity;
    io_ro_32 clr_stop_det;
    io_ro_32 clr_start_det;
    io_ro_32 clr_gen_call;
    io_rw_32 enable;
    io_ro_32 status;
    io_ro_32 txflr;
    io_ro_32 rxflr;
    io_rw_32 sda_hold;
    io_ro_32 tx_abrt_source;
    io_rw_32 slv_data_nack_only;
    io_rw_32 dma_cr;
    io_rw_32 dma_tdlr;
    io_rw_32 dma_rdlr;
    io_rw_32 sda_setup;
    io_rw_32 ack_general_call;
    io_ro_32 enable_status;
    io_rw_32 fs_spklen;
    uint32_t _pad2;
    io_ro_32 clr_restart_det;
    uint32_t _pad3[18];
    io_ro_32 comp_param_1;
    io_ro_32 comp_version;
    io_ro_32 comp_type;
};

typedef struct tu_fifo_buffer_info_t tu_fifo_buffer_info_t, *Ptu_fifo_buffer_info_t;

struct tu_fifo_buffer_info_t {
    uint16_t len_lin;
    uint16_t len_wrap;
    void *ptr_lin;
    void *ptr_wrap;
};

typedef enum dcd_eventid_t {
    DCD_EVENT_INVALID=0,
    DCD_EVENT_BUS_RESET=1,
    DCD_EVENT_UNPLUGGED=2,
    DCD_EVENT_SOF=3,
    DCD_EVENT_SUSPEND=4,
    DCD_EVENT_RESUME=5,
    DCD_EVENT_SETUP_RECEIVED=6,
    DCD_EVENT_XFER_COMPLETE=7,
    USBD_EVENT_FUNC_CALL=8,
    DCD_EVENT_COUNT=9
} dcd_eventid_t;

typedef struct dcd_event_t dcd_event_t, *Pdcd_event_t;

typedef union anon_union_8_5_b4e6b02b_for_dcd_event_t_2 anon_union_8_5_b4e6b02b_for_dcd_event_t_2, *Panon_union_8_5_b4e6b02b_for_dcd_event_t_2;

typedef struct anon_struct_4_1_a8a2ef67_for_bus_reset anon_struct_4_1_a8a2ef67_for_bus_reset, *Panon_struct_4_1_a8a2ef67_for_bus_reset;

typedef struct anon_struct_4_1_1ccbc21d_for_sof anon_struct_4_1_1ccbc21d_for_sof, *Panon_struct_4_1_1ccbc21d_for_sof;

typedef struct anon_struct_8_3_67226144_for_xfer_complete anon_struct_8_3_67226144_for_xfer_complete, *Panon_struct_8_3_67226144_for_xfer_complete;

typedef struct anon_struct_8_2_23f91d10_for_func_call anon_struct_8_2_23f91d10_for_func_call, *Panon_struct_8_2_23f91d10_for_func_call;

struct anon_struct_8_3_67226144_for_xfer_complete {
    uint8_t ep_addr;
    uint8_t result;
    uint32_t len;
};

struct anon_struct_8_2_23f91d10_for_func_call {
    void (*func)(void *);
    void *param;
};

struct anon_struct_4_1_1ccbc21d_for_sof {
    uint32_t frame_count;
};

struct anon_struct_4_1_a8a2ef67_for_bus_reset {
    enum tusb_speed_t.conflict speed;
};

union anon_union_8_5_b4e6b02b_for_dcd_event_t_2 {
    struct anon_struct_4_1_a8a2ef67_for_bus_reset bus_reset;
    struct anon_struct_4_1_1ccbc21d_for_sof sof;
    struct tusb_control_request_t setup_received;
    struct anon_struct_8_3_67226144_for_xfer_complete xfer_complete;
    struct anon_struct_8_2_23f91d10_for_func_call func_call;
};

struct dcd_event_t {
    uint8_t rhport;
    uint8_t event_id;
    union anon_union_8_5_b4e6b02b_for_dcd_event_t_2 field_2;
};

typedef struct __siov __siov, *P__siov;

struct __siov {
    void *iov_base;
    size_t iov_len;
};

typedef struct __suio __suio, *P__suio;

struct __suio {
    struct __siov *uio_iov;
    int uio_iovcnt;
    size_t uio_resid;
};

typedef struct ticks_slice_hw_t ticks_slice_hw_t, *Pticks_slice_hw_t;

struct ticks_slice_hw_t {
    io_rw_32 ctrl;
    io_rw_32 cycles;
    io_ro_32 count;
};

typedef enum tick_gen_num_rp2350 {
    TICK_PROC0=0,
    TICK_PROC1=1,
    TICK_TIMER0=2,
    TICK_TIMER1=3,
    TICK_WATCHDOG=4,
    TICK_RISCV=5,
    TICK_COUNT=6
} tick_gen_num_rp2350;

typedef struct ticks_hw_t ticks_hw_t, *Pticks_hw_t;

struct ticks_hw_t {
    struct ticks_slice_hw_t ticks[6];
};

typedef enum tick_gen_num_rp2350 tick_gen_num_t;

typedef enum pico_error_codes {
    PICO_ERROR_RESOURCE_IN_USE=-21,
    PICO_ERROR_VERSION_MISMATCH=-20,
    PICO_ERROR_LOCK_REQUIRED=-19,
    PICO_ERROR_UNSUPPORTED_MODIFICATION=-18,
    PICO_ERROR_NOT_FOUND=-17,
    PICO_ERROR_INVALID_DATA=-16,
    PICO_ERROR_MODIFIED_DATA=-15,
    PICO_ERROR_PRECONDITION_NOT_MET=-14,
    PICO_ERROR_BUFFER_TOO_SMALL=-13,
    PICO_ERROR_INVALID_STATE=-12,
    PICO_ERROR_BAD_ALIGNMENT=-11,
    PICO_ERROR_INVALID_ADDRESS=-10,
    PICO_ERROR_INSUFFICIENT_RESOURCES=-9,
    PICO_ERROR_CONNECT_FAILED=-8,
    PICO_ERROR_BADAUTH=-7,
    PICO_ERROR_IO=-6,
    PICO_ERROR_INVALID_ARG=-5,
    PICO_ERROR_NOT_PERMITTED=-4,
    PICO_ERROR_NO_DATA=-3,
    PICO_ERROR_TIMEOUT=-2,
    PICO_ERROR_GENERIC=-1,
    PICO_ERROR_NONE=0,
    PICO_OK=0
} pico_error_codes;

typedef struct interp_hw_t.conflict interp_hw_t.conflict, *Pinterp_hw_t.conflict;

struct interp_hw_t.conflict {
    io_rw_32 accum[2];
    io_rw_32 base[3];
    io_ro_32 pop[3];
    io_ro_32 peek[3];
    io_rw_32 ctrl[2];
    io_rw_32 add_raw[2];
    io_wo_32 base01;
};

typedef struct hw_endpoint hw_endpoint, *Phw_endpoint;

struct hw_endpoint {
    _Bool configured;
    _Bool rx;
    uint8_t ep_addr;
    uint8_t next_pid;
    io_rw_32 *endpoint_control;
    io_rw_32 *buffer_control;
    uint8_t *hw_data_buf;
    uint8_t *user_buf;
    uint16_t remaining_len;
    uint16_t xferred_len;
    uint16_t wMaxPacketSize;
    _Bool active;
    uint8_t transfer_type;
    uint8_t pending;
};

typedef struct recursive_mutex_t recursive_mutex_t, *Precursive_mutex_t;

struct recursive_mutex_t {
    lock_core_t core;
    int8_t owner;
    uint8_t enter_count;
};

typedef struct 17recursive_mutex_t 17recursive_mutex_t, *P17recursive_mutex_t;

typedef struct 17recursive_mutex_t recursive_mutex_t.conflict;

struct 17recursive_mutex_t {
    lock_core_t core;
    int8_t owner;
    uint8_t enter_count;
};

typedef struct __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>, *P__pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>;

struct __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> { // Original name: __pair_base<std::_Rb_tree_iterator<std::pair<int const, int> >, bool>
};

typedef struct piecewise_construct_t piecewise_construct_t, *Ppiecewise_construct_t;

struct piecewise_construct_t {
};

typedef struct pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>, *Ppair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>;

struct pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> { // Original name: pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>
Missing member super___pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> : __pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> at offset 0x0 [conflicting member at same offset]
    struct _Rb_tree_node_base *first;
    struct _Rb_tree_node_base *second;
};

typedef struct __pair_base<const_pio_program*_const,_int> __pair_base<const_pio_program*_const,_int>, *P__pair_base<const_pio_program*_const,_int>;

struct __pair_base<const_pio_program*_const,_int> { // Original name: __pair_base<const pio_program* const, int>
};

typedef struct __pair_base<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool> __pair_base<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool>, *P__pair_base<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool>;

struct __pair_base<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool> { // Original name: __pair_base<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> >, bool>
};

typedef struct __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>, *P__pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>;

struct __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_> { // Original name: __pair_base<std::_Rb_tree_iterator<std::pair<int const, int> >, std::_Rb_tree_iterator<std::pair<int const, int> > >
};

typedef struct __pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> __pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>, *P__pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>;

struct __pair_base<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> { // Original name: __pair_base<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*>
};

typedef struct pair<const_pio_program*_const,_int> pair<const_pio_program*_const,_int>, *Ppair<const_pio_program*_const,_int>;

struct pair<const_pio_program*_const,_int> { // Original name: pair<const pio_program* const, int>
Missing member super___pair_base<const_pio_program*_const,_int> : __pair_base<const_pio_program*_const,_int> at offset 0x0 [conflicting member at same offset]
    struct pio_program *first;
    int second;
};

typedef struct __pair_base<int_const,_int> __pair_base<int_const,_int>, *P__pair_base<int_const,_int>;

struct __pair_base<int_const,_int> { // Original name: __pair_base<int const, int>
};

typedef struct pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>, *Ppair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>;

struct pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> { // Original name: pair<std::_Rb_tree_iterator<std::pair<int const, int> >, bool>
Missing member super___pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> : __pair_base<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool> at offset 0x0 [conflicting member at same offset]
    struct _Rb_tree_iterator<std::pair<int_const,_int>_> first;
    bool second;
};

typedef struct pio_program *first_type;


// WARNING! conflicting data type names: /DWARF/stl_pair.h/std/pair<int_const,_int>/first_type - /DWARF/stl_pair.h/std/pair<const_pio_program*_const,_int>/first_type


// WARNING! conflicting data type names: /stdio.h/FILE - /DWARF/stdio.h/FILE

typedef struct sockaddr sockaddr, *Psockaddr;

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef uint __socklen_t;

typedef __socklen_t socklen_t;


// WARNING! conflicting data type names: /types.h/ssize_t - /DWARF/stdio.h/ssize_t

typedef int __ssize_t;

typedef void (*__sighandler_t)(int);

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef enum Elf_ProgramHeaderType_RISCV {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType_RISCV;

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef enum Elf_SectionHeaderType_RISCV {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType_RISCV;

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_RISCV p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_RISCV sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};


// WARNING! conflicting data type names: /stdint.h/intptr_t - /DWARF/_stdint.h/intptr_t


// WARNING! conflicting data type names: /locale.h/lconv - /DWARF/locale.h/lconv



undefined LAB_00007dfc;
undefined *null;
undefined __global_pointer$;
undefined1 completed.1;
undefined DAT_10023600;
pointer PTR_write_10022628;
undefined u8x8_ascii_next;
undefined u8x8_utf8_next;
pointer PTR_write_10022610;
undefined u8x8_byte_arduino_hw_i2c;
undefined u8x8_gpio_and_delay_arduino;
uint64_t[80] sha512_k;
undefined DAT_10022108;
undefined DAT_00000001;
char[11] seedString;
uint8_t[3387] u8g2_font_t0_16b_mf;
uint8_t seed;
int[16] check_pins;
EEPROMClass EEPROM;
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2;
int[16] pins_order;
ulong totalSeconds;
char[6] timeString;
String pinStatesRow1;
String pinStatesRow2;
char[21] secret;
RP2040 rp2040;
int[16] prev_pin_states;
ulong previousMillis;
u8g2_cb_t u8g2_cb_r0;
TwoWire Wire;
SPISettings DEFAULT_SPI_SETTINGS;
uint8_t[1024] buf;
undefined u8x8_cad_ssd13xx_fast_i2c;
undefined u8g2_ll_hvline_vertical_top_lsb;
undefined u8x8_d_ssd1306_128x64_noname;
undefined u8g2_font_calc_vref_font;
uint8_t in_transfer;
uint8_t[5] u8x8_d_ssd1306_128x64_noname_powersave0_seq;
uint8_t[5] u8x8_d_ssd1306_128x64_noname_powersave1_seq;
uint8_t[7] u8x8_d_ssd1306_128x64_noname_flip0_seq;
uint8_t[7] u8x8_d_ssd1306_128x64_noname_flip1_seq;
u8x8_display_info_t u8x8_ssd1306_128x64_noname_display_info;
uint8_t[53] u8x8_d_ssd1306_128x64_noname_init_seq;
undefined u8x8_dummy_cb;
undefined DAT_1002355c;
absolute_time_t UNK_00000010;
uint64_t UNK_00000010;
undefined DAT_50002404;
undefined DAT_50003404;
i2c_inst_t i2c1_inst;
undefined DAT_1002350c;
pointer PTR_write_100234bc;
TwoWire Wire1;
undefined DAT_5000040c;
uint32_t _dma_i2c0_irq_mask;
TwoWire *_dma_i2c0_wire_instance;
uint32_t _dma_i2c1_irq_mask;
TwoWire *_dma_i2c1_wire_instance;
undefined _dma_i2c0_irq_handler;
undefined _dma_i2c1_irq_handler;
i2c_inst_t i2c0_inst;
undefined DAT_d0000180;
uint8_t _doorbell;
bool __otherCoreIdled;
undefined EXT_101fe000;
undefined DAT_d0000000;
pointer PTR_~SPIClassRP2040_10023580;
pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> UNK_00000010;
SPIClassRP2040 SPI;
SPIClassRP2040 SPI1;
UDItype UNK_00000018;
undefined DAT_d000018c;
undefined DAT_d0000188;
undefined _irq;
pio_program ccount_program;
bool core1_disable_systick;
SerialUSB Serial;
USBClass USB;
_reent *_impure_ptr1;
_reent *_impure_ptr;
String emptyString;
undefined DAT_d0000004;
undefined DAT_d0000008;
undefined DAT_d0000018;
undefined DAT_d0000020;
undefined DAT_d000001c;
undefined DAT_d0000024;
undefined DAT_d0000038;
undefined DAT_d0000040;
undefined DAT_d000003c;
undefined DAT_d0000044;
PinMode[30] _pm;
uint32_t[2] _irqStackTop;
uint32_t[2][15] _irqStack;
undefined DAT_50300000;
undefined DAT_50400000;
map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>[3] __pioMap;
bool[3] __pioAllocated;
mutex_t _pioMutex;
undefined DAT_10023670;
pointer PTR_write_1002363c;
undefined _cb;
uint64_t last_avail_time;
undefined DAT_40022000;
undefined DAT_40023000;
uint64_t UNK_00000018;
char[25] idString;
undefined simpleInterface;
int usb_hid_poll_interval;
uint16_t[32] desc_str;
undefined DAT_000003e8;
undefined usbIRQ;
uint64_t _adcGPIOInit;
uint8_t user_irq_claimed;
mutex_t _irqMutex;
__FILE[3] __sf;
lock_core_t sleep_notifier;
spin_lock_t[32] _sw_spin_locks;
alarm_pool_t default_alarm_pool;
undefined DAT_400b0024;
undefined DAT_400b0028;
uint8_t[2] claimed;
undefined DAT_400d8004;
uint32_t load_value;
undefined DAT_400db000;
undefined DAT_4001a008;
undefined DAT_400da000;
undefined DAT_400d801c;
undefined DAT_400d8020;
undefined DAT_400d8024;
undefined DAT_400d8028;
undefined DAT_00007dfa;
undefined DAT_400e0828;
undefined DAT_400e080c;
uint16_t _claimed;
undefined DAT_d0000050;
undefined DAT_d0000058;
undefined4 null;
undefined DAT_d0000054;
undefined core1_trampoline;
undefined core1_wrapper;
pico_unique_board_id_t retrieved_id;
uintptr_t __pre_init_runtime_init_bootrom_reset;
pointer __preinit_array_end;
uintptr_t __pre_init_first_per_core_initializer;
undefined DAT_40020008;
undefined DAT_5011004c;
undefined DAT_5011204c;
undefined DAT_40010084;
undefined DAT_4001303c;
undefined DAT_40010044;
undefined DAT_40013030;
undefined DAT_40010038;
undefined DAT_40050000;
undefined DAT_40058000;
uint8_t _app_driver_count;
usbd_class_driver_t[4] _usbd_driver;
usbd_class_driver_t *_app_driver;
usbd_device_t _usbd_dev;
uint8_t _usbd_rhport;
osal_mutex_def_t _ubsd_mutexdef;
uint8_t _usbd_queued_setup;
osal_mutex_t _usbd_mutex;
osal_queue_t _usbd_q;
osal_queue_def_t _usbd_qdef;
uint8_t uint8_t_20003eec;
usbd_control_xfer_t _ctrl_xfer;
cdcd_interface_t[1] _cdcd_itf;
cdcd_epbuf_t[1] _cdcd_epbuf;
tud_cdc_configure_fifo_t _cdcd_fifo_cfg;
hidd_interface_t[2] _hidd_itf;
hidd_epbuf_t[2] _hidd_epbuf;
anon_struct_128_2_23a6f806[1] _midid_epbuf;
midid_interface_t[1] _midid_itf;
mscd_interface_t _mscd_itf;
anon_struct_64_1_2f67eb89 _mscd_epbuf;
tusb_role_t.conflict[2] _tusb_rhport_role;
uint8_t striped_spin_lock_num;
uint32_t claimed;
undefined check_single_timeout_us;
undefined DAT_40048000;
undefined DAT_4004800c;
undefined DAT_4004a000;
undefined DAT_40048004;
uint8_t *next_buffer_ptr;
hw_endpoint[16][2] hw_endpoints;
undefined DAT_50110078;
undefined DAT_50110040;
undefined DAT_50110090;
undefined dcd_rp2040_irq;
undefined DAT_5011304c;
undefined DAT_50112090;
_Bool _sof_enable;
undefined DAT_50110000;
undefined DAT_50112068;
new_handler __new_handler;
undefined DAT_10022568;
DFtype UNK_00000010;
DFtype UNK_00000018;
undefined UNK_10022528;
undefined UNK_1002252c;
undefined UNK_10022530;
undefined UNK_10022534;
undefined UNK_10022560;
undefined UNK_1001991e;
__locale_t __global_locale;
_reent _impure_data;
undefined _fclose_r;
_glue __sglue;
undefined __sclose;
undefined __swrite;
undefined __sseek;
_func_void *__stdio_exit_handler;
undefined stdio_exit_handler;
undefined __sread;
recursive_mutex_t.conflict __lock___sfp_recursive_mutex;
undefined cleanup_stdio;
undefined __fp_lock;
undefined __fp_unlock;
char *__malloc_sbrk_base;
mbinptr[258] __malloc_av_;
ulong __malloc_max_total_mem;
ulong __malloc_top_pad;
mallinfo __malloc_current_mallinfo;
ulong __malloc_max_sbrked_mem;
double UNK_00000010;
undefined DAT_10022569;
ulong __malloc_trim_threshold;
recursive_mutex_t.conflict __lock___malloc_recursive_mutex;
int errno;
undefined _fflush_r;
double[25] __mprec_tens;
_atexit *__atexit;
_LOCK_T __atexit_recursive_mutex;
uint32_t[512] core1_stack;
undefined end;
char *heap_end;
undefined1 DAT_d0000000;
undefined DAT_400e0000;
_Bool boot2_copyout_valid;
uint32_t[64] boot2_copyout;
undefined DAT_400d0020;
undefined DAT_400d0028;
undefined DAT_400d0024;
undefined DAT_00007df8;
undefined DAT_400d002c;
undefined DAT_400d0030;
undefined DAT_50110058;
undefined DAT_50113058;
undefined DAT_50110098;
undefined DAT_50113090;
undefined DAT_50110048;
undefined DAT_50113050;
uint32_t e15_last_sof;
UDItype UNK_00000010;
UQItype[256] __clz_tab;
TFtype UNK_00000010;
undefined *__soft_vector_table;

void entry(void)

{
  gp = &__global_pointer_;
  (*(code *)&LAB_00007dfc)(&LAB_00007dfc);
  return;
}



void data_cpy(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  gp = &__global_pointer_;
  for (; param_2 < param_3; param_2 = param_2 + 1) {
    *param_2 = *param_1;
    param_1 = param_1 + 1;
  }
  return;
}



void reenter_bootrom(void)

{
  gp = &__global_pointer_;
  (*(code *)&LAB_00007dfc)(&LAB_00007dfc);
  return;
}



// WARNING: Removing unreachable block (ram,0x100030d6)
// WARNING: Removing unreachable block (ram,0x100030dc)

void deregister_tm_clones(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Removing unreachable block (ram,0x10003102)
// WARNING: Removing unreachable block (ram,0x10003108)

void register_tm_clones(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Removing unreachable block (ram,0x10003128)

void __do_global_dtors_aux(void)

{
  gp = &__global_pointer_;
  if (completed_1 == '\0') {
    deregister_tm_clones();
    completed_1 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x1000314c)

void frame_dummy(void)

{
  gp = &__global_pointer_;
  register_tm_clones();
  return;
}



// DWARF original prototype: String * operator+=(String * this, char c)

String * __thiscall arduino::String::operator+=(String *this,char c)

{
  char c_local;
  String *this_local;
  
  gp = &__global_pointer_;
  concat(this,c);
  return this;
}



// DWARF original prototype: void Print(Print * this)

void __thiscall arduino::Print::Print(Print *this)

{
  Print *this_local;
  
  gp = &__global_pointer_;
  this->_vptr_Print = (_func_int_varargs **)&DAT_10023600;
  this->write_error = 0;
  return;
}



// DWARF original prototype: int availableForWrite(Print * this)

int __thiscall arduino::Print::availableForWrite(Print *this)

{
  Print *this_local;
  
  gp = &__global_pointer_;
  return 0;
}



// DWARF original prototype: void flush(Print * this)

void __thiscall arduino::Print::flush(Print *this)

{
  Print *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: void reboot(RP2040 * this)

int __thiscall RP2040::reboot(RP2040 *this,int __howto)

{
  RP2040 *this_local;
  
  watchdog_reboot(0,0,10);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// DWARF original prototype: void restart(RP2040 * this)

void __thiscall RP2040::restart(RP2040 *this)

{
  int in_a1;
  RP2040 *this_local;
  
  gp = &__global_pointer_;
  reboot(this,in_a1);
  return;
}



// DWARF original prototype: void U8G2(U8G2 * this)

void __thiscall U8G2::U8G2(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  arduino::Print::Print(&this->super_Print);
  (this->super_Print)._vptr_Print = (_func_int_varargs **)&PTR_write_10022628;
  this->cpp_next_cb = u8x8_ascii_next;
  home(this);
  return;
}



// DWARF original prototype: u8x8_t * getU8x8(U8G2 * this)

u8x8_t * __thiscall U8G2::getU8x8(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  return &(this->u8g2).u8x8;
}



// DWARF original prototype: void enableUTF8Print(U8G2 * this)

void __thiscall U8G2::enableUTF8Print(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  this->cpp_next_cb = u8x8_utf8_next;
  return;
}



// DWARF original prototype: void initDisplay(U8G2 * this)

void __thiscall U8G2::initDisplay(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8x8_InitDisplay(&(this->u8g2).u8x8);
  return;
}



// DWARF original prototype: void clearDisplay(U8G2 * this)

void __thiscall U8G2::clearDisplay(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8g2_ClearDisplay(&this->u8g2);
  return;
}



// DWARF original prototype: void setPowerSave(U8G2 * this, uint8_t is_enable)

void __thiscall U8G2::setPowerSave(U8G2 *this,uint8_t is_enable)

{
  uint8_t is_enable_local;
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8x8_SetPowerSave(&(this->u8g2).u8x8,is_enable);
  return;
}



// DWARF original prototype: bool begin(U8G2 * this)

bool __thiscall U8G2::begin(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  initDisplay(this);
  clearDisplay(this);
  setPowerSave(this,'\0');
  return true;
}



// DWARF original prototype: void sendBuffer(U8G2 * this)

void __thiscall U8G2::sendBuffer(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8g2_SendBuffer(&this->u8g2);
  return;
}



// DWARF original prototype: void clearBuffer(U8G2 * this)

void __thiscall U8G2::clearBuffer(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8g2_ClearBuffer(&this->u8g2);
  return;
}



// DWARF original prototype: void setFont(U8G2 * this, uint8_t * font)

void __thiscall U8G2::setFont(U8G2 *this,uint8_t *font)

{
  uint8_t *font_local;
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  u8g2_SetFont(&this->u8g2,font);
  return;
}



// DWARF original prototype: u8g2_uint_t drawUTF8(U8G2 * this, u8g2_uint_t x, u8g2_uint_t y, char *
// s)

u8g2_uint_t __thiscall U8G2::drawUTF8(U8G2 *this,u8g2_uint_t x,u8g2_uint_t y,char *s)

{
  u8g2_uint_t uVar1;
  char *s_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  uVar1 = u8g2_DrawUTF8(&this->u8g2,x,y,s);
  return uVar1;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: size_t write(U8G2 * this, uint8_t v)

ssize_t __thiscall U8G2::write(U8G2 *this,int __fd,void *__buf,size_t __n)

{
  byte bVar1;
  uint16_t encoding;
  uint8_t v_local;
  U8G2 *this_local;
  u8g2_uint_t delta;
  uint16_t e;
  
  gp = &__global_pointer_;
  encoding = (*this->cpp_next_cb)(&(this->u8g2).u8x8,(uint8_t)__fd);
  if (encoding < 0xfffe) {
    u8g2_DrawGlyph(&this->u8g2,this->tx,this->ty,encoding);
    bVar1 = (this->u8g2).font_decode.dir;
    if (bVar1 == 3) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if (bVar1 < 4) {
      if (bVar1 == 2) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
      if (bVar1 < 3) {
        if (bVar1 == 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
          halt_unimplemented();
        }
        if (bVar1 == 1) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
          halt_unimplemented();
        }
      }
    }
  }
  return 1;
}



// DWARF original prototype: size_t write(U8G2 * this, uint8_t * buffer, size_t size)

ssize_t __thiscall U8G2::write(U8G2 *this,int __fd,void *__buf,size_t __n)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  void *local_2c;
  size_t size_local;
  uint8_t *buffer_local;
  U8G2 *this_local;
  int local_14;
  size_t cnt;
  
  gp = &__global_pointer_;
  local_14 = 0;
  size_local = __fd;
  for (local_2c = __buf; local_2c != (void *)0x0; local_2c = (void *)((int)local_2c + -1)) {
    p_Var2 = *(this->super_Print)._vptr_Print;
    iVar1 = (*p_Var2)((uint)*(byte *)size_local,p_Var2);
    local_14 = local_14 + iVar1;
    size_local = size_local + 1;
  }
  return local_14;
}



// DWARF original prototype: void home(U8G2 * this)

void __thiscall U8G2::home(U8G2 *this)

{
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  this->tx = 0;
  this->ty = 0;
  u8x8_utf8_init(&(this->u8g2).u8x8);
  return;
}



// DWARF original prototype: void setCursor(U8G2 * this, u8g2_uint_t x, u8g2_uint_t y)

void __thiscall U8G2::setCursor(U8G2 *this,u8g2_uint_t x,u8g2_uint_t y)

{
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  U8G2 *this_local;
  
  gp = &__global_pointer_;
  this->tx = x;
  this->ty = y;
  return;
}



// DWARF original prototype: void
// U8G2_SSD1306_128X64_NONAME_F_HW_I2C(U8G2_SSD1306_128X64_NONAME_F_HW_I2C * this, u8g2_cb_t *
// rotation, uint8_t reset, uint8_t clock, uint8_t data)

void __thiscall
U8G2_SSD1306_128X64_NONAME_F_HW_I2C::U8G2_SSD1306_128X64_NONAME_F_HW_I2C
          (U8G2_SSD1306_128X64_NONAME_F_HW_I2C *this,u8g2_cb_t *rotation,uint8_t reset,uint8_t clock
          ,uint8_t data)

{
  u8x8_t *u8x8;
  uint8_t data_local;
  uint8_t clock_local;
  uint8_t reset_local;
  u8g2_cb_t *rotation_local;
  U8G2_SSD1306_128X64_NONAME_F_HW_I2C *this_local;
  
  gp = &__global_pointer_;
  U8G2::U8G2(&this->super_U8G2);
  (this->super_U8G2).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_10022610;
  u8g2_Setup_ssd1306_i2c_128x64_noname_f
            (&(this->super_U8G2).u8g2,rotation,u8x8_byte_arduino_hw_i2c,u8x8_gpio_and_delay_arduino)
  ;
  u8x8 = U8G2::getU8x8(&this->super_U8G2);
  u8x8_SetPin_HW_I2C(u8x8,reset,clock,data);
  return;
}



// WARNING: Variable defined which should be unmapped: a

void sha512_transform(uint64_t *state,uint8_t *data)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  uint64_t uVar5;
  uint64_t uVar6;
  uint64_t uVar7;
  uint64_t uVar8;
  uint64_t uVar9;
  uint64_t uVar10;
  uint64_t uVar11;
  uint64_t uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint8_t *data_local;
  uint64_t *state_local;
  uint uStack_308;
  uint64_t m [80];
  uint64_t t2;
  uint64_t t1;
  size_t j;
  size_t i;
  uint64_t h;
  uint64_t g;
  uint64_t f;
  uint64_t e;
  uint64_t d;
  uint64_t c;
  uint64_t b;
  uint64_t a;
  
  gp = &__global_pointer_;
  t1._4_4_ = 0;
  for (j = 0; j < 0x10; j = j + 1) {
    bVar1 = data[t1._4_4_];
    bVar2 = data[t1._4_4_ + 1];
    bVar3 = data[t1._4_4_ + 2];
    bVar4 = data[t1._4_4_ + 3];
    *(uint *)((int)m + j * 8 + -4) =
         (uint)data[t1._4_4_ + 4] << 0x18 | (uint)data[t1._4_4_ + 5] << 0x10 |
         (uint)data[t1._4_4_ + 6] << 8 | (uint)data[t1._4_4_ + 7];
    *(uint *)(m + j) = (uint)bVar1 << 0x18 | (uint)bVar2 << 0x10 | (uint)bVar3 << 8 | (uint)bVar4;
    t1._4_4_ = t1._4_4_ + 8;
  }
  for (; j < 0x50; j = j + 1) {
    uVar14 = *(uint *)((int)m + (j - 2) * 8 + -4);
    uVar12 = m[j - 2];
    uVar16 = *(uint *)((int)m + (j - 2) * 8 + -4);
    uVar5 = m[j - 2];
    uVar6 = m[j - 2];
    uVar19 = (uVar14 >> 0x13 | (uint)uVar12 << 0xd) ^ (uVar16 << 3 | (uint)uVar5 >> 0x1d) ^
             ((uint)uVar6 << 0x1a | *(uint *)((int)m + (j - 2) * 8 + -4) >> 6);
    uVar7 = m[j - 7];
    uVar15 = uVar19 + *(int *)((int)m + (j - 7) * 8 + -4);
    uVar21 = *(uint *)((int)m + (j - 0xf) * 8 + -4);
    uVar8 = m[j - 0xf];
    uVar18 = *(uint *)((int)m + (j - 0xf) * 8 + -4);
    uVar9 = m[j - 0xf];
    uVar10 = m[j - 0xf];
    uVar13 = uVar15 + ((uVar21 >> 1 | (uint)uVar8 << 0x1f) ^ (uVar18 >> 8 | (uint)uVar9 << 0x18) ^
                      ((uint)uVar10 << 0x19 | *(uint *)((int)m + (j - 0xf) * 8 + -4) >> 7));
    uVar11 = m[j - 0x10];
    uVar20 = uVar13 + *(int *)((int)m + (j - 0x10) * 8 + -4);
    *(uint *)((int)m + j * 8 + -4) = uVar20;
    *(uint *)(m + j) =
         (uint)(uVar20 < uVar13) +
         (uint)(uVar13 < uVar15) +
         (uint)(uVar15 < uVar19) +
         (((uint)uVar12 >> 0x13 | uVar14 << 0xd) ^ ((uint)uVar5 << 3 | uVar16 >> 0x1d) ^
         (uint)uVar6 >> 6) + (int)uVar7 +
         (((uint)uVar8 >> 1 | uVar21 << 0x1f) ^ ((uint)uVar9 >> 8 | uVar18 << 0x18) ^
         (uint)uVar10 >> 7) + (int)uVar11;
  }
  b._4_4_ = (uint)*state;
  a._0_4_ = *(uint *)((int)state + 4);
  c._4_4_ = (uint)state[1];
  b._0_4_ = *(uint *)((int)state + 0xc);
  d._4_4_ = (uint)state[2];
  c._0_4_ = *(uint *)((int)state + 0x14);
  e._4_4_ = (uint)state[3];
  d._0_4_ = *(uint *)((int)state + 0x1c);
  f._4_4_ = (uint)state[4];
  e._0_4_ = *(uint *)((int)state + 0x24);
  g._4_4_ = (uint)state[5];
  f._0_4_ = *(uint *)((int)state + 0x2c);
  h._4_4_ = (uint)state[6];
  g._0_4_ = *(uint *)((int)state + 0x34);
  i = (size_t)state[7];
  h._0_4_ = *(uint *)((int)state + 0x3c);
  for (j = 0; j < 0x50; j = j + 1) {
    uVar16 = (f._4_4_ >> 0xe | (uint)e << 0x12) ^ (f._4_4_ >> 0x12 | (uint)e << 0xe) ^
             (f._4_4_ << 0x17 | (uint)e >> 9);
    uVar15 = uVar16 + i;
    uVar14 = uVar15 + (g._4_4_ & f._4_4_ ^ h._4_4_ & ~f._4_4_);
    uVar21 = uVar14 + (int)sha512_k[j];
    uVar13 = uVar21 + *(int *)((int)m + j * 8 + -4);
    iVar17 = (uint)(uVar13 < uVar21) +
             (uint)(uVar21 < uVar14) +
             (uint)(uVar14 < uVar15) +
             (uint)(uVar15 < uVar16) +
             (((uint)e >> 0xe | f._4_4_ << 0x12) ^ ((uint)e >> 0x12 | f._4_4_ << 0xe) ^
             ((uint)e << 0x17 | f._4_4_ >> 9)) + (uint)h + ((uint)f & (uint)e ^ (uint)g & ~(uint)e)
             + *(int *)((int)sha512_k + j * 8 + 4) + (int)m[j];
    uVar15 = b._4_4_ << 4;
    uVar14 = b._4_4_ >> 2;
    uVar16 = b._4_4_ >> 7;
    uVar21 = (b._4_4_ >> 0x1c | (uint)a << 4) ^ (b._4_4_ << 0x1e | (uint)a >> 2) ^
             (b._4_4_ << 0x19 | (uint)a >> 7);
    uVar18 = (uint)c ^ (uint)b;
    uVar19 = (uint)c & (uint)b;
    m[0x4f]._4_4_ = uVar21 + (b._4_4_ & (d._4_4_ ^ c._4_4_) ^ d._4_4_ & c._4_4_);
    i = h._4_4_;
    h._0_4_ = (uint)g;
    h._4_4_ = g._4_4_;
    g._0_4_ = (uint)f;
    g._4_4_ = f._4_4_;
    f._0_4_ = (uint)e;
    f._4_4_ = e._4_4_ + uVar13;
    e._0_4_ = (uint)(f._4_4_ < e._4_4_) + (uint)d + iVar17;
    e._4_4_ = d._4_4_;
    d._0_4_ = (uint)c;
    d._4_4_ = c._4_4_;
    c._0_4_ = (uint)b;
    c._4_4_ = b._4_4_;
    b._0_4_ = (uint)a;
    b._4_4_ = uVar13 + m[0x4f]._4_4_;
    a._0_4_ = (uint)(b._4_4_ < uVar13) +
              iVar17 + (uint)(m[0x4f]._4_4_ < uVar21) +
                       (((uint)a >> 0x1c | uVar15) ^ ((uint)a << 0x1e | uVar14) ^
                       ((uint)a << 0x19 | uVar16)) + ((uint)a & uVar18 ^ uVar19);
  }
  uVar12 = *state;
  uVar15 = (uint)uVar12 + b._4_4_;
  *(uint *)state = uVar15;
  *(uint *)((int)state + 4) = (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 4) + (uint)a;
  uVar12 = state[1];
  uVar15 = (uint)uVar12 + c._4_4_;
  *(uint *)(state + 1) = uVar15;
  *(uint *)((int)state + 0xc) = (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0xc) + (uint)b
  ;
  uVar12 = state[2];
  uVar15 = (uint)uVar12 + d._4_4_;
  *(uint *)(state + 2) = uVar15;
  *(uint *)((int)state + 0x14) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x14) + (uint)c;
  uVar12 = state[3];
  uVar15 = (uint)uVar12 + e._4_4_;
  *(uint *)(state + 3) = uVar15;
  *(uint *)((int)state + 0x1c) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x1c) + (uint)d;
  uVar12 = state[4];
  uVar15 = (uint)uVar12 + f._4_4_;
  *(uint *)(state + 4) = uVar15;
  *(uint *)((int)state + 0x24) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x24) + (uint)e;
  uVar12 = state[5];
  uVar15 = (uint)uVar12 + g._4_4_;
  *(uint *)(state + 5) = uVar15;
  *(uint *)((int)state + 0x2c) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x2c) + (uint)f;
  uVar12 = state[6];
  uVar15 = (uint)uVar12 + h._4_4_;
  *(uint *)(state + 6) = uVar15;
  *(uint *)((int)state + 0x34) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x34) + (uint)g;
  uVar12 = state[7];
  uVar15 = (uint)uVar12 + i;
  *(uint *)(state + 7) = uVar15;
  *(uint *)((int)state + 0x3c) =
       (uint)(uVar15 < (uint)uVar12) + *(int *)((int)state + 0x3c) + (uint)h;
  return;
}



// WARNING: Variable defined which should be unmapped: block_offset

void sha512(uint8_t *data,size_t length,uint8_t *hash)

{
  uint8_t local_160;
  uint8_t local_158;
  uint8_t local_150;
  uint8_t local_148;
  byte local_140;
  uint8_t local_120;
  uint8_t local_118;
  uint8_t *hash_local;
  size_t length_local;
  uint8_t *data_local;
  uint8_t msg_block [128];
  uint64_t state [8];
  uint64_t bit_len;
  size_t i;
  size_t block_offset;
  
  gp = &__global_pointer_;
  memcpy(msg_block + 0x7c,&DAT_10022108,0x40);
  i = 0;
  state[7]._4_4_ = length << 3;
  for (hash_local = (uint8_t *)length; (uint8_t *)0x7f < hash_local; hash_local = hash_local + -0x80
      ) {
    for (bit_len._4_4_ = (uint8_t *)0x0; bit_len._4_4_ < 0x80;
        bit_len._4_4_ = (uint8_t *)((int)bit_len._4_4_ + 1)) {
      msg_block[(int)bit_len._4_4_ - 4] = data[i + (int)bit_len._4_4_];
    }
    sha512_transform((uint64_t *)(msg_block + 0x7c),(uint8_t *)&data_local);
    i = i + 0x80;
  }
  for (bit_len._4_4_ = (uint8_t *)0x0; bit_len._4_4_ < hash_local; bit_len._4_4_ = bit_len._4_4_ + 1
      ) {
    *(uint8_t *)((int)&data_local + (int)bit_len._4_4_) = data[(int)(bit_len._4_4_ + i)];
  }
  *(uint8_t *)((int)&data_local + (int)hash_local) = 0x80;
  bit_len._4_4_ = hash_local;
  while (bit_len._4_4_ = bit_len._4_4_ + 1, bit_len._4_4_ < (uint8_t *)0x80) {
    *(uint8_t *)((int)&data_local + (int)bit_len._4_4_) = '\0';
  }
  if ((uint8_t *)0x6f < hash_local) {
    sha512_transform((uint64_t *)(msg_block + 0x7c),(uint8_t *)&data_local);
    for (bit_len._4_4_ = (uint8_t *)0x0; bit_len._4_4_ < 0x80;
        bit_len._4_4_ = (uint8_t *)((int)bit_len._4_4_ + 1)) {
      msg_block[(int)bit_len._4_4_ - 4] = '\0';
    }
  }
  for (bit_len._4_4_ = (uint8_t *)0x70; bit_len._4_4_ < 0x78;
      bit_len._4_4_ = (uint8_t *)((int)bit_len._4_4_ + 1)) {
    msg_block[(int)bit_len._4_4_ - 4] = '\0';
  }
  msg_block[0x74] = '\0';
  msg_block[0x75] = '\0';
  msg_block[0x76] = '\0';
  local_140 = (byte)(length >> 0x1d);
  msg_block[0x77] = local_140;
  local_118 = (uint8_t)((uint)state[7]._4_4_ >> 0x18);
  msg_block[0x78] = local_118;
  local_120 = (uint8_t)((uint)state[7]._4_4_ >> 0x10);
  msg_block[0x79] = local_120;
  msg_block[0x7a] = (uint8_t)((uint)state[7]._4_4_ >> 8);
  msg_block[0x7b] = state[7]._4_1_;
  sha512_transform((uint64_t *)(msg_block + 0x7c),(uint8_t *)&data_local);
  for (bit_len._4_4_ = (uint8_t *)0x0; bit_len._4_4_ < 8;
      bit_len._4_4_ = (uint8_t *)((int)bit_len._4_4_ + 1)) {
    local_148 = (uint8_t)((uint)(int)state[(int)bit_len._4_4_] >> 0x18);
    hash[(int)bit_len._4_4_ * 8] = local_148;
    local_150 = (uint8_t)((uint)(int)state[(int)bit_len._4_4_] >> 0x10);
    hash[(int)bit_len._4_4_ * 8 + 1] = local_150;
    local_158 = (uint8_t)((uint)(int)state[(int)bit_len._4_4_] >> 8);
    hash[(int)bit_len._4_4_ * 8 + 2] = local_158;
    local_160 = (uint8_t)(int)state[(int)bit_len._4_4_];
    hash[(int)bit_len._4_4_ * 8 + 3] = local_160;
    hash[(int)bit_len._4_4_ * 8 + 4] =
         (uint8_t)((uint)*(undefined4 *)((int)state + (int)bit_len._4_4_ * 8 + -4) >> 0x18);
    hash[(int)bit_len._4_4_ * 8 + 5] =
         (uint8_t)((uint)*(undefined4 *)((int)state + (int)bit_len._4_4_ * 8 + -4) >> 0x10);
    hash[(int)bit_len._4_4_ * 8 + 6] =
         (uint8_t)((uint)*(undefined4 *)((int)state + (int)bit_len._4_4_ * 8 + -4) >> 8);
    hash[(int)bit_len._4_4_ * 8 + 7] =
         (uint8_t)*(undefined4 *)((int)state + (int)bit_len._4_4_ * 8 + -4);
  }
  return;
}



void calculate_pins_order(char *seedString,int *pins_order)

{
  int iVar1;
  int iVar2;
  int *pins_order_local;
  char *seedString_local;
  int iStack_13c;
  int ranks [16];
  anon_struct_8_2_97b3200e pairs [16];
  uint8_t hash [64];
  int pin_idx;
  int temp_idx;
  int temp_val;
  int i_5;
  int i_4;
  int j_1;
  int i_3;
  int i_2;
  int j;
  int i_1;
  int i;
  
  gp = &__global_pointer_;
  sha512((uint8_t *)seedString,10,(uint8_t *)&pairs[0xf].original_index);
  sha512((uint8_t *)&pairs[0xf].original_index,0x40,(uint8_t *)&pairs[0xf].original_index);
  for (i_1 = 0; i_1 < 0x10; i_1 = i_1 + 1) {
    pins_order[i_1] = 0;
  }
  for (j = 0; j < 0x40; j = j + 1) {
    for (i_2 = 0; i_2 < 8; i_2 = i_2 + 1) {
      if (((int)(uint)*(byte *)((int)&pairs[0xf].original_index + j) >> (i_2 & 0x1fU) & 1U) != 0) {
        pins_order[(j * 8 + i_2) % 0x10] = pins_order[(j * 8 + i_2) % 0x10] + 1;
      }
    }
  }
  for (i_3 = 0; i_3 < 0x10; i_3 = i_3 + 1) {
    pairs[i_3 + -1].original_index = pins_order[i_3];
    pairs[i_3].value = i_3;
  }
  for (j_1 = 0; j_1 < 0xf; j_1 = j_1 + 1) {
    for (i_4 = 0; i_4 < 0xf - j_1; i_4 = i_4 + 1) {
      if ((pairs[i_4].original_index < pairs[i_4 + -1].original_index) ||
         ((pairs[i_4 + -1].original_index == pairs[i_4].original_index &&
          (pairs[i_4 + 1].value < pairs[i_4].value)))) {
        iVar1 = pairs[i_4 + -1].original_index;
        iVar2 = pairs[i_4].value;
        pairs[i_4 + -1].original_index = pairs[i_4].original_index;
        pairs[i_4].value = pairs[i_4 + 1].value;
        pairs[i_4].original_index = iVar1;
        pairs[i_4 + 1].value = iVar2;
      }
    }
  }
  for (i_5 = 0; i_5 < 0x10; i_5 = i_5 + 1) {
    ranks[pairs[i_5].value + -1] = i_5 + 1;
  }
  for (temp_val = 0; temp_val < 0x10; temp_val = temp_val + 1) {
    pins_order[temp_val] = ranks[temp_val + -1];
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10004cf4)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void setup(void)

{
  ssize_t sVar1;
  uint uVar2;
  void *in_a2;
  undefined1 *__buf;
  size_t in_a3;
  undefined1 auStack_40 [4];
  char encryptedSecret [21];
  uint8_t bootedFlag;
  uint8_t detonatedFlag;
  int i_4;
  int i_3;
  int i_2;
  int state;
  int i_1;
  int i;
  
  gp = &__global_pointer_;
  U8G2::begin(&u8g2.super_U8G2);
  U8G2::enableUTF8Print(&u8g2.super_U8G2);
  U8G2::setFont(&u8g2.super_U8G2,u8g2_font_t0_16b_mf);
  EEPROMClass::begin(&EEPROM,0x100);
  sVar1 = EEPROMClass::read(&EEPROM,0,in_a2,in_a3);
  encryptedSecret[0x13] = (char)sVar1;
  sVar1 = EEPROMClass::read(&EEPROM,1,in_a2,in_a3);
  encryptedSecret[0x12] = (char)sVar1;
  if ((encryptedSecret[0x13] == '\0') && (encryptedSecret[0x12] == '\0')) {
    encryptedSecret[0x12] = '\0';
    for (i_1 = 0; i_1 < 0x10; i_1 = i_1 + 1) {
      __pinMode((pin_size_t)check_pins[i_1],INPUT);
    }
    for (state = 0; state < 0x10; state = state + 1) {
      i_2 = __digitalRead((pin_size_t)check_pins[state]);
      if (i_2 == HIGH) {
        U8G2::clearBuffer(&u8g2.super_U8G2);
        U8G2::setCursor(&u8g2.super_U8G2,10,0x1e);
        arduino::Print::print((Print *)&u8g2,"Pin ");
        arduino::Print::print((Print *)&u8g2,state,10);
        arduino::Print::print((Print *)&u8g2," discon");
        U8G2::sendBuffer(&u8g2.super_U8G2);
      }
      while (i_2 == 1) {
        i_2 = __digitalRead((pin_size_t)check_pins[state]);
      }
    }
    U8G2::clearBuffer(&u8g2.super_U8G2);
    U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x28);
    arduino::Print::print((Print *)&u8g2,"Booting...");
    U8G2::sendBuffer(&u8g2.super_U8G2);
    delay(5000);
    __buf = &DAT_00000001;
    EEPROMClass::write(&EEPROM,1,&DAT_00000001,in_a3);
    EEPROMClass::commit(&EEPROM);
    for (i_3 = 0; i_3 < 5; i_3 = i_3 + 1) {
      uVar2 = EEPROMClass::read(&EEPROM,i_3 + 2,__buf,in_a3);
      seed = (uint8_t)uVar2;
      __buf = (undefined1 *)(uVar2 & 0xff);
      sprintf(seedString + i_3 * 2,"%02x");
    }
    calculate_pins_order(seedString,pins_order);
    for (i_4 = 0; (uint)i_4 < 0x15; i_4 = i_4 + 1) {
      sVar1 = EEPROMClass::read(&EEPROM,i_4 + 8,__buf,in_a3);
      auStack_40[i_4] = (char)sVar1;
      __buf = (undefined1 *)0x0;
      EEPROMClass::write(&EEPROM,i_4 + 8,(void *)0x0,in_a3);
    }
    EEPROMClass::commit(&EEPROM);
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  U8G2::clearBuffer(&u8g2.super_U8G2);
  U8G2::setCursor(&u8g2.super_U8G2,5,10);
  arduino::Print::print((Print *)&u8g2,"Your bomb is");
  U8G2::setCursor(&u8g2.super_U8G2,5,0x19);
  arduino::Print::print((Print *)&u8g2,"already");
  U8G2::setCursor(&u8g2.super_U8G2,5,0x28);
  arduino::Print::print((Print *)&u8g2,"detonated!");
  U8G2::setCursor(&u8g2.super_U8G2,5,0x3c);
  arduino::Print::print((Print *)&u8g2,"System locked!");
  U8G2::sendBuffer(&u8g2.super_U8G2);
  delay(2000);
  do {
    delay(1000);
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void updateTimeString(void)

{
  int seconds;
  int minutes;
  
  gp = &__global_pointer_;
  sprintf(timeString,"%02d:%02d",totalSeconds / 0x3c,totalSeconds % 0x3c);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void updatePinState(void)

{
  PinStatus PVar1;
  char c;
  char stateChar;
  int state;
  int i;
  
  gp = &__global_pointer_;
  arduino::String::operator=(&pinStatesRow1,"");
  arduino::String::operator=(&pinStatesRow2,"");
  for (state = 0; state < 0x10; state = state + 1) {
    PVar1 = __digitalRead((pin_size_t)check_pins[state]);
    if (PVar1 == HIGH) {
      c = 'x';
    }
    else {
      c = 'o';
    }
    if (state < 8) {
      arduino::String::operator+=(&pinStatesRow1,c);
    }
    else {
      arduino::String::operator+=(&pinStatesRow2,c);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void detonate(void)

{
  size_t in_a3;
  
  gp = &__global_pointer_;
  EEPROMClass::write(&EEPROM,0,&DAT_00000001,in_a3);
  EEPROMClass::commit(&EEPROM);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void win(void)

{
  uint local_18;
  int i_1;
  int i;
  
  U8G2::clearBuffer(&u8g2.super_U8G2);
  U8G2::setCursor(&u8g2.super_U8G2,0x23,0xf);
  arduino::Print::print((Print *)&u8g2,"You win!");
  U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x23);
  for (i_1 = 0; (uint)i_1 < 10; i_1 = i_1 + 1) {
    arduino::Print::print((Print *)&u8g2,secret[i_1]);
  }
  U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x32);
  for (local_18 = 10; local_18 < 0x14; local_18 = local_18 + 1) {
    arduino::Print::print((Print *)&u8g2,secret[local_18]);
  }
  U8G2::sendBuffer(&u8g2.super_U8G2);
  do {
    delay(1000);
  } while( true );
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void check_disconn(void)

{
  bool bVar1;
  bool bVar2;
  PinStatus PVar3;
  int current_state;
  int i_2;
  int iStack_1c;
  bool winFlag;
  int i_1;
  int i;
  bool should_decrement;
  bool found_disconnected;
  
  gp = &__global_pointer_;
  bVar1 = false;
  bVar2 = true;
  for (i_1 = 0; i_1 < 0x10; i_1 = i_1 + 1) {
    PVar3 = __digitalRead((pin_size_t)check_pins[i_1]);
    if (((check_disconn::prev_pin_states[i_1] == 0) && (PVar3 == HIGH)) &&
       (bVar1 = true, pins_order[i_1] != 1)) {
      bVar2 = false;
    }
    check_disconn::prev_pin_states[i_1] = PVar3;
  }
  if (bVar1) {
    if (bVar2) {
      for (iStack_1c = 0; iStack_1c < 0x10; iStack_1c = iStack_1c + 1) {
        if (0 < pins_order[iStack_1c]) {
          pins_order[iStack_1c] = pins_order[iStack_1c] + -1;
        }
      }
      bVar1 = true;
      for (current_state = 0; current_state < 0x10; current_state = current_state + 1) {
        if (pins_order[current_state] != 0) {
          bVar1 = false;
        }
      }
      if (bVar1) {
        win();
      }
    }
    else {
      detonate();
      U8G2::clearBuffer(&u8g2.super_U8G2);
      U8G2::setCursor(&u8g2.super_U8G2,0x19,0x1e);
      arduino::Print::print((Print *)&u8g2,"Wrong Wire!");
      U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x32);
      arduino::Print::print((Print *)&u8g2,"Kaboomed!");
      U8G2::sendBuffer(&u8g2.super_U8G2);
      delay(2000);
      U8G2::clearBuffer(&u8g2.super_U8G2);
      U8G2::setCursor(&u8g2.super_U8G2,0xf,0x28);
      arduino::Print::print((Print *)&u8g2,"Resetting...");
      U8G2::sendBuffer(&u8g2.super_U8G2);
      delay(2000);
      RP2040::restart(&rp2040);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void loop(void)

{
  uint32_t uVar1;
  ulong currentMillis;
  
  gp = &__global_pointer_;
  uVar1 = millis();
  if (999 < uVar1 - previousMillis) {
    previousMillis = uVar1;
    if (totalSeconds == 0) {
      detonate();
      U8G2::clearBuffer(&u8g2.super_U8G2);
      U8G2::setCursor(&u8g2.super_U8G2,0x19,0x1e);
      arduino::Print::print((Print *)&u8g2,"Time\'s up!");
      U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x32);
      arduino::Print::print((Print *)&u8g2,"Kaboomed!");
      U8G2::sendBuffer(&u8g2.super_U8G2);
      delay(2000);
      U8G2::clearBuffer(&u8g2.super_U8G2);
      U8G2::setCursor(&u8g2.super_U8G2,0xf,0x28);
      arduino::Print::print((Print *)&u8g2,"Resetting...");
      U8G2::sendBuffer(&u8g2.super_U8G2);
      delay(2000);
      RP2040::restart(&rp2040);
    }
    else {
      check_disconn();
      totalSeconds = totalSeconds - 1;
      updateTimeString();
      U8G2::clearBuffer(&u8g2.super_U8G2);
      U8G2::drawUTF8(&u8g2.super_U8G2,1,0xf,"Time Left:");
      U8G2::setCursor(&u8g2.super_U8G2,0x55,0xf);
      arduino::Print::print((Print *)&u8g2,timeString);
      U8G2::drawUTF8(&u8g2.super_U8G2,1,0x1e,"S/N:");
      U8G2::setCursor(&u8g2.super_U8G2,0x28,0x1e);
      arduino::Print::print((Print *)&u8g2,seedString);
      updatePinState();
      U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x2d);
      arduino::Print::print((Print *)&u8g2,&pinStatesRow1);
      U8G2::setCursor(&u8g2.super_U8G2,0x1e,0x3c);
      arduino::Print::print((Print *)&u8g2,&pinStatesRow2);
      U8G2::sendBuffer(&u8g2.super_U8G2);
    }
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  U8G2_SSD1306_128X64_NONAME_F_HW_I2C::U8G2_SSD1306_128X64_NONAME_F_HW_I2C
            (&u8g2,&u8g2_cb_r0,0xff,'\x05','\x04');
  arduino::String::String(&pinStatesRow1,"");
  arduino::String::String(&pinStatesRow2,"");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I_u8g2(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



void arduino::digitalWrite(pin_size_t pinNumber,int status)

{
  int status_local;
  pin_size_t pinNumber_local;
  
  gp = &__global_pointer_;
  __digitalWrite(pinNumber,status);
  return;
}



// DWARF original prototype: void SPISettings(SPISettings * this)

void __thiscall arduino::SPISettings::SPISettings(SPISettings *this)

{
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  this->clockFreq = 4000000;
  this->dataMode = SPI_MODE0;
  this->bitOrder = MSBFIRST;
  return;
}



// DWARF original prototype: void init_MightInline(SPISettings * this, uint32_t clock, BitOrder
// bitOrder, SPIMode dataMode)

void __thiscall
arduino::SPISettings::init_MightInline
          (SPISettings *this,uint32_t clock,BitOrder bitOrder,SPIMode dataMode)

{
  SPIMode dataMode_local;
  BitOrder bitOrder_local;
  uint32_t clock_local;
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  this->clockFreq = clock;
  this->dataMode = dataMode;
  this->bitOrder = bitOrder;
  return;
}



// DWARF original prototype: void begin(SPIClassRP2040 * this)

void __thiscall SPIClassRP2040::begin(SPIClassRP2040 *this)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  begin(this,false);
  return;
}



uint8_t u8x8_gpio_and_delay_arduino(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  pin_size_t ulPin;
  PinStatus PVar1;
  uint usec;
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  byte local_11;
  uint8_t i;
  
  gp = &__global_pointer_;
  switch(msg) {
  case '(':
    for (local_11 = 0; local_11 < 0x16; local_11 = local_11 + 1) {
      if (u8x8->pins[local_11] != 0xff) {
        if (local_11 < 0x10) {
          __pinMode(u8x8->pins[local_11],OUTPUT);
        }
        else {
          __pinMode(u8x8->pins[local_11],OUTPUT);
          arduino::digitalWrite(u8x8->pins[local_11],1);
        }
      }
    }
    break;
  case ')':
    delay((uint)arg_int);
    break;
  case '*':
  case '+':
    break;
  case ',':
    delayMicroseconds((uint)(arg_int != '\0'));
    break;
  case '-':
    if (arg_int < 3) {
      usec = 5;
    }
    else {
      usec = 2;
    }
    delayMicroseconds(usec);
    break;
  default:
    if (msg < 0x40) {
      return '\0';
    }
    ulPin = u8x8->pins[msg & 0x3f];
    if (ulPin != 0xff) {
      if ((msg & 0x30) == 0) {
        arduino::digitalWrite(ulPin,(uint)arg_int);
      }
      else {
        if ((msg & 0x3f) == 0x10) {
          yield();
        }
        PVar1 = __digitalRead(ulPin);
        u8x8->gpio_result = PVar1 != LOW;
      }
    }
    break;
  case 'L':
  case 'M':
    if (arg_int == '\0') {
      __pinMode(u8x8->pins[msg & 0x3f],OUTPUT);
      arduino::digitalWrite(u8x8->pins[msg & 0x3f],0);
    }
    else {
      __pinMode(u8x8->pins[msg & 0x3f],OUTPUT);
      arduino::digitalWrite(u8x8->pins[msg & 0x3f],1);
    }
  }
  return '\x01';
}



uint8_t u8x8_byte_arduino_hw_i2c(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  switch(msg) {
  case '\x14':
    if (u8x8->bus_clock == 0) {
      u8x8->bus_clock = (uint)u8x8->display_info->i2c_bus_clock_100kHz * 100000;
    }
    TwoWire::begin(&Wire);
    break;
  default:
    return '\0';
  case '\x17':
    TwoWire::write(&Wire,(int)arg_ptr,(void *)(uint)arg_int,(size_t)arg_ptr);
    break;
  case '\x18':
    TwoWire::setClock(&Wire,u8x8->bus_clock);
    TwoWire::beginTransmission(&Wire,u8x8->i2c_address >> 1);
    break;
  case '\x19':
    TwoWire::endTransmission(&Wire);
    break;
  case ' ':
  }
  return '\x01';
}



void u8x8_SetPin_HW_I2C(u8x8_t *u8x8,uint8_t reset,uint8_t clock,uint8_t data)

{
  uint8_t data_local;
  uint8_t clock_local;
  uint8_t reset_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  u8x8->pins[0xb] = reset;
  u8x8->pins[0xc] = clock;
  u8x8->pins[0xd] = data;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  arduino::SPISettings::SPISettings(&arduino::DEFAULT_SPI_SETTINGS);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN4U8X85writeEh(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



void u8g2_ClearBuffer(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  size_t cnt;
  
  gp = &__global_pointer_;
  memset(u8g2->tile_buf_ptr,0,
         (uint)((u8g2->u8x8).display_info)->tile_width * (uint)u8g2->tile_buf_height * 8);
  return;
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_send_tile_row(u8g2_t *u8g2,uint8_t src_tile_row,uint8_t dest_tile_row)

{
  uint8_t dest_tile_row_local;
  uint8_t src_tile_row_local;
  u8g2_t *u8g2_local;
  uint8_t *ptr;
  uint16_t offset;
  uint8_t w;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



void u8g2_send_buffer(u8g2_t *u8g2)

{
  byte bVar1;
  byte bVar2;
  u8g2_t *u8g2_local;
  byte local_12;
  byte local_11;
  uint8_t dest_max;
  uint8_t src_max;
  uint8_t dest_row;
  uint8_t src_row;
  
  gp = &__global_pointer_;
  local_11 = 0;
  bVar1 = u8g2->tile_buf_height;
  local_12 = u8g2->tile_curr_row;
  bVar2 = ((u8g2->u8x8).display_info)->tile_height;
  do {
    u8g2_send_tile_row(u8g2,local_11,local_12);
    local_11 = local_11 + 1;
    local_12 = local_12 + 1;
    if (bVar1 <= local_11) {
      gp = &__global_pointer_;
      return;
    }
  } while (local_12 < bVar2);
  return;
}



void u8g2_SendBuffer(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2_send_buffer(u8g2);
  u8x8_RefreshDisplay(&u8g2->u8x8);
  return;
}



void u8g2_SetBufferCurrTileRow(u8g2_t *u8g2,uint8_t row)

{
  uint8_t row_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2->tile_curr_row = row;
  (*u8g2->cb->update_dimension)(u8g2);
  (*u8g2->cb->update_page_win)(u8g2);
  return;
}



void u8g2_FirstPage(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  if (u8g2->is_auto_page_clear != '\0') {
    u8g2_ClearBuffer(u8g2);
  }
  u8g2_SetBufferCurrTileRow(u8g2,'\0');
  return;
}



uint8_t u8g2_NextPage(u8g2_t *u8g2)

{
  byte row_00;
  uint8_t uVar1;
  u8g2_t *u8g2_local;
  uint8_t row;
  
  gp = &__global_pointer_;
  u8g2_send_buffer(u8g2);
  row_00 = u8g2->tile_buf_height + u8g2->tile_curr_row;
  if (row_00 < ((u8g2->u8x8).display_info)->tile_height) {
    if (u8g2->is_auto_page_clear != '\0') {
      u8g2_ClearBuffer(u8g2);
    }
    u8g2_SetBufferCurrTileRow(u8g2,row_00);
    uVar1 = '\x01';
  }
  else {
    u8x8_RefreshDisplay(&u8g2->u8x8);
    uVar1 = '\0';
  }
  return uVar1;
}



void u8g2_ClearDisplay(u8g2_t *u8g2)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2_FirstPage(u8g2);
  do {
    uVar1 = u8g2_NextPage(u8g2);
  } while (CONCAT31(extraout_var,uVar1) != 0);
  u8g2_SetBufferCurrTileRow(u8g2,'\0');
  return;
}



uint8_t * u8g2_m_16_8_f(uint8_t *page_cnt)

{
  uint8_t *page_cnt_local;
  
  gp = &__global_pointer_;
  *page_cnt = '\b';
  return u8g2_m_16_8_f::buf;
}



void u8g2_Setup_ssd1306_i2c_128x64_noname_f
               (u8g2_t *u8g2,u8g2_cb_t *rotation,u8x8_msg_cb byte_cb,u8x8_msg_cb gpio_and_delay_cb)

{
  u8x8_msg_cb gpio_and_delay_cb_local;
  u8x8_msg_cb byte_cb_local;
  u8g2_cb_t *rotation_local;
  u8g2_t *u8g2_local;
  uint8_t local_15;
  uint8_t *puStack_14;
  uint8_t tile_buf_height;
  uint8_t *buf;
  
  gp = &__global_pointer_;
  u8x8_Setup(&u8g2->u8x8,u8x8_d_ssd1306_128x64_noname,u8x8_cad_ssd13xx_fast_i2c,byte_cb,
             gpio_and_delay_cb);
  puStack_14 = u8g2_m_16_8_f(&local_15);
  u8g2_SetupBuffer(u8g2,puStack_14,local_15,u8g2_ll_hvline_vertical_top_lsb,rotation);
  return;
}



uint8_t u8g2_font_get_byte(uint8_t *font,uint8_t offset)

{
  uint8_t offset_local;
  uint8_t *font_local;
  
  gp = &__global_pointer_;
  return font[offset];
}



uint16_t u8g2_font_get_word(uint8_t *font,uint8_t offset)

{
  uint8_t offset_local;
  uint8_t *font_local;
  uint16_t pos;
  
  gp = &__global_pointer_;
  return (ushort)font[offset] * 0x100 + (ushort)(font + offset)[1];
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_read_font_info(u8g2_font_info_t *font_info,uint8_t *font)

{
  uint8_t uVar1;
  uint8_t *font_local;
  u8g2_font_info_t *font_info_local;
  
  gp = &__global_pointer_;
  uVar1 = u8g2_font_get_byte(font,'\0');
  font_info->glyph_cnt = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x01');
  font_info->bbx_mode = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x02');
  font_info->bits_per_0 = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x03');
  font_info->bits_per_1 = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x04');
  font_info->bits_per_char_width = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x05');
  font_info->bits_per_char_height = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\x06');
  font_info->bits_per_char_x = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\a');
  font_info->bits_per_char_y = uVar1;
  uVar1 = u8g2_font_get_byte(font,'\b');
  font_info->bits_per_delta_x = uVar1;
  u8g2_font_get_byte(font,'\t');
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

uint8_t u8g2_font_decode_get_unsigned_bits(u8g2_font_decode_t *f,uint8_t cnt)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  uint8_t cnt_local;
  u8g2_font_decode_t *f_local;
  uint8_t s;
  uint8_t bit_pos;
  uint8_t bit_pos_plus_cnt;
  uint8_t val;
  
  gp = &__global_pointer_;
  bVar1 = f->decode_bit_pos;
  bVar2 = *f->decode_ptr;
  bVar3 = cnt + bVar1;
  if (7 < bVar3) {
    f->decode_ptr = f->decode_ptr + 1;
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  f->decode_bit_pos = bVar3;
  return ~(byte)(-1 << (cnt & 0x1f)) & (byte)((int)(uint)bVar2 >> (bVar1 & 0x1f));
}



int8_t u8g2_font_decode_get_signed_bits(u8g2_font_decode_t *f,uint8_t cnt)

{
  uint8_t uVar1;
  uint8_t cnt_local;
  u8g2_font_decode_t *f_local;
  int8_t d;
  int8_t v;
  
  gp = &__global_pointer_;
  uVar1 = u8g2_font_decode_get_unsigned_bits(f,cnt);
  return uVar1 - (char)(1 << ((byte)(cnt - 1) & 0x1f));
}



// WARNING: Control flow encountered unimplemented instructions

u8g2_uint_t u8g2_add_vector_y(u8g2_uint_t dy,int8_t x,int8_t y,uint8_t dir)

{
  uint8_t dir_local;
  int8_t y_local;
  int8_t x_local;
  u8g2_uint_t dy_local;
  
  gp = &__global_pointer_;
  if (dir == '\x02') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if (dir < 3) {
    if (dir == '\0') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if (dir == '\x01') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

u8g2_uint_t u8g2_add_vector_x(u8g2_uint_t dx,int8_t x,int8_t y,uint8_t dir)

{
  uint8_t dir_local;
  int8_t y_local;
  int8_t x_local;
  u8g2_uint_t dx_local;
  
  gp = &__global_pointer_;
  if (dir == '\x02') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if (dir < 3) {
    if (dir == '\0') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if (dir == '\x01') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_font_decode_len(u8g2_t *u8g2,uint8_t len,uint8_t is_foreground)

{
  u8g2_uint_t dy;
  byte bVar1;
  uint8_t is_foreground_local;
  uint8_t len_local;
  u8g2_t *u8g2_local;
  u8g2_uint_t y;
  u8g2_uint_t x;
  uint8_t rem;
  u8g2_font_decode_t *decode;
  uint8_t ly;
  uint8_t lx;
  uint8_t current;
  uint8_t cnt;
  
  gp = &__global_pointer_;
  decode._1_1_ = (u8g2->font_decode).x;
  decode._0_1_ = (u8g2->font_decode).y;
  decode._3_1_ = len;
  while( true ) {
    bVar1 = (u8g2->font_decode).glyph_width - decode._1_1_;
    dy = (u8g2->font_decode).target_y;
    u8g2_add_vector_x((u8g2->font_decode).target_x,decode._1_1_,(int8_t)decode,
                      (u8g2->font_decode).dir);
    u8g2_add_vector_y(dy,decode._1_1_,(int8_t)decode,(u8g2->font_decode).dir);
    if (is_foreground != '\0') {
      u8g2->draw_color = (u8g2->font_decode).fg_color;
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if ((u8g2->font_decode).is_transparent == '\0') break;
    if (decode._3_1_ < bVar1) {
      (u8g2->font_decode).x = decode._3_1_ + decode._1_1_;
      (u8g2->font_decode).y = (int8_t)decode;
      return;
    }
    decode._3_1_ = decode._3_1_ - bVar1;
    decode._1_1_ = '\0';
    decode._0_1_ = (int8_t)decode + '\x01';
  }
  u8g2->draw_color = (u8g2->font_decode).bg_color;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_font_setup_decode(u8g2_t *u8g2,uint8_t *glyph_data)

{
  uint8_t *glyph_data_local;
  u8g2_t *u8g2_local;
  u8g2_font_decode_t *decode;
  
  gp = &__global_pointer_;
  (u8g2->font_decode).decode_ptr = glyph_data;
  (u8g2->font_decode).decode_bit_pos = '\0';
  u8g2_font_decode_get_unsigned_bits(&u8g2->font_decode,(u8g2->font_info).bits_per_char_width);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

int8_t u8g2_font_decode_glyph(u8g2_t *u8g2,uint8_t *glyph_data)

{
  int8_t iVar1;
  u8g2_font_decode_t *f;
  uint8_t *glyph_data_local;
  u8g2_t *u8g2_local;
  uint8_t b;
  uint8_t a;
  int8_t d;
  int8_t y;
  int8_t x;
  int8_t h;
  u8g2_font_decode_t *decode;
  u8g2_uint_t y1;
  u8g2_uint_t y0;
  u8g2_uint_t x1;
  u8g2_uint_t x0;
  
  gp = &__global_pointer_;
  f = &u8g2->font_decode;
  u8g2_font_setup_decode(u8g2,glyph_data);
  u8g2_font_decode_get_signed_bits(f,(u8g2->font_info).bits_per_char_x);
  u8g2_font_decode_get_signed_bits(f,(u8g2->font_info).bits_per_char_y);
  iVar1 = u8g2_font_decode_get_signed_bits(f,(u8g2->font_info).bits_per_delta_x);
  if ('\0' < (u8g2->font_decode).glyph_width) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return iVar1;
}



uint8_t * u8g2_font_get_glyph_data(u8g2_t *u8g2,uint16_t encoding)

{
  uint16_t uVar1;
  undefined2 extraout_var;
  uint16_t encoding_local;
  u8g2_t *u8g2_local;
  uint8_t *puStack_18;
  uint16_t e;
  uint8_t *unicode_lookup_table;
  uint8_t *font;
  
  gp = &__global_pointer_;
  unicode_lookup_table = u8g2->font + 0x17;
  if (encoding < 0x100) {
    if (encoding < 0x61) {
      if (0x40 < encoding) {
        unicode_lookup_table = unicode_lookup_table + (u8g2->font_info).start_pos_upper_A;
      }
    }
    else {
      unicode_lookup_table = unicode_lookup_table + (u8g2->font_info).start_pos_lower_a;
    }
    for (; unicode_lookup_table[1] != '\0';
        unicode_lookup_table = unicode_lookup_table + unicode_lookup_table[1]) {
      if (encoding == *unicode_lookup_table) {
        return unicode_lookup_table + 2;
      }
    }
  }
  else {
    puStack_18 = unicode_lookup_table + (u8g2->font_info).start_pos_unicode;
    unicode_lookup_table = puStack_18;
    do {
      uVar1 = u8g2_font_get_word(puStack_18,'\0');
      unicode_lookup_table = unicode_lookup_table + CONCAT22(extraout_var,uVar1);
      uVar1 = u8g2_font_get_word(puStack_18,'\x02');
      puStack_18 = puStack_18 + 4;
    } while (uVar1 < encoding);
    for (; CONCAT11(*unicode_lookup_table,unicode_lookup_table[1]) != 0;
        unicode_lookup_table = unicode_lookup_table + unicode_lookup_table[2]) {
      if (CONCAT11(*unicode_lookup_table,unicode_lookup_table[1]) == encoding) {
        return unicode_lookup_table + 3;
      }
    }
  }
  return (uint8_t *)0x0;
}



u8g2_uint_t u8g2_font_draw_glyph(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,uint16_t encoding)

{
  int8_t iVar1;
  uint8_t *glyph_data_00;
  undefined3 extraout_var;
  uint16_t encoding_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  uint8_t *glyph_data;
  u8g2_uint_t dx;
  
  gp = &__global_pointer_;
  glyph_data._2_2_ = 0;
  (u8g2->font_decode).target_x = x;
  (u8g2->font_decode).target_y = y;
  glyph_data_00 = u8g2_font_get_glyph_data(u8g2,encoding);
  if (glyph_data_00 != (uint8_t *)0x0) {
    iVar1 = u8g2_font_decode_glyph(u8g2,glyph_data_00);
    glyph_data._2_2_ = (u8g2_uint_t)CONCAT31(extraout_var,iVar1);
  }
  return glyph_data._2_2_;
}



u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,uint16_t encoding)

{
  byte bVar1;
  u8g2_uint_t uVar2;
  u8g2_uint_t local_18;
  uint16_t encoding_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  bVar1 = (u8g2->font_decode).dir;
  local_18 = y;
  if (bVar1 == 3) {
    uVar2 = (*u8g2->font_calc_vref)(u8g2);
    encoding_local = x + uVar2;
  }
  else {
    encoding_local = x;
    if (bVar1 < 4) {
      if (bVar1 == 2) {
        local_18 = (*u8g2->font_calc_vref)(u8g2);
        local_18 = y - local_18;
      }
      else if (bVar1 < 3) {
        if (bVar1 == 0) {
          local_18 = (*u8g2->font_calc_vref)(u8g2);
          local_18 = y + local_18;
        }
        else if (bVar1 == 1) {
          uVar2 = (*u8g2->font_calc_vref)(u8g2);
          encoding_local = x - uVar2;
        }
      }
    }
  }
  uVar2 = u8g2_font_draw_glyph(u8g2,encoding_local,local_18,encoding);
  return uVar2;
}



u8g2_uint_t u8g2_draw_string(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,char *str)

{
  byte bVar1;
  uint16_t encoding;
  u8g2_uint_t uVar2;
  uint8_t *local_2c;
  char *str_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  u8g2_uint_t delta;
  uint16_t e;
  u8g2_uint_t sum;
  
  gp = &__global_pointer_;
  u8x8_utf8_init(&u8g2->u8x8);
  delta = 0;
  local_2c = (uint8_t *)str;
  str_local._0_2_ = y;
  str_local._2_2_ = x;
  while (encoding = (*(u8g2->u8x8).next_cb)(&u8g2->u8x8,*local_2c), encoding != 0xffff) {
    local_2c = local_2c + 1;
    if (encoding != 0xfffe) {
      uVar2 = u8g2_DrawGlyph(u8g2,str_local._2_2_,(u8g2_uint_t)str_local,encoding);
      bVar1 = (u8g2->font_decode).dir;
      if (bVar1 == 3) {
        str_local._0_2_ = (u8g2_uint_t)str_local - uVar2;
      }
      else if (bVar1 < 4) {
        if (bVar1 == 2) {
          str_local._2_2_ = str_local._2_2_ - uVar2;
        }
        else if (bVar1 < 3) {
          if (bVar1 == 0) {
            str_local._2_2_ = uVar2 + str_local._2_2_;
          }
          else if (bVar1 == 1) {
            str_local._0_2_ = uVar2 + (u8g2_uint_t)str_local;
          }
        }
      }
      delta = uVar2 + delta;
    }
  }
  return delta;
}



u8g2_uint_t u8g2_DrawUTF8(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,char *str)

{
  u8g2_uint_t uVar1;
  char *str_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  (u8g2->u8x8).next_cb = u8x8_utf8_next;
  uVar1 = u8g2_draw_string(u8g2,x,y,str);
  return uVar1;
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_UpdateRefHeight(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  if (u8g2->font != (uint8_t *)0x0) {
    u8g2->font_ref_ascent = (u8g2->font_info).ascent_A;
    u8g2->font_ref_descent = (u8g2->font_info).descent_g;
    if (u8g2->font_height_mode != '\0') {
      if (u8g2->font_height_mode == '\x01') {
        if (u8g2->font_ref_ascent < (u8g2->font_info).ascent_para) {
          u8g2->font_ref_ascent = (u8g2->font_info).ascent_para;
        }
        if ((u8g2->font_info).descent_para < u8g2->font_ref_descent) {
          u8g2->font_ref_descent = (u8g2->font_info).descent_para;
        }
      }
      else {
        if ((int)u8g2->font_ref_ascent <
            (int)(u8g2->font_info).y_offset + (int)(u8g2->font_info).max_char_height) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
          halt_unimplemented();
        }
        if ((u8g2->font_info).y_offset < u8g2->font_ref_descent) {
          u8g2->font_ref_descent = (u8g2->font_info).y_offset;
        }
      }
    }
  }
  return;
}



u8g2_uint_t u8g2_font_calc_vref_font(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  return 0;
}



void u8g2_SetFontPosBaseline(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2->font_calc_vref = u8g2_font_calc_vref_font;
  return;
}



void u8g2_SetFont(u8g2_t *u8g2,uint8_t *font)

{
  uint8_t *font_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  if (font != u8g2->font) {
    u8g2->font = font;
    u8g2_read_font_info(&u8g2->font_info,font);
    u8g2_UpdateRefHeight(u8g2);
  }
  return;
}



uint8_t u8g2_clip_intersection2(u8g2_uint_t *ap,u8g2_uint_t *len,u8g2_uint_t c,u8g2_uint_t d)

{
  ushort uVar1;
  uint8_t uVar2;
  u8g2_uint_t d_local;
  u8g2_uint_t c_local;
  u8g2_uint_t *len_local;
  u8g2_uint_t *ap_local;
  ushort local_14;
  ushort local_12;
  u8g2_uint_t b;
  u8g2_uint_t a;
  
  gp = &__global_pointer_;
  uVar1 = *ap;
  local_14 = *len + uVar1;
  local_12 = uVar1;
  if ((local_14 < uVar1) && (local_12 = c, uVar1 < d)) {
    local_14 = d - 1;
    local_12 = uVar1;
  }
  if (local_12 < d) {
    if (c < local_14) {
      if (local_12 < c) {
        local_12 = c;
      }
      if (d < local_14) {
        local_14 = d;
      }
      *ap = local_12;
      *len = local_14 - local_12;
      uVar2 = '\x01';
    }
    else {
      uVar2 = '\0';
    }
  }
  else {
    uVar2 = '\0';
  }
  return uVar2;
}



void u8g2_draw_hv_line_2dir(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,u8g2_uint_t len,uint8_t dir)

{
  uint8_t dir_local;
  u8g2_uint_t len_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  (*u8g2->ll_hvline)(u8g2,x,y - u8g2->pixel_curr_row,len,dir);
  return;
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_DrawHVLine(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,u8g2_uint_t len,uint8_t dir)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u8g2_uint_t local_1a;
  u8g2_uint_t uStack_18;
  uint8_t dir_local;
  u8g2_uint_t len_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  int iVar2;
  
  gp = &__global_pointer_;
  if ((u8g2->is_page_clip_window_intersection != '\0') && (len != 0)) {
    if (1 < len) {
      if (dir == '\x02') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
      if (dir == '\x03') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
    }
    local_1a = len;
    uStack_18 = y;
    len_local = x;
    _y_local = u8g2;
    if ((dir & 1) == 0) {
      if (y < u8g2->user_y0) {
        return;
      }
      if (u8g2->user_y1 <= y) {
        return;
      }
      uVar1 = u8g2_clip_intersection2(&len_local,&local_1a,u8g2->user_x0,u8g2->user_x1);
      iVar2 = CONCAT31(extraout_var,uVar1);
    }
    else {
      if (x < u8g2->user_x0) {
        return;
      }
      if (u8g2->user_x1 <= x) {
        return;
      }
      uVar1 = u8g2_clip_intersection2(&stack0xffffffe8,&local_1a,u8g2->user_y0,u8g2->user_y1);
      iVar2 = CONCAT31(extraout_var_00,uVar1);
    }
    if (iVar2 != 0) {
      (*_y_local->cb->draw_l90)(_y_local,len_local,uStack_18,local_1a,dir & 1);
    }
  }
  return;
}



uint8_t u8g2_is_intersection_decision_tree
                  (u8g2_uint_t a0,u8g2_uint_t a1,u8g2_uint_t v0,u8g2_uint_t v1)

{
  uint8_t uVar1;
  u8g2_uint_t v1_local;
  u8g2_uint_t v0_local;
  u8g2_uint_t a1_local;
  u8g2_uint_t a0_local;
  
  gp = &__global_pointer_;
  if (v0 < a1) {
    if (a0 < v1) {
      uVar1 = '\x01';
    }
    else if (v1 < v0) {
      uVar1 = '\x01';
    }
    else {
      uVar1 = '\0';
    }
  }
  else if (a0 < v1) {
    if (v1 < v0) {
      uVar1 = '\x01';
    }
    else {
      uVar1 = '\0';
    }
  }
  else {
    uVar1 = '\0';
  }
  return uVar1;
}



uint8_t u8g2_IsIntersection(u8g2_t *u8g2,u8g2_uint_t x0,u8g2_uint_t y0,u8g2_uint_t x1,u8g2_uint_t y1
                           )

{
  uint8_t uVar1;
  undefined3 extraout_var;
  u8g2_uint_t y1_local;
  u8g2_uint_t x1_local;
  u8g2_uint_t y0_local;
  u8g2_uint_t x0_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  uVar1 = u8g2_is_intersection_decision_tree(u8g2->user_y0,u8g2->user_y1,y0,y1);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    uVar1 = '\0';
  }
  else {
    uVar1 = u8g2_is_intersection_decision_tree(u8g2->user_x0,u8g2->user_x1,x0,x1);
  }
  return uVar1;
}



void u8g2_ll_hvline_vertical_top_lsb
               (u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,u8g2_uint_t len,uint8_t dir)

{
  u8g2_uint_t local_2a;
  uint8_t dir_local;
  u8g2_uint_t len_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  byte local_17;
  uint16_t offset;
  uint8_t mask;
  uint8_t xor_mask;
  uint8_t or_mask;
  uint8_t bit_pos;
  uint8_t *ptr;
  
  gp = &__global_pointer_;
  offset._1_1_ = (byte)y & 7;
  offset._0_1_ = 0;
  local_17 = 0;
  if (u8g2->draw_color < 2) {
    offset._0_1_ = '\x01' << offset._1_1_;
  }
  if (u8g2->draw_color != '\x01') {
    local_17 = '\x01' << offset._1_1_;
  }
  _mask = u8g2->tile_buf_ptr +
          (uint)x + (uint)(ushort)((ushort)((u8g2->u8x8).display_info)->tile_width * (y & 0xfff8));
  local_2a = len;
  if (dir == '\0') {
    do {
      *_mask = *_mask | (byte)offset;
      *_mask = *_mask ^ local_17;
      _mask = _mask + 1;
      local_2a = local_2a - 1;
    } while (local_2a != 0);
  }
  else {
    do {
      *_mask = *_mask | (byte)offset;
      *_mask = *_mask ^ local_17;
      offset._1_1_ = offset._1_1_ + 1 & 7;
      local_2a = local_2a - 1;
      if (offset._1_1_ == 0) {
        _mask = _mask + u8g2->pixel_buf_width;
        if (u8g2->draw_color < 2) {
          offset._0_1_ = 1;
        }
        if (u8g2->draw_color != '\x01') {
          local_17 = 1;
        }
      }
      else {
        offset._0_1_ = (byte)offset << 1;
        local_17 = local_17 << 1;
      }
    } while (local_2a != 0);
  }
  return;
}



void u8g2_SetMaxClipWindow(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2->clip_x0 = 0;
  u8g2->clip_y0 = 0;
  u8g2->clip_x1 = 0xffff;
  u8g2->clip_y1 = 0xffff;
  (*u8g2->cb->update_page_win)(u8g2);
  return;
}



void u8g2_SetupBuffer(u8g2_t *u8g2,uint8_t *buf,uint8_t tile_buf_height,
                     u8g2_draw_ll_hvline_cb ll_hvline_cb,u8g2_cb_t *u8g2_cb)

{
  u8g2_cb_t *u8g2_cb_local;
  u8g2_draw_ll_hvline_cb ll_hvline_cb_local;
  uint8_t tile_buf_height_local;
  uint8_t *buf_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2->font = (uint8_t *)0x0;
  u8g2->ll_hvline = ll_hvline_cb;
  u8g2->tile_buf_ptr = buf;
  u8g2->tile_buf_height = tile_buf_height;
  u8g2->tile_curr_row = '\0';
  (u8g2->font_decode).is_transparent = '\0';
  u8g2->bitmap_transparency = '\0';
  u8g2->font_height_mode = '\0';
  u8g2->draw_color = '\x01';
  u8g2->is_auto_page_clear = '\x01';
  u8g2->cb = u8g2_cb;
  (*u8g2->cb->update_dimension)(u8g2);
  u8g2_SetMaxClipWindow(u8g2);
  u8g2_SetFontPosBaseline(u8g2);
  (u8g2->font_decode).dir = '\0';
  return;
}



// WARNING: Control flow encountered unimplemented instructions

void u8g2_update_dimension_common(u8g2_t *u8g2)

{
  u8x8_display_info_t *puVar1;
  u8g2_t *u8g2_local;
  u8x8_display_info_t *display_info;
  u8g2_uint_t t;
  
  gp = &__global_pointer_;
  puVar1 = (u8g2->u8x8).display_info;
  u8g2->pixel_buf_height = (ushort)u8g2->tile_buf_height << 3;
  u8g2->pixel_buf_width = (ushort)puVar1->tile_width << 3;
  u8g2->pixel_curr_row = (ushort)u8g2->tile_curr_row << 3;
  u8g2->buf_y0 = u8g2->pixel_curr_row;
  u8g2->buf_y1 = u8g2->buf_y0;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



void u8g2_apply_clip_window(u8g2_t *u8g2)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  uVar1 = u8g2_IsIntersection(u8g2,u8g2->clip_x0,u8g2->clip_y0,u8g2->clip_x1,u8g2->clip_y1);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    u8g2->is_page_clip_window_intersection = '\0';
  }
  else {
    u8g2->is_page_clip_window_intersection = '\x01';
    if (u8g2->user_x0 < u8g2->clip_x0) {
      u8g2->user_x0 = u8g2->clip_x0;
    }
    if (u8g2->clip_x1 < u8g2->user_x1) {
      u8g2->user_x1 = u8g2->clip_x1;
    }
    if (u8g2->user_y0 < u8g2->clip_y0) {
      u8g2->user_y0 = u8g2->clip_y0;
    }
    if (u8g2->clip_y1 < u8g2->user_y1) {
      u8g2->user_y1 = u8g2->clip_y1;
    }
  }
  return;
}



void u8g2_update_dimension_r0(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2_update_dimension_common(u8g2);
  return;
}



void u8g2_update_page_win_r0(u8g2_t *u8g2)

{
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2->user_x0 = 0;
  u8g2->user_x1 = u8g2->width;
  u8g2->user_y0 = u8g2->buf_y0;
  u8g2->user_y1 = u8g2->buf_y1;
  u8g2_apply_clip_window(u8g2);
  return;
}



void u8g2_draw_l90_r0(u8g2_t *u8g2,u8g2_uint_t x,u8g2_uint_t y,u8g2_uint_t len,uint8_t dir)

{
  uint8_t dir_local;
  u8g2_uint_t len_local;
  u8g2_uint_t y_local;
  u8g2_uint_t x_local;
  u8g2_t *u8g2_local;
  
  gp = &__global_pointer_;
  u8g2_draw_hv_line_2dir(u8g2,x,y,len,dir);
  return;
}



void u8x8_utf8_init(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  u8x8->utf8_state = '\0';
  return;
}



// WARNING: Control flow encountered unimplemented instructions

uint16_t u8x8_ascii_next(u8x8_t *u8x8,uint8_t b)

{
  uint8_t b_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  if ((b != '\0') && (b != '\n')) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return 0xffff;
}



// WARNING: Control flow encountered unimplemented instructions

uint16_t u8x8_utf8_next(u8x8_t *u8x8,uint8_t b)

{
  uint8_t b_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  if ((b != '\0') && (b != '\n')) {
    if (u8x8->utf8_state != '\0') {
      u8x8->utf8_state = u8x8->utf8_state + 0xff;
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if (b < 0xfc) {
      if (b < 0xf8) {
        if (b < 0xf0) {
          if (b < 0xe0) {
            if (b < 0xc0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
              halt_unimplemented();
            }
            u8x8->utf8_state = '\x01';
          }
          else {
            u8x8->utf8_state = '\x02';
          }
        }
        else {
          u8x8->utf8_state = '\x03';
        }
      }
      else {
        u8x8->utf8_state = '\x04';
      }
    }
    else {
      u8x8->utf8_state = '\x05';
    }
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return 0xffff;
}



uint8_t u8x8_byte_SendBytes(u8x8_t *u8x8,uint8_t cnt,uint8_t *data)

{
  uint8_t uVar1;
  uint8_t *data_local;
  uint8_t cnt_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->byte_cb)(u8x8,'\x17',cnt,data);
  return uVar1;
}



uint8_t u8x8_byte_SendByte(u8x8_t *u8x8,uint8_t byte)

{
  uint8_t uVar1;
  uint8_t local_15;
  u8x8_t *puStack_14;
  uint8_t byte_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  local_15 = byte;
  puStack_14 = u8x8;
  uVar1 = u8x8_byte_SendBytes(u8x8,'\x01',&local_15);
  return uVar1;
}



uint8_t u8x8_byte_StartTransfer(u8x8_t *u8x8)

{
  uint8_t uVar1;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->byte_cb)(u8x8,'\x18','\0',(void *)0x0);
  return uVar1;
}



uint8_t u8x8_byte_EndTransfer(u8x8_t *u8x8)

{
  uint8_t uVar1;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->byte_cb)(u8x8,'\x19','\0',(void *)0x0);
  return uVar1;
}



uint8_t u8x8_cad_SendCmd(u8x8_t *u8x8,uint8_t cmd)

{
  uint8_t uVar1;
  uint8_t cmd_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->cad_cb)(u8x8,'\x15',cmd,(void *)0x0);
  return uVar1;
}



uint8_t u8x8_cad_SendArg(u8x8_t *u8x8,uint8_t arg)

{
  uint8_t uVar1;
  uint8_t arg_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->cad_cb)(u8x8,'\x16',arg,(void *)0x0);
  return uVar1;
}



uint8_t u8x8_cad_SendData(u8x8_t *u8x8,uint8_t cnt,uint8_t *data)

{
  uint8_t uVar1;
  uint8_t *data_local;
  uint8_t cnt_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->cad_cb)(u8x8,'\x17',cnt,data);
  return uVar1;
}



uint8_t u8x8_cad_StartTransfer(u8x8_t *u8x8)

{
  uint8_t uVar1;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->cad_cb)(u8x8,'\x18','\0',(void *)0x0);
  return uVar1;
}



uint8_t u8x8_cad_EndTransfer(u8x8_t *u8x8)

{
  uint8_t uVar1;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = (*u8x8->cad_cb)(u8x8,'\x19','\0',(void *)0x0);
  return uVar1;
}



void u8x8_cad_SendSequence(u8x8_t *u8x8,uint8_t *data)

{
  byte *pbVar1;
  byte *local_28;
  uint8_t *data_local;
  u8x8_t *u8x8_local;
  byte local_12;
  byte local_11;
  uint8_t v;
  uint8_t cmd;
  
  gp = &__global_pointer_;
  local_28 = data;
  while( true ) {
    while( true ) {
      local_11 = *local_28;
      pbVar1 = local_28 + 1;
      if (local_11 != 0xfe) break;
      local_12 = *pbVar1;
      u8x8_gpio_call(u8x8,')',local_12);
      local_28 = local_28 + 2;
    }
    if ((0xfe < local_11) || (0x19 < local_11)) break;
    if (local_11 < 0x18) {
      if (local_11 < 0x17) {
        if (local_11 < 0x15) {
          return;
        }
        local_12 = *pbVar1;
        (*u8x8->cad_cb)(u8x8,local_11,local_12,(void *)0x0);
        local_28 = local_28 + 2;
      }
      else {
        if (local_11 != 0x17) {
          return;
        }
        local_12 = *pbVar1;
        u8x8_cad_SendData(u8x8,'\x01',&local_12);
        local_28 = local_28 + 2;
      }
    }
    else {
      (*u8x8->cad_cb)(u8x8,local_11,'\0',(void *)0x0);
      local_28 = pbVar1;
    }
  }
  return;
}



void u8x8_i2c_data_transfer(u8x8_t *u8x8,uint8_t arg_int,void *arg_ptr)

{
  void *arg_ptr_local;
  uint8_t arg_int_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  u8x8_byte_StartTransfer(u8x8);
  u8x8_byte_SendByte(u8x8,'@');
  (*u8x8->byte_cb)(u8x8,'\x17',arg_int,arg_ptr);
  u8x8_byte_EndTransfer(u8x8);
  return;
}



uint8_t u8x8_cad_ssd13xx_fast_i2c(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  uint8_t uVar1;
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  void *local_14;
  uint8_t *p;
  
  gp = &__global_pointer_;
  switch(msg) {
  case '\x14':
    if (u8x8->i2c_address == 0xff) {
      u8x8->i2c_address = 'x';
    }
    uVar1 = (*u8x8->byte_cb)(u8x8,msg,arg_int,arg_ptr);
    return uVar1;
  case '\x15':
    if (u8x8_cad_ssd13xx_fast_i2c::in_transfer != '\0') {
      u8x8_byte_EndTransfer(u8x8);
    }
    u8x8_byte_StartTransfer(u8x8);
    u8x8_byte_SendByte(u8x8,'\0');
    u8x8_byte_SendByte(u8x8,arg_int);
    u8x8_cad_ssd13xx_fast_i2c::in_transfer = '\x01';
    break;
  case '\x16':
    u8x8_byte_SendByte(u8x8,arg_int);
    break;
  case '\x17':
    arg_ptr_local._2_1_ = arg_int;
    local_14 = arg_ptr;
    if (u8x8_cad_ssd13xx_fast_i2c::in_transfer != '\0') {
      u8x8_byte_EndTransfer(u8x8);
    }
    for (; 0x18 < arg_ptr_local._2_1_; arg_ptr_local._2_1_ = arg_ptr_local._2_1_ - 0x18) {
      u8x8_i2c_data_transfer(u8x8,'\x18',local_14);
      local_14 = (void *)((int)local_14 + 0x18);
    }
    u8x8_i2c_data_transfer(u8x8,arg_ptr_local._2_1_,local_14);
    u8x8_cad_ssd13xx_fast_i2c::in_transfer = '\0';
    break;
  case '\x18':
    u8x8_cad_ssd13xx_fast_i2c::in_transfer = '\0';
    break;
  case '\x19':
    if (u8x8_cad_ssd13xx_fast_i2c::in_transfer != '\0') {
      u8x8_byte_EndTransfer(u8x8);
    }
    u8x8_cad_ssd13xx_fast_i2c::in_transfer = '\0';
    break;
  default:
    return '\0';
  }
  return '\x01';
}



uint8_t u8x8_d_ssd1306_sh1106_generic(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  byte bVar1;
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  uint8_t *ptr;
  uint8_t c;
  uint8_t x;
  
  gp = &__global_pointer_;
  if (msg == '\x0f') {
    u8x8_cad_StartTransfer(u8x8);
    bVar1 = u8x8->x_offset + *(char *)((int)arg_ptr + 5) * '\b';
    u8x8_cad_SendCmd(u8x8,'@');
    u8x8_cad_SendCmd(u8x8,bVar1 >> 4 | 0x10);
    u8x8_cad_SendArg(u8x8,bVar1 & 0xf);
    u8x8_cad_SendArg(u8x8,*(byte *)((int)arg_ptr + 6) | 0xb0);
    arg_ptr_local._2_1_ = arg_int;
    do {
                    // WARNING: Load size is inaccurate
      u8x8_cad_SendData(u8x8,*(char *)((int)arg_ptr + 4) << 3,*arg_ptr);
      arg_ptr_local._2_1_ = arg_ptr_local._2_1_ + 0xff;
    } while (arg_ptr_local._2_1_ != '\0');
    u8x8_cad_EndTransfer(u8x8);
  }
  else {
    if (0xf < msg) {
      return '\0';
    }
    if (msg == '\x0e') {
      u8x8_cad_StartTransfer(u8x8);
      u8x8_cad_SendCmd(u8x8,0x81);
      u8x8_cad_SendArg(u8x8,arg_int);
      u8x8_cad_EndTransfer(u8x8);
    }
    else {
      if (0xe < msg) {
        return '\0';
      }
      if (msg == '\v') {
        if (arg_int == '\0') {
          u8x8_cad_SendSequence(u8x8,u8x8_d_ssd1306_128x64_noname_powersave0_seq);
        }
        else {
          u8x8_cad_SendSequence(u8x8,u8x8_d_ssd1306_128x64_noname_powersave1_seq);
        }
      }
      else {
        if (msg != '\r') {
          return '\0';
        }
        if (arg_int == '\0') {
          u8x8_cad_SendSequence(u8x8,u8x8_d_ssd1306_128x64_noname_flip0_seq);
          u8x8->x_offset = u8x8->display_info->default_x_offset;
        }
        else {
          u8x8_cad_SendSequence(u8x8,u8x8_d_ssd1306_128x64_noname_flip1_seq);
          u8x8->x_offset = u8x8->display_info->flipmode_x_offset;
        }
      }
    }
  }
  return '\x01';
}



uint8_t u8x8_d_ssd1306_128x64_noname(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  uVar1 = u8x8_d_ssd1306_sh1106_generic(u8x8,msg,arg_int,arg_ptr);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    if (msg == '\t') {
      u8x8_d_helper_display_setup_memory(u8x8,&u8x8_ssd1306_128x64_noname_display_info);
    }
    else {
      if (msg != '\n') {
        gp = &__global_pointer_;
        return '\0';
      }
      u8x8_d_helper_display_init(u8x8);
      u8x8_cad_SendSequence(u8x8,u8x8_d_ssd1306_128x64_noname_init_seq);
    }
  }
  return '\x01';
}



void u8x8_d_helper_display_setup_memory(u8x8_t *u8x8,u8x8_display_info_t *display_info)

{
  u8x8_display_info_t *display_info_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  u8x8->display_info = display_info;
  u8x8->x_offset = u8x8->display_info->default_x_offset;
  return;
}



void u8x8_d_helper_display_init(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->gpio_and_delay_cb)(u8x8,'(','\0',(void *)0x0);
  (*u8x8->cad_cb)(u8x8,'\x14','\0',(void *)0x0);
  u8x8_gpio_call(u8x8,'K','\x01');
  u8x8_gpio_call(u8x8,')',u8x8->display_info->reset_pulse_width_ms);
  u8x8_gpio_call(u8x8,'K','\0');
  u8x8_gpio_call(u8x8,')',u8x8->display_info->reset_pulse_width_ms);
  u8x8_gpio_call(u8x8,'K','\x01');
  u8x8_gpio_call(u8x8,')',u8x8->display_info->post_reset_wait_ms);
  return;
}



uint8_t u8x8_DrawTile(u8x8_t *u8x8,uint8_t x,uint8_t y,uint8_t cnt,uint8_t *tile_ptr)

{
  uint8_t uVar1;
  uint8_t *tile_ptr_local;
  uint8_t cnt_local;
  uint8_t y_local;
  uint8_t x_local;
  u8x8_t *u8x8_local;
  uint8_t *local_18;
  u8x8_tile_t tile;
  
  gp = &__global_pointer_;
  local_18 = tile_ptr;
  tile.tile_ptr._0_1_ = cnt;
  tile.tile_ptr._1_1_ = x;
  tile.tile_ptr._2_1_ = y;
  uVar1 = (*u8x8->display_cb)(u8x8,'\x0f','\x01',&local_18);
  return uVar1;
}



void u8x8_SetupMemory(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->display_cb)(u8x8,'\t','\0',(void *)0x0);
  return;
}



void u8x8_InitDisplay(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->display_cb)(u8x8,'\n','\0',(void *)0x0);
  return;
}



void u8x8_SetPowerSave(u8x8_t *u8x8,uint8_t is_enable)

{
  uint8_t is_enable_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->display_cb)(u8x8,'\v',is_enable,(void *)0x0);
  return;
}



void u8x8_RefreshDisplay(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->display_cb)(u8x8,'\x10','\0',(void *)0x0);
  return;
}



void u8x8_gpio_call(u8x8_t *u8x8,uint8_t msg,uint8_t arg)

{
  uint8_t arg_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  (*u8x8->gpio_and_delay_cb)(u8x8,msg,arg,(void *)0x0);
  return;
}



uint8_t u8x8_dummy_cb(u8x8_t *u8x8,uint8_t msg,uint8_t arg_int,void *arg_ptr)

{
  void *arg_ptr_local;
  uint8_t arg_int_local;
  uint8_t msg_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  return '\0';
}



void u8x8_SetupDefaults(u8x8_t *u8x8)

{
  u8x8_t *u8x8_local;
  byte local_11;
  uint8_t i;
  
  gp = &__global_pointer_;
  u8x8->display_info = (u8x8_display_info_t *)0x0;
  u8x8->display_cb = u8x8_dummy_cb;
  u8x8->cad_cb = u8x8_dummy_cb;
  u8x8->byte_cb = u8x8_dummy_cb;
  u8x8->gpio_and_delay_cb = u8x8_dummy_cb;
  u8x8->is_font_inverse_mode = '\0';
  u8x8->utf8_state = '\0';
  u8x8->bus_clock = 0;
  u8x8->i2c_address = 0xff;
  u8x8->debounce_default_pin_state = 0xff;
  for (local_11 = 0; local_11 < 0x16; local_11 = local_11 + 1) {
    u8x8->pins[local_11] = 0xff;
  }
  return;
}



void u8x8_Setup(u8x8_t *u8x8,u8x8_msg_cb display_cb,u8x8_msg_cb cad_cb,u8x8_msg_cb byte_cb,
               u8x8_msg_cb gpio_and_delay_cb)

{
  u8x8_msg_cb gpio_and_delay_cb_local;
  u8x8_msg_cb byte_cb_local;
  u8x8_msg_cb cad_cb_local;
  u8x8_msg_cb display_cb_local;
  u8x8_t *u8x8_local;
  
  gp = &__global_pointer_;
  u8x8_SetupDefaults(u8x8);
  u8x8->display_cb = display_cb;
  u8x8->cad_cb = cad_cb;
  u8x8->byte_cb = byte_cb;
  u8x8->gpio_and_delay_cb = gpio_and_delay_cb;
  u8x8_SetupMemory(u8x8);
  return;
}



// DWARF original prototype: void Stream(Stream * this)

void __thiscall arduino::Stream::Stream(Stream *this)

{
  Stream *this_local;
  
  gp = &__global_pointer_;
  Print::Print(&this->super_Print);
  (this->super_Print)._vptr_Print = (_func_int_varargs **)&DAT_1002355c;
  this->_timeout = 1000;
  return;
}



undefined4 to_us_since_boot(absolute_time_t t)

{
  undefined4 in_a0;
  absolute_time_t t_local;
  
  gp = &__global_pointer_;
  return in_a0;
}



void update_us_since_boot(absolute_time_t *t,uint64_t us_since_boot)

{
  undefined4 in_a1;
  undefined4 in_a2;
  uint64_t us_since_boot_local;
  absolute_time_t *t_local;
  
  gp = &__global_pointer_;
  *(undefined4 *)t = in_a1;
  *(undefined4 *)((int)t + 4) = in_a2;
  return;
}



void gpio_pull_up(uint gpio)

{
  uint gpio_local;
  
  gp = &__global_pointer_;
  gpio_set_pulls(gpio,true,false);
  return;
}



// WARNING: Variable defined which should be unmapped: target

bool timer_time_reached(timer_hw_t *timer,absolute_time_t t)

{
  uint uVar1;
  uint extraout_a1;
  bool bVar2;
  absolute_time_t t_local;
  timer_hw_t *timer_local;
  uint32_t hi;
  uint32_t hi_target;
  uint64_t target;
  
  gp = &__global_pointer_;
  uVar1 = to_us_since_boot(t);
  if ((timer->timerawh < extraout_a1) ||
     ((timer->timerawl < uVar1 && (timer->timerawh == extraout_a1)))) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  return bVar2;
}



bool time_reached(absolute_time_t t)

{
  bool bVar1;
  absolute_time_t t_local;
  
  gp = &__global_pointer_;
  bVar1 = timer_time_reached((timer_hw_t *)0x400b0000,t);
  return bVar1;
}



// WARNING: Unknown calling convention

undefined4 get_absolute_time(void)

{
  undefined4 local_18;
  absolute_time_t t;
  
  gp = &__global_pointer_;
  time_us_64();
  update_us_since_boot((absolute_time_t *)&local_18,uRam00000010);
  return local_18;
}



undefined4 delayed_by_ms(absolute_time_t t,uint32_t ms)

{
  int extraout_a1;
  uint in_a2;
  uint32_t ms_local;
  absolute_time_t t_local;
  undefined4 local_38;
  absolute_time_t t2;
  uint64_t base;
  uint64_t delayed;
  
  gp = &__global_pointer_;
  t2._4_4_ = to_us_since_boot(t);
  base._4_4_ = t2._4_4_ + in_a2 * 1000;
  delayed._0_4_ =
       (uint)(base._4_4_ < t2._4_4_) + extraout_a1 + (int)((ulonglong)in_a2 * 1000 >> 0x20);
  if ((int)delayed < 0) {
    base._4_4_ = 0xffffffff;
    delayed._0_4_ = 0x7fffffff;
  }
  base._0_4_ = extraout_a1;
  update_us_since_boot((absolute_time_t *)&local_38,t);
  return local_38;
}



undefined4 make_timeout_time_ms(uint32_t ms)

{
  uint32_t ms_00;
  undefined4 uVar1;
  uint32_t ms_local;
  
  gp = &__global_pointer_;
  ms_00 = get_absolute_time();
  uVar1 = delayed_by_ms(aRam00000010,ms_00);
  return uVar1;
}



void check_dma_channel_param(uint channel)

{
  uint channel_local;
  
  gp = &__global_pointer_;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void dma_channel_set_irq0_enabled(uint channel,bool enabled)

{
  bool enabled_local;
  uint channel_local;
  
  gp = &__global_pointer_;
  check_dma_channel_param(channel);
  if (enabled) {
    _DAT_50002404 = 1 << (channel & 0x1f);
  }
  else {
    _DAT_50003404 = 1 << (channel & 0x1f);
  }
  return;
}



uint i2c_get_index(i2c_inst_t *i2c)

{
  i2c_inst_t *i2c_local;
  
  gp = &__global_pointer_;
  return (uint)(i2c == &i2c1_inst);
}



i2c_hw_t * i2c_get_hw(i2c_inst_t *i2c)

{
  i2c_inst_t *i2c_local;
  
  gp = &__global_pointer_;
  i2c_get_index(i2c);
  return i2c->hw;
}



size_t i2c_get_write_available(i2c_inst_t *i2c)

{
  i2c_hw_t *piVar1;
  i2c_inst_t *i2c_local;
  size_t IC_TX_BUFFER_DEPTH;
  
  gp = &__global_pointer_;
  piVar1 = i2c_get_hw(i2c);
  return 0x10 - piVar1->txflr;
}



// DWARF original prototype: void HardwareI2C(HardwareI2C * this)

void __thiscall arduino::HardwareI2C::HardwareI2C(HardwareI2C *this)

{
  HardwareI2C *this_local;
  
  gp = &__global_pointer_;
  Stream::Stream(&this->super_Stream);
  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&DAT_1002350c;
  return;
}



// DWARF original prototype: void TwoWire(TwoWire * this, i2c_inst_t * i2c, pin_size_t sda,
// pin_size_t scl)

void __thiscall TwoWire::TwoWire(TwoWire *this,i2c_inst_t *i2c,pin_size_t sda,pin_size_t scl)

{
  uint8_t *puVar1;
  pin_size_t scl_local;
  pin_size_t sda_local;
  i2c_inst_t *i2c_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  arduino::HardwareI2C::HardwareI2C(&this->super_HardwareI2C);
  (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print =
       (_func_int_varargs **)&PTR_write_100234bc;
  this->_slaveStartDet = false;
  this->_dmaRunning = false;
  this->_dmaChannelReceive = -1;
  this->_dmaChannelSend = -1;
  this->_dmaSendBuffer = (uint16_t *)0x0;
  this->_dmaSendBufferLen = 0;
  this->_dmaFinished = true;
  this->_dmaOnFinished = (_func_void *)0x0;
  this->_sda = sda;
  this->_scl = scl;
  this->_i2c = i2c;
  this->_clkHz = 100000;
  this->_running = false;
  this->_txBegun = false;
  this->_buffLen = 0;
  this->_buffSize = 0x100;
  puVar1 = (uint8_t *)__wrap_malloc(this->_buffSize);
  this->_buff = puVar1;
  return;
}



// DWARF original prototype: void setClock(TwoWire * this, uint32_t hz)

void __thiscall TwoWire::setClock(TwoWire *this,uint32_t hz)

{
  uint32_t hz_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  this->_clkHz = hz;
  if (this->_running != false) {
    i2c_set_baudrate(this->_i2c,hz);
  }
  return;
}



// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names
// DWARF original prototype: void begin(TwoWire * this)

void __thiscall TwoWire::begin(TwoWire *this)

{
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  if (this->_running == false) {
    this->_slave = false;
    i2c_init(this->_i2c,this->_clkHz);
    i2c_set_slave_mode(this->_i2c,false,'\0');
    gpio_set_function((uint)this->_sda,GPIO_FUNC_I2C);
    gpio_pull_up((uint)this->_sda);
    gpio_set_function((uint)this->_scl,GPIO_FUNC_I2C);
    gpio_pull_up((uint)this->_scl);
    this->_running = true;
    this->_txBegun = false;
    this->_buffLen = 0;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _handler0(void)

{
  gp = &__global_pointer_;
  TwoWire::onIRQ(&Wire);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _handler1(void)

{
  gp = &__global_pointer_;
  TwoWire::onIRQ(&Wire1);
  return;
}



// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names
// DWARF original prototype: void begin(TwoWire * this, uint8_t addr)

void __thiscall TwoWire::begin(TwoWire *this,uint8_t addr)

{
  int iVar1;
  uint8_t *puVar2;
  uint uVar3;
  uint uVar4;
  uint8_t addr_local;
  TwoWire *this_local;
  int irqNo;
  
  gp = &__global_pointer_;
  if (this->_running == false) {
    if (this->_buff == (uint8_t *)0x0) {
      puVar2 = (uint8_t *)__wrap_malloc(this->_buffSize);
      this->_buff = puVar2;
      if (this->_buff == (uint8_t *)0x0) {
        return;
      }
    }
    this->_slave = true;
    i2c_init(this->_i2c,this->_clkHz);
    i2c_set_slave_mode(this->_i2c,true,addr);
    this->_i2c->hw->intr_mask = 0x1664;
    uVar3 = i2c_get_index(this->_i2c);
    uVar4 = i2c_get_index(this->_i2c);
    if (uVar4 == 0) {
      iVar1 = 0x5be;
    }
    else {
      iVar1 = 0x5da;
    }
    irq_set_exclusive_handler(uVar3 + 0x24,(irq_handler_t)(iVar1 + 0x10008000));
    irq_set_enabled(uVar3 + 0x24,true);
    gpio_set_function((uint)this->_sda,GPIO_FUNC_I2C);
    gpio_pull_up((uint)this->_sda);
    gpio_set_function((uint)this->_scl,GPIO_FUNC_I2C);
    gpio_pull_up((uint)this->_scl);
    this->_running = true;
  }
  return;
}



// DWARF original prototype: void onIRQ(TwoWire * this)

void __thiscall TwoWire::onIRQ(TwoWire *this)

{
  uint uVar1;
  io_rw_32 iVar2;
  int iVar3;
  TwoWire *this_local;
  uint32_t irqstat;
  
  gp = &__global_pointer_;
  uVar1 = this->_i2c->hw->intr_stat;
  if (uVar1 != 0) {
    if (((uVar1 & 4) != 0) && (this->_buffLen < (int)this->_buffSize)) {
      iVar2 = this->_i2c->hw->data_cmd;
      iVar3 = this->_buffLen;
      this->_buffLen = iVar3 + 1;
      this->_buff[iVar3] = (uint8_t)iVar2;
    }
    if (((uVar1 & 0x20) != 0) && (this->_onRequestCallback != (_func_void *)0x0)) {
      (*this->_onRequestCallback)(this->_onRequestCallback);
    }
    if ((uVar1 & 0x400) != 0) {
      this->_slaveStartDet = true;
    }
    if ((uVar1 & 0x1000) != 0) {
      if ((this->_onReceiveCallback != (_func_void_int *)0x0) && (this->_buffLen != 0)) {
        (*this->_onReceiveCallback)(this->_buffLen);
      }
      this->_buffLen = 0;
      this->_buffOff = 0;
      this->_slaveStartDet = false;
    }
    if ((uVar1 & 0x200) != 0) {
      if ((this->_onReceiveCallback != (_func_void_int *)0x0) && (this->_buffLen != 0)) {
        (*this->_onReceiveCallback)(this->_buffLen);
      }
      this->_buffLen = 0;
      this->_buffOff = 0;
      this->_slaveStartDet = false;
    }
  }
  return;
}



// DWARF original prototype: void end(TwoWire * this)

void __thiscall TwoWire::end(TwoWire *this)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  TwoWire *this_local;
  int irqNo;
  
  gp = &__global_pointer_;
  endAsync(this);
  if (this->_running == true) {
    if (this->_slave != false) {
      uVar2 = i2c_get_index(this->_i2c);
      uVar3 = i2c_get_index(this->_i2c);
      if (uVar3 == 0) {
        iVar1 = 0x5be;
      }
      else {
        iVar1 = 0x5da;
      }
      irq_remove_handler(uVar2 + 0x24,(irq_handler_t)(iVar1 + 0x10008000));
      irq_set_enabled(uVar2 + 0x24,false);
    }
    i2c_deinit(this->_i2c);
    __pinMode(this->_sda,INPUT);
    __pinMode(this->_scl,INPUT);
    this->_running = false;
    this->_txBegun = false;
  }
  return;
}



// DWARF original prototype: void beginTransmission(TwoWire * this, uint8_t addr)

void __thiscall TwoWire::beginTransmission(TwoWire *this,uint8_t addr)

{
  uint8_t addr_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  if ((this->_running == true) && (this->_txBegun == false)) {
    this->_addr = addr;
    this->_buffLen = 0;
    this->_buffOff = 0;
    this->_txBegun = true;
  }
  return;
}



// DWARF original prototype: size_t requestFrom(TwoWire * this, uint8_t address, size_t quantity,
// bool stopBit)

size_t __thiscall TwoWire::requestFrom(TwoWire *this,uint8_t address,size_t quantity,bool stopBit)

{
  i2c_inst_t *i2c;
  int iVar1;
  size_t sVar2;
  uint8_t *dst;
  size_t quantity_local;
  bool stopBit_local;
  uint8_t address_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  if ((((this->_running == true) && (this->_txBegun == false)) && (quantity != 0)) &&
     (quantity <= this->_buffSize)) {
    i2c = this->_i2c;
    dst = this->_buff;
    make_timeout_time_ms((this->super_HardwareI2C).super_Stream._timeout);
    iVar1 = i2c_read_blocking_until(i2c,address,dst,quantity,!stopBit,aRam00000010);
    this->_buffLen = iVar1;
    if ((this->_buffLen == -1) || (this->_buffLen == -2)) {
      if (this->_buffLen == -2) {
        _handleTimeout(this,this->_reset_with_timeout);
      }
      this->_buffLen = 0;
    }
    this->_buffOff = 0;
    sVar2 = this->_buffLen;
  }
  else {
    sVar2 = 0;
  }
  return sVar2;
}



// DWARF original prototype: size_t requestFrom(TwoWire * this, uint8_t address, size_t quantity)

size_t __thiscall TwoWire::requestFrom(TwoWire *this,uint8_t address,size_t quantity)

{
  size_t sVar1;
  _func_int_varargs *p_Var2;
  size_t quantity_local;
  uint8_t address_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  p_Var2 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[0xe];
  sVar1 = (*p_Var2)((uint)address,quantity,1,p_Var2);
  return sVar1;
}



bool _clockStretch(pin_size_t pin)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  PinStatus PVar4;
  int extraout_a1;
  uint extraout_a1_00;
  uint uVar5;
  pin_size_t pin_local;
  ulonglong end;
  
  gp = &__global_pointer_;
  uVar2 = time_us_64();
  uVar5 = (uint)(uVar2 + 500 < uVar2) + extraout_a1;
  do {
    uVar3 = time_us_64();
    if (((extraout_a1_00 < uVar5) || ((uVar5 == extraout_a1_00 && (uVar3 < uVar2 + 500)))) &&
       (PVar4 = __digitalRead(pin), PVar4 == LOW)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
  } while (bVar1);
  PVar4 = __digitalRead(pin);
  return PVar4 != LOW;
}



// WARNING: Variable defined which should be unmapped: ack
// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names

bool _probe(int addr,pin_size_t sda,pin_size_t scl,int freq)

{
  bool bVar1;
  PinStatus PVar2;
  int freq_local;
  pin_size_t scl_local;
  int iStack_44;
  pin_size_t sda_local;
  int addr_local;
  int delay;
  int i;
  bool ack;
  
  gp = &__global_pointer_;
  i._3_1_ = false;
  __pinMode(sda,INPUT_PULLUP);
  __pinMode(scl,INPUT_PULLUP);
  gpio_set_function((uint)scl,GPIO_FUNC_SIO);
  gpio_set_function((uint)sda,GPIO_FUNC_SIO);
  __digitalWrite(sda,HIGH);
  sleep_us(uRam00000010);
  __digitalWrite(scl,HIGH);
  bVar1 = _clockStretch(scl);
  if (bVar1) {
    __digitalWrite(sda,LOW);
    sleep_us(uRam00000010);
    __digitalWrite(scl,LOW);
    sleep_us(uRam00000010);
    iStack_44 = addr;
    for (delay = 0; delay < 8; delay = delay + 1) {
      iStack_44 = iStack_44 << 1;
      __digitalWrite(sda,iStack_44 >> 7 & HIGH);
      sleep_us(uRam00000010);
      __digitalWrite(scl,HIGH);
      sleep_us(uRam00000010);
      bVar1 = _clockStretch(scl);
      if (!bVar1) goto LAB_10008dce;
      __digitalWrite(scl,LOW);
      sleep_us(uRam00000010);
    }
    __digitalWrite(sda,HIGH);
    sleep_us(uRam00000010);
    __digitalWrite(scl,HIGH);
    bVar1 = _clockStretch(scl);
    if (bVar1) {
      PVar2 = __digitalRead(sda);
      i._3_1_ = PVar2 == LOW;
      sleep_us(uRam00000010);
      __digitalWrite(scl,LOW);
    }
  }
LAB_10008dce:
  sleep_us(uRam00000010);
  __digitalWrite(sda,LOW);
  sleep_us(uRam00000010);
  __digitalWrite(scl,HIGH);
  sleep_us(uRam00000010);
  __digitalWrite(sda,HIGH);
  sleep_us(uRam00000010);
  gpio_set_function((uint)scl,GPIO_FUNC_I2C);
  gpio_set_function((uint)sda,GPIO_FUNC_I2C);
  return i._3_1_;
}



// WARNING: Variable defined which should be unmapped: sclPulseCount
// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names
// DWARF original prototype: void _handleTimeout(TwoWire * this, bool reset)

void __thiscall TwoWire::_handleTimeout(TwoWire *this,bool reset)

{
  byte bVar1;
  bool bVar2;
  PinStatus PVar3;
  int iVar4;
  _func_int_varargs *p_Var5;
  bool reset_local;
  TwoWire *this_local;
  int prev_clkHz;
  uint8_t prev_addr;
  int delay;
  int prev_clkHz_1;
  int sclPulseCount;
  
  gp = &__global_pointer_;
  this->_timeoutFlag = true;
  if (reset) {
    if (this->_slave == false) {
      iVar4 = this->_clkHz;
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[9];
      (*p_Var5)(p_Var5);
      __pinMode(this->_sda,INPUT_PULLUP);
      __pinMode(this->_scl,INPUT_PULLUP);
      gpio_set_function((uint)this->_scl,GPIO_FUNC_SIO);
      gpio_set_function((uint)this->_sda,GPIO_FUNC_SIO);
      PVar3 = __digitalRead(this->_sda);
      if (PVar3 == LOW) {
        prev_clkHz_1 = 0;
        while( true ) {
          if ((prev_clkHz_1 < 9) && (PVar3 = __digitalRead(this->_sda), PVar3 == LOW)) {
            bVar2 = true;
          }
          else {
            bVar2 = false;
          }
          if (!bVar2) break;
          prev_clkHz_1 = prev_clkHz_1 + 1;
          __digitalWrite(this->_scl,LOW);
          sleep_us(uRam00000010);
          __digitalWrite(this->_scl,HIGH);
          sleep_us(uRam00000010);
        }
        PVar3 = __digitalRead(this->_sda);
        if (PVar3 == HIGH) {
          __digitalWrite(this->_sda,LOW);
          sleep_us(uRam00000010);
          __digitalWrite(this->_sda,HIGH);
        }
      }
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[10];
      (*p_Var5)(iVar4,p_Var5);
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[7];
      (*p_Var5)(p_Var5);
    }
    else {
      bVar1 = this->_addr;
      iVar4 = this->_clkHz;
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[9];
      (*p_Var5)(p_Var5);
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[10];
      (*p_Var5)(iVar4,p_Var5);
      p_Var5 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[8];
      (*p_Var5)((uint)bVar1,p_Var5);
    }
  }
  return;
}



// DWARF original prototype: uint8_t endTransmission(TwoWire * this, bool stopBit)

uint8_t __thiscall TwoWire::endTransmission(TwoWire *this,bool stopBit)

{
  i2c_inst_t *i2c;
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  uint8_t uVar3;
  int iVar4;
  size_t len_00;
  uint8_t *src;
  bool stopBit_local;
  TwoWire *this_local;
  int ret;
  int len;
  
  gp = &__global_pointer_;
  if ((this->_running == true) && (this->_txBegun == true)) {
    this->_txBegun = false;
    if (this->_buffLen == 0) {
      bVar1 = _probe((uint)this->_addr,this->_sda,this->_scl,this->_clkHz);
      if (CONCAT31(extraout_var,bVar1) == 0) {
        uVar3 = '\x02';
      }
      else {
        uVar3 = '\0';
      }
    }
    else {
      iVar4 = this->_buffLen;
      i2c = this->_i2c;
      uVar3 = this->_addr;
      src = this->_buff;
      len_00 = this->_buffLen;
      make_timeout_time_ms((this->super_HardwareI2C).super_Stream._timeout);
      iVar2 = i2c_write_blocking_until(i2c,uVar3,src,len_00,!stopBit,aRam00000010);
      if (iVar2 == -2) {
        _handleTimeout(this,this->_reset_with_timeout);
        uVar3 = '\x05';
      }
      else {
        this->_buffLen = 0;
        if (iVar2 == iVar4) {
          uVar3 = '\0';
        }
        else {
          uVar3 = '\x04';
        }
      }
    }
  }
  else {
    uVar3 = '\x04';
  }
  return uVar3;
}



// DWARF original prototype: uint8_t endTransmission(TwoWire * this)

uint8_t __thiscall TwoWire::endTransmission(TwoWire *this)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  p_Var2 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[0xc];
  iVar1 = (*p_Var2)(1,p_Var2);
  return (uint8_t)iVar1;
}



// DWARF original prototype: size_t write(TwoWire * this, uint8_t ucData)

ssize_t __thiscall TwoWire::write(TwoWire *this,int __fd,void *__buf,size_t __n)

{
  bool bVar1;
  size_t sVar2;
  ssize_t sVar3;
  int iVar4;
  uint8_t ucData_local;
  TwoWire *this_local;
  ulonglong end;
  
  gp = &__global_pointer_;
  if (this->_running == true) {
    if (this->_slave == false) {
      if ((this->_txBegun == true) && (this->_buffLen != this->_buffSize)) {
        iVar4 = this->_buffLen;
        this->_buffLen = iVar4 + 1;
        this->_buff[iVar4] = (uint8_t)__fd;
        sVar3 = 1;
      }
      else {
        sVar3 = 0;
      }
    }
    else {
      make_timeout_time_ms((this->super_HardwareI2C).super_Stream._timeout);
      do {
        sVar2 = i2c_get_write_available(this->_i2c);
        if ((sVar2 != 0) || (bVar1 = time_reached(aRam00000010), bVar1)) {
          bVar1 = false;
        }
        else {
          bVar1 = true;
        }
      } while (bVar1);
      sVar2 = i2c_get_write_available(this->_i2c);
      if (sVar2 == 0) {
        _handleTimeout(this,this->_reset_with_timeout);
        sVar3 = 0;
      }
      else {
        this->_i2c->hw->data_cmd = __fd & 0xff;
        sVar3 = 1;
      }
    }
  }
  else {
    sVar3 = 0;
  }
  return sVar3;
}



// DWARF original prototype: size_t write(TwoWire * this, uint8_t * data, size_t quantity)

ssize_t __thiscall TwoWire::write(TwoWire *this,int __fd,void *__buf,size_t __n)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  void *pvVar3;
  size_t quantity_local;
  uint8_t *data_local;
  TwoWire *this_local;
  void *local_14;
  size_t i;
  
  gp = &__global_pointer_;
  local_14 = (void *)0x0;
  while ((pvVar3 = __buf, local_14 < __buf &&
         (p_Var2 = *(this->super_HardwareI2C).super_Stream.super_Print._vptr_Print,
         iVar1 = (*p_Var2)((uint)*(byte *)((int)local_14 + __fd),p_Var2), pvVar3 = local_14,
         iVar1 != 0))) {
    local_14 = (void *)((int)local_14 + 1);
  }
  return (ssize_t)pvVar3;
}



// DWARF original prototype: int available(TwoWire * this)

int __thiscall TwoWire::available(TwoWire *this)

{
  int iVar1;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  if (this->_running == false) {
    iVar1 = 0;
  }
  else {
    iVar1 = this->_buffLen - this->_buffOff;
  }
  return iVar1;
}



// DWARF original prototype: int read(TwoWire * this)

ssize_t __thiscall TwoWire::read(TwoWire *this,int __fd,void *__buf,size_t __nbytes)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  uint uVar3;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  p_Var2 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[4];
  iVar1 = (*p_Var2)(p_Var2);
  if (iVar1 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    iVar1 = this->_buffOff;
    this->_buffOff = iVar1 + 1;
    uVar3 = (uint)this->_buff[iVar1];
  }
  return uVar3;
}



// DWARF original prototype: int peek(TwoWire * this)

int __thiscall TwoWire::peek(TwoWire *this)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  uint uVar3;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  p_Var2 = (this->super_HardwareI2C).super_Stream.super_Print._vptr_Print[4];
  iVar1 = (*p_Var2)(p_Var2);
  if (iVar1 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = (uint)this->_buff[this->_buffOff];
  }
  return uVar3;
}



// DWARF original prototype: void flush(TwoWire * this)

void __thiscall TwoWire::flush(TwoWire *this)

{
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void _dma_i2c0_irq_handler(void)

{
  uint uVar1;
  uint32_t status;
  
  uVar1 = _DAT_5000040c;
  gp = &__global_pointer_;
  if (((_DAT_5000040c & _dma_i2c0_irq_mask) != 0) && (_dma_i2c0_wire_instance != (TwoWire *)0x0)) {
    TwoWire::_dma_irq_handler(_dma_i2c0_wire_instance);
  }
  _DAT_5000040c = uVar1 & _dma_i2c0_irq_mask;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void _dma_i2c1_irq_handler(void)

{
  uint uVar1;
  uint32_t status;
  
  uVar1 = _DAT_5000040c;
  gp = &__global_pointer_;
  if (((_DAT_5000040c & _dma_i2c1_irq_mask) != 0) && (_dma_i2c1_wire_instance != (TwoWire *)0x0)) {
    TwoWire::_dma_irq_handler(_dma_i2c1_wire_instance);
  }
  _DAT_5000040c = uVar1 & _dma_i2c1_irq_mask;
  return;
}



// DWARF original prototype: void _dma_irq_handler(TwoWire * this)

void __thiscall TwoWire::_dma_irq_handler(TwoWire *this)

{
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  this->_i2c->hw->dma_cr = 0;
  this->_txBegun = false;
  this->_dmaFinished = true;
  dma_channel_set_irq0_enabled(this->_dmaChannelSend,false);
  dma_channel_set_irq0_enabled(this->_dmaChannelReceive,false);
  if (this->_dmaOnFinished != (_func_void *)0x0) {
    (*this->_dmaOnFinished)(this->_dmaOnFinished);
  }
  return;
}



// DWARF original prototype: void endAsync(TwoWire * this)

void __thiscall TwoWire::endAsync(TwoWire *this)

{
  uint uVar1;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  if (this->_dmaRunning == true) {
    uVar1 = i2c_get_index(this->_i2c);
    if (uVar1 == 0) {
      _dma_i2c0_irq_mask = 0;
      _dma_i2c0_wire_instance = (TwoWire *)0x0;
      irq_remove_handler(10,_dma_i2c0_irq_handler);
    }
    else {
      _dma_i2c1_irq_mask = 0;
      _dma_i2c1_wire_instance = (TwoWire *)0x0;
      irq_remove_handler(10,_dma_i2c1_irq_handler);
    }
    if (-1 < this->_dmaChannelReceive) {
      dma_channel_cleanup(this->_dmaChannelReceive);
      dma_channel_unclaim(this->_dmaChannelReceive);
      this->_dmaChannelReceive = -1;
    }
    if (-1 < this->_dmaChannelSend) {
      dma_channel_cleanup(this->_dmaChannelSend);
      dma_channel_unclaim(this->_dmaChannelSend);
      this->_dmaChannelSend = -1;
    }
    this->_i2c->hw->dma_cr = 0;
    __wrap_free(this->_dmaSendBuffer);
    this->_dmaSendBuffer = (uint16_t *)0x0;
    this->_dmaSendBufferLen = 0;
    this->_txBegun = false;
    this->_dmaFinished = true;
    this->_dmaOnFinished = (_func_void *)0x0;
    this->_dmaRunning = false;
  }
  return;
}



// DWARF original prototype: void onReceive(TwoWire * this, _func_void_int * function)

void __thiscall TwoWire::onReceive(TwoWire *this,_func_void_int *function)

{
  _func_void_int *function_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  this->_onReceiveCallback = function;
  return;
}



// DWARF original prototype: void onRequest(TwoWire * this, _func_void * function)

void __thiscall TwoWire::onRequest(TwoWire *this,_func_void *function)

{
  _func_void *function_local;
  TwoWire *this_local;
  
  gp = &__global_pointer_;
  this->_onRequestCallback = function;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  TwoWire::TwoWire(&Wire,&i2c0_inst,'\x04','\x05');
  TwoWire::TwoWire(&Wire1,&i2c1_inst,'\x1a','\x1b');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN7TwoWireC2EP8i2c_insthh(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



void check_doorbell_num_param(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void multicore_doorbell_set_other_core(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  check_doorbell_num_param(doorbell_num);
  _DAT_d0000180 = 1 << (doorbell_num & 0x1f);
  return;
}



// DWARF original prototype: void idleOtherCore(_MFIFO * this)

void __thiscall _MFIFO::idleOtherCore(_MFIFO *this)

{
  _MFIFO *this_local;
  
  gp = &__global_pointer_;
  if (this->_multicore == true) {
    __otherCoreIdled = false;
    multicore_doorbell_set_other_core((uint)_doorbell);
    do {
    } while (__otherCoreIdled != true);
  }
  return;
}



// DWARF original prototype: void resumeOtherCore(_MFIFO * this)

void __thiscall _MFIFO::resumeOtherCore(_MFIFO *this)

{
  _MFIFO *this_local;
  
  gp = &__global_pointer_;
  if (this->_multicore == true) {
    __otherCoreIdled = false;
  }
  return;
}



// DWARF original prototype: void idleOtherCore(RP2040 * this)

void __thiscall RP2040::idleOtherCore(RP2040 *this)

{
  RP2040 *this_local;
  
  gp = &__global_pointer_;
  _MFIFO::idleOtherCore(&this->fifo);
  return;
}



// DWARF original prototype: void resumeOtherCore(RP2040 * this)

void __thiscall RP2040::resumeOtherCore(RP2040 *this)

{
  RP2040 *this_local;
  
  gp = &__global_pointer_;
  _MFIFO::resumeOtherCore(&this->fifo);
  return;
}



// DWARF original prototype: void EEPROMClass(EEPROMClass * this)

void __thiscall EEPROMClass::EEPROMClass(EEPROMClass *this)

{
  EEPROMClass *this_local;
  
  gp = &__global_pointer_;
  this->_sector = &_EEPROM_start;
  this->_data = (uint8_t *)0x0;
  this->_size = 0;
  this->_dirty = false;
  return;
}



// DWARF original prototype: void begin(EEPROMClass * this, size_t size)

void __thiscall EEPROMClass::begin(EEPROMClass *this,size_t size)

{
  uint8_t *puVar1;
  uint sz;
  size_t local_18;
  size_t size_local;
  EEPROMClass *this_local;
  
  gp = &__global_pointer_;
  if ((size == 0) || (local_18 = size, 0x1000 < size)) {
    local_18 = 0x1000;
  }
  sz = local_18 + 0xff & 0xffffff00;
  if ((this->_data == (uint8_t *)0x0) || (sz == this->_size)) {
    if (this->_data == (uint8_t *)0x0) {
      puVar1 = (uint8_t *)operator_new___(sz);
      this->_data = puVar1;
    }
  }
  else {
    if (this->_data != (uint8_t *)0x0) {
      operator_delete___(this->_data);
    }
    puVar1 = (uint8_t *)operator_new___(sz);
    this->_data = puVar1;
  }
  this->_size = sz;
  memcpy(this->_data,this->_sector,this->_size);
  this->_dirty = false;
  return;
}



// DWARF original prototype: uint8_t read(EEPROMClass * this, int address)

ssize_t __thiscall EEPROMClass::read(EEPROMClass *this,int __fd,void *__buf,size_t __nbytes)

{
  uint uVar1;
  int address_local;
  EEPROMClass *this_local;
  
  gp = &__global_pointer_;
  if ((__fd < 0) || (this->_size <= (uint)__fd)) {
    uVar1 = 0;
  }
  else if (this->_data == (uint8_t *)0x0) {
    uVar1 = 0;
  }
  else {
    uVar1 = (uint)this->_data[__fd];
  }
  return uVar1;
}



// DWARF original prototype: void write(EEPROMClass * this, int address, uint8_t value)

ssize_t __thiscall EEPROMClass::write(EEPROMClass *this,int __fd,void *__buf,size_t __n)

{
  uint8_t value_local;
  int address_local;
  EEPROMClass *this_local;
  uint8_t *pData;
  
  gp = &__global_pointer_;
  if ((((-1 < __fd) && ((uint)__fd < this->_size)) && (this->_data != (uint8_t *)0x0)) &&
     ((uint8_t)__buf != this->_data[__fd])) {
    this->_data[__fd] = (uint8_t)__buf;
    this->_dirty = true;
  }
  return (ssize_t)this;
}



// DWARF original prototype: bool commit(EEPROMClass * this)

bool __thiscall EEPROMClass::commit(EEPROMClass *this)

{
  bool bVar1;
  EEPROMClass *this_local;
  
  gp = &__global_pointer_;
  if (this->_size == 0) {
    bVar1 = false;
  }
  else if (this->_dirty == true) {
    if (this->_data == (uint8_t *)0x0) {
      bVar1 = false;
    }
    else {
      noInterrupts();
      RP2040::idleOtherCore(&rp2040);
      flash_range_erase((uint32_t)(this->_sector + -0x10000000),0x1000);
      flash_range_program((uint32_t)(this->_sector + -0x10000000),this->_data,this->_size);
      RP2040::resumeOtherCore(&rp2040);
      interrupts();
      this->_dirty = false;
      bVar1 = true;
    }
  }
  else {
    bVar1 = true;
  }
  return bVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  EEPROMClass::EEPROMClass(&EEPROM);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN11EEPROMClassC2Ev(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



// DWARF original prototype: void SPISettings(SPISettings * this, uint32_t clock, BitOrder bitOrder,
// SPIMode dataMode)

void __thiscall
arduino::SPISettings::SPISettings
          (SPISettings *this,uint32_t clock,BitOrder bitOrder,SPIMode dataMode)

{
  SPIMode dataMode_local;
  BitOrder bitOrder_local;
  uint32_t clock_local;
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  init_MightInline(this,clock,bitOrder,dataMode);
  return;
}



// DWARF original prototype: bool operator==(SPISettings * this, SPISettings * rhs)

bool __thiscall arduino::SPISettings::operator==(SPISettings *this,SPISettings *rhs)

{
  bool bVar1;
  SPISettings *rhs_local;
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  if (((this->clockFreq == rhs->clockFreq) && (this->bitOrder == rhs->bitOrder)) &&
     (this->dataMode == rhs->dataMode)) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  return bVar1;
}



// DWARF original prototype: uint32_t getClockFreq(SPISettings * this)

uint32_t __thiscall arduino::SPISettings::getClockFreq(SPISettings *this)

{
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  return this->clockFreq;
}



// DWARF original prototype: SPIMode getDataMode(SPISettings * this)

SPIMode __thiscall arduino::SPISettings::getDataMode(SPISettings *this)

{
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  return this->dataMode;
}



// DWARF original prototype: BitOrder getBitOrder(SPISettings * this)

BitOrder __thiscall arduino::SPISettings::getBitOrder(SPISettings *this)

{
  SPISettings *this_local;
  
  gp = &__global_pointer_;
  return this->bitOrder;
}



// DWARF original prototype: void ~HardwareSPI(HardwareSPI * this, int __in_chrg)

void __thiscall arduino::HardwareSPI::~HardwareSPI(HardwareSPI *this,int __in_chrg)

{
  HardwareSPI *this_local;
  
  gp = &__global_pointer_;
  this->_vptr_HardwareSPI = (_func_int_varargs **)0x100235c0;
  return;
}



// DWARF original prototype: void ~HardwareSPI(HardwareSPI * this, int __in_chrg)

void __thiscall arduino::HardwareSPI::~HardwareSPI(HardwareSPI *this,int __in_chrg)

{
  HardwareSPI *this_local;
  
  gp = &__global_pointer_;
  ~HardwareSPI(this,__in_chrg);
  operator_delete(this,4);
  return;
}



uint spi_get_index(spi_inst_t *spi)

{
  spi_inst_t *spi_local;
  
  gp = &__global_pointer_;
  return (uint)(spi == (spi_inst_t *)0x40088000);
}



spi_hw_t * spi_get_hw(spi_inst_t *spi)

{
  spi_inst_t *spi_local;
  
  gp = &__global_pointer_;
  spi_get_index(spi);
  return (spi_hw_t *)spi;
}



void spi_set_format(spi_inst_t *spi,uint data_bits,spi_cpol_t cpol,spi_cpha_t cpha,spi_order_t order
                   )

{
  spi_hw_t *psVar1;
  uint uVar2;
  spi_order_t order_local;
  spi_cpha_t cpha_local;
  spi_cpol_t cpol_local;
  uint data_bits_local;
  spi_inst_t *spi_local;
  uint32_t enable_mask;
  
  gp = &__global_pointer_;
  psVar1 = spi_get_hw(spi);
  uVar2 = psVar1->cr1;
  psVar1 = spi_get_hw(spi);
  psVar1[0x133].sr = 2;
  psVar1 = spi_get_hw(spi);
  psVar1[0x66].cpsr = (psVar1->cr0 ^ (cpha << 7 | data_bits - 1 | cpol << 6)) & 0xcf;
  psVar1 = spi_get_hw(spi);
  psVar1[0xcc].dmacr = uVar2 & 2;
  return;
}



// DWARF original name: operator new

void * operator_new(size_t param_1,void *__p)

{
  void *__p_local;
  size_t param_0_local;
  
  gp = &__global_pointer_;
  return __p;
}



// DWARF original prototype: void _Rb_tree_header(_Rb_tree_header * this)

void __thiscall std::_Rb_tree_header::_Rb_tree_header(_Rb_tree_header *this)

{
  _Rb_tree_header *this_local;
  
  gp = &__global_pointer_;
  (this->_M_header)._M_color = _S_red;
  _M_reset(this);
  return;
}



// DWARF original prototype: void _M_reset(_Rb_tree_header * this)

void __thiscall std::_Rb_tree_header::_M_reset(_Rb_tree_header *this)

{
  _Rb_tree_header *this_local;
  
  gp = &__global_pointer_;
  (this->_M_header)._M_parent = (_Base_ptr)0x0;
  (this->_M_header)._M_left = &this->_M_header;
  (this->_M_header)._M_right = &this->_M_header;
  this->_M_node_count = 0;
  return;
}



// DWARF original prototype: void ~_Rb_tree_impl(_Rb_tree_impl<std::less<int>,_true> * this, int
// __in_chrg)

void __thiscall
std::_Rb_tree<>::_Rb_tree_impl<>::~_Rb_tree_impl(_Rb_tree_impl<> *this,int __in_chrg)

{
  _Rb_tree_impl<> *this_local;
  
  gp = &__global_pointer_;
  __new_allocator<>::~__new_allocator((__new_allocator<> *)this,__in_chrg);
  return;
}



// DWARF original prototype: void
// _Rb_tree(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

void __thiscall std::_Rb_tree<>::_Rb_tree(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree_impl<>::_Rb_tree_impl(&this->_M_impl);
  return;
}



// DWARF original prototype: void
// map(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this)

void __thiscall std::map<>::map(map<> *this)

{
  map<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree<>::_Rb_tree(&this->_M_t);
  return;
}



// DWARF original prototype: void
// ~map(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this, int
// __in_chrg)

void __thiscall std::map<>::~map(map<> *this,int __in_chrg)

{
  map<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree<>::~_Rb_tree(&this->_M_t,__in_chrg);
  return;
}



// DWARF original prototype: void SPIHelper(SPIHelper * this)

void __thiscall SPIHelper::SPIHelper(SPIHelper *this)

{
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  std::map<>::map(&this->_usingIRQs);
  return;
}



// DWARF original prototype: void ~SPIHelper(SPIHelper * this, int __in_chrg)

void __thiscall SPIHelper::~SPIHelper(SPIHelper *this,int __in_chrg)

{
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  std::map<>::~map(&this->_usingIRQs,__in_chrg);
  return;
}



// DWARF original prototype: spi_cpol_t cpol(SPIHelper * this, SPISettings * _spis)

spi_cpol_t __thiscall SPIHelper::cpol(SPIHelper *this,SPISettings *_spis)

{
  SPIMode SVar1;
  SPISettings *_spis_local;
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  SVar1 = arduino::SPISettings::getDataMode(_spis);
  if (SVar1 == SPI_MODE3) {
    return SPI_CPOL_1;
  }
  if ((int)SVar1 < 4) {
    if (SVar1 == SPI_MODE2) {
      return SPI_CPOL_1;
    }
    if ((int)SVar1 < 3) {
      if (SVar1 == SPI_MODE0) {
        return SPI_CPOL_0;
      }
      if (SVar1 == SPI_MODE1) {
        return SPI_CPOL_0;
      }
    }
  }
  return SPI_CPOL_0;
}



// DWARF original prototype: spi_cpha_t cpha(SPIHelper * this, SPISettings * _spis)

spi_cpha_t __thiscall SPIHelper::cpha(SPIHelper *this,SPISettings *_spis)

{
  SPIMode SVar1;
  SPISettings *_spis_local;
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  SVar1 = arduino::SPISettings::getDataMode(_spis);
  if (SVar1 == SPI_MODE3) {
    return SPI_CPHA_1;
  }
  if ((int)SVar1 < 4) {
    if (SVar1 == SPI_MODE2) {
      return SPI_CPHA_0;
    }
    if ((int)SVar1 < 3) {
      if (SVar1 == SPI_MODE0) {
        return SPI_CPHA_0;
      }
      if (SVar1 == SPI_MODE1) {
        return SPI_CPHA_1;
      }
    }
  }
  return SPI_CPHA_0;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint8_t reverseByte(SPIHelper * this, uint8_t b)

uint8_t __thiscall SPIHelper::reverseByte(SPIHelper *this,uint8_t b)

{
  uint8_t b_local;
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint16_t reverse16Bit(SPIHelper * this, uint16_t w)

uint16_t __thiscall SPIHelper::reverse16Bit(SPIHelper *this,uint16_t w)

{
  uint16_t w_local;
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  reverseByte(this,(uint8_t)w);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void maskInterrupts(SPIHelper * this)

void __thiscall SPIHelper::maskInterrupts(SPIHelper *this)

{
  int iVar1;
  bool bVar2;
  undefined3 extraout_var;
  reference ppVar3;
  undefined3 extraout_var_00;
  uint *puVar4;
  SPIHelper *this_local;
  uint local_3c;
  uint32_t val;
  int gpio;
  iterator __for_end;
  iterator __for_begin;
  pair<> entry;
  io_rw_32 *en_reg;
  map<> *__for_range;
  io_bank0_irq_ctrl_hw_t *irq_ctrl_base;
  
  gp = &__global_pointer_;
  bVar2 = std::map<>::empty(&this->_usingIRQs);
  if (CONCAT31(extraout_var,bVar2) == 0) {
    noInterrupts();
    if (_DAT_d0000000 == 0) {
      iVar1 = 0x248;
    }
    else {
      iVar1 = 0x290;
    }
    __for_end = std::map<>::begin(&this->_usingIRQs);
    gpio = (int)std::map<>::end(&this->_usingIRQs);
    while (bVar2 = std::operator!=(&__for_end,(_Self *)&gpio), CONCAT31(extraout_var_00,bVar2) != 0)
    {
      ppVar3 = std::_Rb_tree_iterator<>::operator*(&__for_end);
      val = ppVar3->first;
      puVar4 = (uint *)(((int)(val + ((int)val >> 0x1f & 7U)) >> 3) * 4 + iVar1 + 0x40028000);
      local_3c = *puVar4 >> (((int)val % 8 & 7U) << 2) & 0xf;
      std::map<>::insert_or_assign<>(&this->_usingIRQs,(key_type *)&val,&local_3c);
      *puVar4 = *puVar4 ^ local_3c << (((int)val % 8 & 7U) << 2);
      std::_Rb_tree_iterator<>::operator++(&__for_end);
    }
    interrupts();
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void unmaskInterrupts(SPIHelper * this)

void __thiscall SPIHelper::unmaskInterrupts(SPIHelper *this)

{
  bool bVar1;
  undefined3 extraout_var;
  reference ppVar2;
  undefined3 extraout_var_00;
  SPIHelper *this_local;
  iterator __for_end;
  iterator __for_begin;
  pair<> entry;
  int mode;
  int gpio;
  io_bank0_irq_ctrl_hw_t *irq_ctrl_base;
  map<> *__for_range;
  
  gp = &__global_pointer_;
  bVar1 = std::map<>::empty(&this->_usingIRQs);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    noInterrupts();
    __for_end = std::map<>::begin(&this->_usingIRQs);
    this_local = (SPIHelper *)std::map<>::end(&this->_usingIRQs);
    while (bVar1 = std::operator!=(&__for_end,(_Self *)&this_local),
          CONCAT31(extraout_var_00,bVar1) != 0) {
      ppVar2 = std::_Rb_tree_iterator<>::operator*(&__for_end);
      gpio_set_irq_enabled(ppVar2->first,ppVar2->second,true);
      std::_Rb_tree_iterator<>::operator++(&__for_end);
    }
    interrupts();
  }
  return;
}



// DWARF original prototype: void usingInterrupt(SPIHelper * this, int interruptNumber)

void __thiscall SPIHelper::usingInterrupt(SPIHelper *this,int interruptNumber)

{
  int local_38;
  int interruptNumber_local;
  SPIHelper *this_local;
  pair<> pStack_1c;
  int local_14 [2];
  
  gp = &__global_pointer_;
  local_14[0] = 0;
  local_38 = interruptNumber;
  interruptNumber_local = (int)this;
  std::pair<>::pair<int&,_int>(&pStack_1c,&local_38,local_14);
  std::map<>::insert(&this->_usingIRQs,&pStack_1c);
  return;
}



// DWARF original prototype: void notUsingInterrupt(SPIHelper * this, int interruptNumber)

void __thiscall SPIHelper::notUsingInterrupt(SPIHelper *this,int interruptNumber)

{
  int local_18;
  int interruptNumber_local;
  SPIHelper *this_local;
  
  gp = &__global_pointer_;
  local_18 = interruptNumber;
  interruptNumber_local = (int)this;
  std::map<>::erase(&this->_usingIRQs,&local_18);
  return;
}



// DWARF original prototype: void usingInterrupt(SPIClassRP2040 * this, int interruptNumber)

void __thiscall SPIClassRP2040::usingInterrupt(SPIClassRP2040 *this,int interruptNumber)

{
  int interruptNumber_local;
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  SPIHelper::usingInterrupt(&this->_helper,interruptNumber);
  return;
}



// DWARF original prototype: void notUsingInterrupt(SPIClassRP2040 * this, int interruptNumber)

void __thiscall SPIClassRP2040::notUsingInterrupt(SPIClassRP2040 *this,int interruptNumber)

{
  int interruptNumber_local;
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  SPIHelper::notUsingInterrupt(&this->_helper,interruptNumber);
  return;
}



// DWARF original prototype: void attachInterrupt(SPIClassRP2040 * this)

void __thiscall SPIClassRP2040::attachInterrupt(SPIClassRP2040 *this)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: void detachInterrupt(SPIClassRP2040 * this)

void __thiscall SPIClassRP2040::detachInterrupt(SPIClassRP2040 *this)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: void HardwareSPI(HardwareSPI * this)

void __thiscall arduino::HardwareSPI::HardwareSPI(HardwareSPI *this)

{
  HardwareSPI *this_local;
  
  gp = &__global_pointer_;
  this->_vptr_HardwareSPI = (_func_int_varargs **)0x100235c0;
  return;
}



// DWARF original prototype: void SPIClassRP2040(SPIClassRP2040 * this, spi_inst_t * spi, pin_size_t
// rx, pin_size_t cs, pin_size_t sck, pin_size_t tx)

void __thiscall
SPIClassRP2040::SPIClassRP2040
          (SPIClassRP2040 *this,spi_inst_t *spi,pin_size_t rx,pin_size_t cs,pin_size_t sck,
          pin_size_t tx)

{
  pin_size_t tx_local;
  pin_size_t sck_local;
  pin_size_t cs_local;
  pin_size_t rx_local;
  spi_inst_t *spi_local;
  SPIClassRP2040 *this_local;
  SPISettings local_1c;
  
  gp = &__global_pointer_;
  arduino::HardwareSPI::HardwareSPI(&this->super_HardwareSPI);
  (this->super_HardwareSPI)._vptr_HardwareSPI = (_func_int_varargs **)&PTR__SPIClassRP2040_10023580;
  arduino::SPISettings::SPISettings(&this->_spis);
  this->_dmaBuffer = (uint8_t *)0x0;
  SPIHelper::SPIHelper(&this->_helper);
  this->_spi = spi;
  this->_running = false;
  this->_initted = false;
  arduino::SPISettings::SPISettings(&local_1c,0,LSBFIRST,SPI_MODE0);
  (this->_spis).clockFreq = local_1c.clockFreq;
  (this->_spis).dataMode = local_1c.dataMode;
  (this->_spis).bitOrder = local_1c.bitOrder;
  this->_RX = rx;
  this->_TX = tx;
  this->_SCK = sck;
  this->_CS = cs;
  return;
}



// DWARF original prototype: byte transfer(SPIClassRP2040 * this, uint8_t data)

byte __thiscall SPIClassRP2040::transfer(SPIClassRP2040 *this,uint8_t data)

{
  BitOrder BVar1;
  uint8_t local_35;
  SPIClassRP2040 *pSStack_34;
  uint8_t data_local;
  SPIClassRP2040 *this_local;
  uint8_t local_25;
  uint uStack_24;
  uint8_t ret;
  spi_hw_t *local_20;
  undefined4 local_1c;
  undefined4 local_18;
  spi_hw_t *local_14;
  
  gp = &__global_pointer_;
  if (this->_initted == true) {
    local_35 = data;
    pSStack_34 = this;
    BVar1 = arduino::SPISettings::getBitOrder(&this->_spis);
    if (BVar1 != MSBFIRST) {
      local_35 = SPIHelper::reverseByte(&pSStack_34->_helper,local_35);
    }
    local_20 = spi_get_hw(pSStack_34->_spi);
    local_18 = 7;
    local_1c = 0xf;
    uStack_24 = (local_20->cr0 ^ 7) & 0xf;
    local_20[0x66].cpsr = uStack_24;
    local_14 = local_20;
    spi_write_read_blocking(pSStack_34->_spi,&local_35,&local_25,1);
    BVar1 = arduino::SPISettings::getBitOrder(&pSStack_34->_spis);
    if (BVar1 != MSBFIRST) {
      local_25 = SPIHelper::reverseByte(&pSStack_34->_helper,local_25);
    }
  }
  else {
    local_25 = '\0';
  }
  return local_25;
}



// DWARF original prototype: uint16_t transfer16(SPIClassRP2040 * this, uint16_t data)

uint16_t __thiscall SPIClassRP2040::transfer16(SPIClassRP2040 *this,uint16_t data)

{
  BitOrder BVar1;
  uint16_t local_36;
  SPIClassRP2040 *pSStack_34;
  uint16_t data_local;
  SPIClassRP2040 *this_local;
  uint16_t local_26;
  uint uStack_24;
  uint16_t ret;
  spi_hw_t *local_20;
  undefined4 local_1c;
  undefined4 local_18;
  spi_hw_t *local_14;
  
  gp = &__global_pointer_;
  if (this->_initted == true) {
    local_36 = data;
    pSStack_34 = this;
    BVar1 = arduino::SPISettings::getBitOrder(&this->_spis);
    if (BVar1 != MSBFIRST) {
      local_36 = SPIHelper::reverse16Bit(&pSStack_34->_helper,local_36);
    }
    local_20 = spi_get_hw(pSStack_34->_spi);
    local_18 = 0xf;
    local_1c = 0xf;
    uStack_24 = (local_20->cr0 ^ 0xf) & 0xf;
    local_20[0x66].cpsr = uStack_24;
    local_14 = local_20;
    spi_write16_read16_blocking(pSStack_34->_spi,&local_36,&local_26,1);
    BVar1 = arduino::SPISettings::getBitOrder(&pSStack_34->_spis);
    if (BVar1 != MSBFIRST) {
      local_26 = SPIHelper::reverse16Bit(&pSStack_34->_helper,local_26);
    }
  }
  else {
    local_26 = 0;
  }
  return local_26;
}



// DWARF original prototype: void transfer(SPIClassRP2040 * this, void * buf, size_t count)

void __thiscall SPIClassRP2040::transfer(SPIClassRP2040 *this,void *buf,size_t count)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  size_t count_local;
  void *buf_local;
  SPIClassRP2040 *this_local;
  uint local_18;
  size_t i;
  uint8_t *buff;
  
  gp = &__global_pointer_;
  i = (size_t)buf;
  for (local_18 = 0; local_18 < count; local_18 = local_18 + 1) {
    p_Var2 = (this->super_HardwareSPI)._vptr_HardwareSPI[2];
    iVar1 = (*p_Var2)((uint)*(byte *)i,p_Var2);
    *(char *)i = (char)iVar1;
    i = i + 1;
  }
  return;
}



// DWARF original prototype: void transfer(SPIClassRP2040 * this, void * txbuf, void * rxbuf, size_t
// count)

void __thiscall SPIClassRP2040::transfer(SPIClassRP2040 *this,void *txbuf,void *rxbuf,size_t count)

{
  uint8_t uVar1;
  spi_hw_t *psVar2;
  BitOrder BVar3;
  int iVar4;
  _func_int_varargs *p_Var5;
  size_t count_local;
  void *rxbuf_local;
  void *txbuf_local;
  SPIClassRP2040 *this_local;
  uint local_1c;
  size_t i;
  uint8_t *rxbuff;
  uint8_t *txbuff;
  
  gp = &__global_pointer_;
  if (this->_initted == true) {
    psVar2 = spi_get_hw(this->_spi);
    psVar2[0x66].cpsr = (psVar2->cr0 ^ 7) & 0xf;
    BVar3 = arduino::SPISettings::getBitOrder(&this->_spis);
    if (BVar3 == MSBFIRST) {
      if (rxbuf == (void *)0x0) {
        spi_write_blocking(this->_spi,(uint8_t *)txbuf,count);
      }
      else if (txbuf == (void *)0x0) {
        spi_read_blocking(this->_spi,0xff,(uint8_t *)rxbuf,count);
      }
      else {
        spi_write_read_blocking(this->_spi,(uint8_t *)txbuf,(uint8_t *)rxbuf,count);
      }
    }
    else {
      i = (size_t)rxbuf;
      rxbuff = (uint8_t *)txbuf;
      for (local_1c = 0; local_1c < count; local_1c = local_1c + 1) {
        p_Var5 = (this->super_HardwareSPI)._vptr_HardwareSPI[2];
        iVar4 = (*p_Var5)((uint)*rxbuff,p_Var5);
        *(char *)i = (char)iVar4;
        BVar3 = arduino::SPISettings::getBitOrder(&this->_spis);
        if (BVar3 == MSBFIRST) {
          uVar1 = *(uint8_t *)i;
        }
        else {
          uVar1 = SPIHelper::reverseByte(&this->_helper,*(uint8_t *)i);
        }
        *(uint8_t *)i = uVar1;
        rxbuff = rxbuff + 1;
        i = i + 1;
      }
    }
  }
  return;
}



// WARNING: Variable defined which should be unmapped: this_local
// DWARF original prototype: void beginTransaction(SPIClassRP2040 * this, SPISettings * settings)

void __thiscall SPIClassRP2040::beginTransaction(SPIClassRP2040 *this,SPISettings *settings)

{
  bool bVar1;
  undefined3 extraout_var;
  uint32_t uVar2;
  uint32_t uVar3;
  spi_cpol_t cpol;
  spi_cpha_t cpha;
  spi_inst_t *psVar4;
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  if ((this->_initted == false) ||
     (bVar1 = arduino::SPISettings::operator==(settings,&this->_spis),
     CONCAT31(extraout_var,bVar1) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    uVar2 = arduino::SPISettings::getClockFreq(settings);
    uVar3 = arduino::SPISettings::getClockFreq(&this->_spis);
    if (uVar2 != uVar3) {
      if (this->_initted != false) {
        spi_deinit(this->_spi);
      }
      psVar4 = this->_spi;
      uVar2 = arduino::SPISettings::getClockFreq(settings);
      spi_init(psVar4,uVar2);
    }
    (this->_spis).clockFreq = settings->clockFreq;
    (this->_spis).dataMode = settings->dataMode;
    (this->_spis).bitOrder = settings->bitOrder;
    psVar4 = this->_spi;
    cpol = SPIHelper::cpol(&this->_helper,&this->_spis);
    cpha = SPIHelper::cpha(&this->_helper,&this->_spis);
    spi_set_format(psVar4,8,cpol,cpha,SPI_MSB_FIRST);
    this->_initted = true;
  }
  SPIHelper::maskInterrupts(&this->_helper);
  return;
}



// DWARF original prototype: void endTransaction(SPIClassRP2040 * this)

void __thiscall SPIClassRP2040::endTransaction(SPIClassRP2040 *this)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  SPIHelper::unmaskInterrupts(&this->_helper);
  return;
}



// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names
// DWARF original prototype: void begin(SPIClassRP2040 * this, bool hwCS)

void __thiscall SPIClassRP2040::begin(SPIClassRP2040 *this,bool hwCS)

{
  int iVar1;
  uint uVar2;
  _func_int_varargs *p_Var3;
  uint32_t local_30;
  SPIMode local_2c;
  BitOrder local_28;
  bool local_15;
  SPIClassRP2040 *pSStack_14;
  bool hwCS_local;
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  local_15 = hwCS;
  pSStack_14 = this;
  if ((this->_RX == 0xff) && (this->_TX == 0xff)) {
    uVar2 = spi_get_index(this->_spi);
    if (uVar2 == 0) {
      iVar1 = 0x4e4;
    }
    else {
      iVar1 = 0x200;
    }
                    // WARNING: Subroutine does not return
    panic("SPI%s: TX and RX assigned to NOPIN",iVar1 + 0x10022000);
  }
  if (this->_RX != 0xff) {
    gpio_set_function((uint)this->_RX,GPIO_FUNC_SPI);
  }
  pSStack_14->_hwCS = local_15;
  if (local_15 != false) {
    gpio_set_function((uint)pSStack_14->_CS,GPIO_FUNC_SPI);
  }
  gpio_set_function((uint)pSStack_14->_SCK,GPIO_FUNC_SPI);
  if (pSStack_14->_TX != 0xff) {
    gpio_set_function((uint)pSStack_14->_TX,GPIO_FUNC_SPI);
  }
  p_Var3 = (pSStack_14->super_HardwareSPI)._vptr_HardwareSPI[8];
  local_30 = (pSStack_14->_spis).clockFreq;
  local_2c = (pSStack_14->_spis).dataMode;
  local_28 = (pSStack_14->_spis).bitOrder;
  (*p_Var3)(&local_30,p_Var3);
  p_Var3 = (pSStack_14->super_HardwareSPI)._vptr_HardwareSPI[9];
  (*p_Var3)(p_Var3);
  return;
}



// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names
// DWARF original prototype: void end(SPIClassRP2040 * this)

void __thiscall SPIClassRP2040::end(SPIClassRP2040 *this)

{
  SPIClassRP2040 *this_local;
  SPISettings local_1c;
  
  gp = &__global_pointer_;
  if (this->_initted != false) {
    this->_initted = false;
    spi_deinit(this->_spi);
  }
  if (this->_RX != 0xff) {
    gpio_set_function((uint)this->_RX,GPIO_FUNC_SIO);
  }
  if (this->_hwCS != false) {
    gpio_set_function((uint)this->_CS,GPIO_FUNC_SIO);
  }
  gpio_set_function((uint)this->_SCK,GPIO_FUNC_SIO);
  if (this->_TX != 0xff) {
    gpio_set_function((uint)this->_TX,GPIO_FUNC_SIO);
  }
  arduino::SPISettings::SPISettings(&local_1c,0,LSBFIRST,SPI_MODE0);
  (this->_spis).clockFreq = local_1c.clockFreq;
  (this->_spis).dataMode = local_1c.dataMode;
  (this->_spis).bitOrder = local_1c.bitOrder;
  return;
}



// DWARF original prototype: void _Rb_tree_impl(_Rb_tree_impl<std::less<int>,_true> * this)

void __thiscall std::_Rb_tree<>::_Rb_tree_impl<>::_Rb_tree_impl(_Rb_tree_impl<> *this)

{
  _Rb_tree_impl<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree_key_compare<>::_Rb_tree_key_compare((_Rb_tree_key_compare<> *)this);
  _Rb_tree_header::_Rb_tree_header(&this->super__Rb_tree_header);
  return;
}



// DWARF original prototype: void
// ~_Rb_tree(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, int __in_chrg)

void __thiscall std::_Rb_tree<>::~_Rb_tree(_Rb_tree<> *this,int __in_chrg)

{
  _Link_type __x;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  __x = _M_begin(this);
  _M_erase(this,__x);
  _Rb_tree_impl<>::~_Rb_tree_impl(&this->_M_impl,(int)__x);
  return;
}



// DWARF original prototype: bool
// empty(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this)

bool __thiscall std::map<>::empty(map<> *this)

{
  bool bVar1;
  map<> *this_local;
  
  gp = &__global_pointer_;
  bVar1 = _Rb_tree<>::empty(&this->_M_t);
  return bVar1;
}



// DWARF original prototype: iterator
// begin(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this)

iterator __thiscall std::map<>::begin(map<> *this)

{
  iterator iVar1;
  map<> *this_local;
  
  gp = &__global_pointer_;
  iVar1 = _Rb_tree<>::begin(&this->_M_t);
  return (iterator)iVar1._M_node;
}



// DWARF original prototype: iterator
// end(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this)

iterator __thiscall std::map<>::end(map<> *this)

{
  iterator iVar1;
  map<> *this_local;
  
  gp = &__global_pointer_;
  iVar1 = _Rb_tree<>::end(&this->_M_t);
  return (iterator)iVar1._M_node;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator!=(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node != __y->_M_node;
}



// DWARF original prototype: _Self * operator++(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this)

_Self * __thiscall std::_Rb_tree_iterator<>::operator++(_Rb_tree_iterator<> *this)

{
  _Rb_tree_node_base *p_Var1;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = _Rb_tree_increment(this->_M_node);
  this->_M_node = p_Var1;
  return this;
}



// DWARF original prototype: reference operator*(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this)

reference __thiscall std::_Rb_tree_iterator<>::operator*(_Rb_tree_iterator<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = _Rb_tree_node<>::_M_valptr((_Rb_tree_node<> *)this->_M_node);
  return ppVar1;
}



// DWARF original name: insert_or_assign<long unsigned int&>
// DWARF original prototype: pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// insert_or_assign<long_unsigned_int&>(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, key_type * __k, ulong * __obj)

_Base_ptr __thiscall std::map<>::insert_or_assign<>(map<> *this,key_type *__k,ulong *__obj)

{
  bool bVar1;
  undefined3 extraout_var;
  reference ppVar2;
  undefined3 extraout_var_00;
  ulong *puVar3;
  ulong uVar4;
  ulong *__obj_local;
  key_type *__k_local;
  map<> *this_local;
  _Self local_58;
  iterator __i;
  less<int> alStack_50 [4];
  const_iterator local_4c [3];
  _Base_ptr local_40;
  pair<> local_38;
  bool local_2d;
  pair<> local_2c;
  bool local_21 [13];
  
  gp = &__global_pointer_;
  local_58._M_node = (_Base_ptr)lower_bound(this,__k);
  __i = end(this);
  bVar1 = operator==(&local_58,&__i);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    key_comp(this);
    ppVar2 = _Rb_tree_iterator<>::operator*(&local_58);
    bVar1 = less<int>::operator()(alStack_50,__k,&ppVar2->first);
    if (CONCAT31(extraout_var_00,bVar1) == 0) {
      bVar1 = false;
      goto LAB_1000ad06;
    }
  }
  bVar1 = true;
LAB_1000ad06:
  if (bVar1) {
    _Rb_tree_const_iterator<>::_Rb_tree_const_iterator(local_4c,&local_58);
    forward_as_tuple<int_const&>();
    forward<>(__obj);
    forward_as_tuple<>();
    local_58._M_node = (_Base_ptr)emplace_hint<>(this,local_4c[0]);
    local_2d = true;
    pair<>::pair<>(&local_38,&local_58,&local_2d);
    local_40 = local_38.first._M_node;
  }
  else {
    puVar3 = forward<>(__obj);
    uVar4 = *puVar3;
    ppVar2 = _Rb_tree_iterator<>::operator*(&local_58);
    ppVar2->second = uVar4;
    local_21[0] = false;
    pair<>::pair<>(&local_2c,&local_58,local_21);
    local_40 = local_2c.first._M_node;
  }
  return local_40;
}



// DWARF original name: pair<int&, int>
// DWARF original prototype: void pair<int&,_int>(pair<int_const,_int> * this, int * __x, int * __y)

void __thiscall std::pair<>::pair<int&,_int>(pair<> *this,int *__x,int *__y)

{
  int *piVar1;
  int *__y_local;
  int *__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  piVar1 = forward<int&>(__x);
  this->first = *piVar1;
  piVar1 = forward<int>(__y);
  this->second = *piVar1;
  return;
}



// DWARF original prototype: pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// insert(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this,
// value_type * __x)

undefined4 __thiscall std::map<>::insert(map<> *this,value_type *__x)

{
  type *__v;
  undefined4 uVar1;
  value_type *__x_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  __v = move<>(__x);
  uVar1 = _Rb_tree<>::_M_insert_unique<>(&this->_M_t,__v);
  return uVar1;
}



// DWARF original prototype: size_type
// erase(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this, key_type
// * __x)

size_type __thiscall std::map<>::erase(map<> *this,key_type *__x)

{
  size_type sVar1;
  key_type *__x_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  sVar1 = _Rb_tree<>::erase(&this->_M_t,__x);
  return sVar1;
}



// DWARF original prototype: void _Rb_tree_key_compare(_Rb_tree_key_compare<std::less<int>_> * this)

void __thiscall std::_Rb_tree_key_compare<>::_Rb_tree_key_compare(_Rb_tree_key_compare<> *this)

{
  _Rb_tree_key_compare<> *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: void
// ~__new_allocator(__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> * this, int
// __in_chrg)

void __thiscall std::__new_allocator<>::~__new_allocator(__new_allocator<> *this,int __in_chrg)

{
  __new_allocator<> *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: void
// _M_erase(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __x)

void __thiscall std::_Rb_tree<>::_M_erase(_Rb_tree<> *this,_Link_type __x)

{
  _Link_type p_Var1;
  _Link_type local_28;
  _Link_type __x_local;
  _Rb_tree<> *this_local;
  _Link_type __y;
  
  gp = &__global_pointer_;
  local_28 = __x;
  while (local_28 != (_Link_type)0x0) {
    p_Var1 = _S_right(&local_28->super__Rb_tree_node_base);
    _M_erase(this,p_Var1);
    p_Var1 = _S_left(&local_28->super__Rb_tree_node_base);
    _M_drop_node(this,local_28);
    local_28 = p_Var1;
  }
  return;
}



// DWARF original prototype: _Link_type
// _M_begin(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_begin(_Rb_tree<> *this)

{
  _Link_type p_Var1;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = _M_mbegin(this);
  return p_Var1;
}



// DWARF original prototype: bool
// empty(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

bool __thiscall std::_Rb_tree<>::empty(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (this->_M_impl).super__Rb_tree_header._M_node_count == 0;
}



// DWARF original prototype: iterator
// begin(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

iterator __thiscall std::_Rb_tree<>::begin(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_14 [3];
  
  gp = &__global_pointer_;
  _Rb_tree_iterator<>::_Rb_tree_iterator
            (local_14,(this->_M_impl).super__Rb_tree_header._M_header._M_left);
  return (iterator)local_14[0]._M_node;
}



// DWARF original prototype: iterator
// end(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

iterator __thiscall std::_Rb_tree<>::end(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_14 [3];
  
  gp = &__global_pointer_;
  _Rb_tree_iterator<>::_Rb_tree_iterator(local_14,&(this->_M_impl).super__Rb_tree_header._M_header);
  return (iterator)local_14[0]._M_node;
}



// DWARF original prototype: pair<int_const,_int> *
// _M_valptr(_Rb_tree_node<std::pair<int_const,_int>_> * this)

pair<> * __thiscall std::_Rb_tree_node<>::_M_valptr(_Rb_tree_node<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_node<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = __gnu_cxx::__aligned_membuf<>::_M_ptr(&this->_M_storage);
  return ppVar1;
}



// DWARF original prototype: iterator
// lower_bound(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this,
// key_type * __x)

iterator __thiscall std::map<>::lower_bound(map<> *this,key_type *__x)

{
  iterator iVar1;
  key_type *__x_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  iVar1 = _Rb_tree<>::lower_bound(&this->_M_t,__x);
  return (iterator)iVar1._M_node;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator==(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node == __y->_M_node;
}



// DWARF original prototype: key_compare
// key_comp(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_> * this)

void __thiscall std::map<>::key_comp(map<> *this)

{
  map<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree<>::key_comp(&this->_M_t);
  return;
}



// DWARF original prototype: bool operator()(less<int> * this, int * __x, int * __y)

bool __thiscall std::less<int>::operator()(less<int> *this,int *__x,int *__y)

{
  int *__y_local;
  int *__x_local;
  less<int> *this_local;
  
  gp = &__global_pointer_;
  return *__x < *__y;
}



// WARNING: Unknown calling convention
// DWARF original name: forward_as_tuple<int const&>

tuple<int_const&> std::forward_as_tuple<int_const&>(void)

{
  _Tuple_impl<> in_a0;
  int *__elements_0;
  type *in_a1;
  
  gp = &__global_pointer_;
  __elements_0 = forward<int_const&>(in_a1);
  tuple<int_const&>::tuple<>
            ((tuple<int_const&> *)in_a0.super__Head_base<0,_int_const&,_false>._M_head_impl,
             __elements_0);
  return (tuple<int_const&>)in_a0.super__Head_base<0,_int_const&,_false>._M_head_impl;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<long unsigned int&>

ulong * std::forward<>(type_conflict *__t)

{
  type_conflict *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention
// DWARF original name: forward_as_tuple<long unsigned int&>

tuple<> std::forward_as_tuple<>(void)

{
  _Tuple_impl<> in_a0;
  ulong *__elements_0;
  type_conflict *in_a1;
  
  gp = &__global_pointer_;
  __elements_0 = forward<>(in_a1);
  tuple<>::tuple<>((tuple<> *)in_a0.super__Head_base<0,_long_unsigned_int&,_false>._M_head_impl,
                   __elements_0);
  return (tuple<>)in_a0.super__Head_base<0,_long_unsigned_int&,_false>._M_head_impl;
}



// DWARF original prototype: void
// _Rb_tree_const_iterator(_Rb_tree_const_iterator<std::pair<int_const,_int>_> * this, iterator *
// __it)

void __thiscall
std::_Rb_tree_const_iterator<>::_Rb_tree_const_iterator
          (_Rb_tree_const_iterator<> *this,iterator *__it)

{
  iterator *__it_local;
  _Rb_tree_const_iterator<> *this_local;
  
  gp = &__global_pointer_;
  this->_M_node = __it->_M_node;
  return;
}



// DWARF original name: emplace_hint<const std::piecewise_construct_t&, std::tuple<int const&>,
// std::tuple<long unsigned int&> >
// DWARF original prototype: iterator
// emplace_hint<const_std::piecewise_construct_t&,_std::tuple<int_const&>,_std::tuple<long_unsigned_int&>_>(map<int,_int,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, const_iterator __pos)

iterator __thiscall std::map<>::emplace_hint<>(map<> *this,const_iterator __pos)

{
  iterator iVar1;
  type *in_a2;
  type *in_a3;
  type *in_a4;
  const_iterator __pos_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  forward<>(in_a2);
  forward<>(in_a3);
  forward<>(in_a4);
  iVar1 = _Rb_tree<>::_M_emplace_hint_unique<>(&this->_M_t,(const_iterator)__pos._M_node);
  return (iterator)iVar1._M_node;
}



// DWARF original name: pair<std::_Rb_tree_iterator<std::pair<int const, int> >&, bool>
// DWARF original prototype: void
// pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>&,_bool>(pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// * this, _Rb_tree_iterator<std::pair<int_const,_int>_> * __x, bool * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_iterator<> *__x,bool *__y)

{
  _Rb_tree_iterator<> *p_Var1;
  bool *pbVar2;
  bool *__y_local;
  _Rb_tree_iterator<> *__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = forward<>(__x);
  (this->first)._M_node = p_Var1->_M_node;
  pbVar2 = forward<bool>(__y);
  this->second = *pbVar2;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * std::forward<int&>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * std::forward<int>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: move<std::pair<int const, int>&>

type * std::move<>(pair<> *__t)

{
  pair<> *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original name: _M_insert_unique<std::pair<int const, int> >
// DWARF original prototype: pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// _M_insert_unique<std::pair<int_const,_int>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, pair<int_const,_int> * __v)

_Base_ptr __thiscall std::_Rb_tree<>::_M_insert_unique<>(_Rb_tree<> *this,pair<> *__v)

{
  _Alloc_node __x;
  _Rb_tree_node_base *__p;
  first_type *__k;
  pair<> *__v_00;
  _Rb_tree_node_base *extraout_a1;
  pair<> *__v_local;
  _Rb_tree<> *this_local;
  _Alloc_node _Stack_58;
  _Alloc_node __an;
  pair<> __res;
  _Base_ptr local_48;
  pair<> local_40;
  _Rb_tree_iterator<> local_38;
  bool local_31;
  pair<> local_30;
  _Rb_tree_iterator<> _Stack_28;
  bool local_21 [9];
  
  gp = &__global_pointer_;
  __k = _Select1st<>::operator()((_Select1st<> *)&__res.second,__v);
  __an._M_t = (_Rb_tree<> *)_M_get_insert_unique_pos(this,__k);
  __res.first = extraout_a1;
  if (extraout_a1 == (_Rb_tree_node_base *)0x0) {
    _Rb_tree_iterator<>::_Rb_tree_iterator(&_Stack_28,(_Base_ptr)__an._M_t);
    local_21[0] = false;
    pair<>::pair<>(&local_30,&_Stack_28,local_21);
    local_48 = local_30.first._M_node;
  }
  else {
    _Alloc_node::_Alloc_node(&_Stack_58,this);
    __p = __res.first;
    __x._M_t = __an._M_t;
    __v_00 = forward<>(__v);
    local_38._M_node = (_Base_ptr)_M_insert_<>(this,(_Base_ptr)__x._M_t,__p,__v_00,&_Stack_58);
    local_31 = true;
    pair<>::pair<>(&local_40,&local_38,&local_31);
    local_48 = local_40.first._M_node;
  }
  return local_48;
}



// DWARF original prototype: size_type
// erase(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, int * __x)

size_type __thiscall std::_Rb_tree<>::erase(_Rb_tree<> *this,int *__x)

{
  size_type sVar1;
  _Base_ptr extraout_a1;
  int *__x_local;
  _Rb_tree<> *this_local;
  iterator local_24;
  pair<> __p;
  const_iterator local_18;
  size_type local_14;
  size_type __old_size;
  
  gp = &__global_pointer_;
  local_24._M_node = (_Base_ptr)equal_range(this,__x);
  __p.first._M_node = extraout_a1;
  local_14 = size(this);
  _Rb_tree_const_iterator<>::_Rb_tree_const_iterator
            ((_Rb_tree_const_iterator<> *)&__p.second,&local_24);
  _Rb_tree_const_iterator<>::_Rb_tree_const_iterator(&local_18,&__p.first);
  _M_erase_aux(this,(const_iterator)__p.second._M_node,local_18);
  sVar1 = size(this);
  return local_14 - sVar1;
}



_Link_type std::_Rb_tree<>::_S_right(_Base_ptr __x)

{
  _Base_ptr __x_local;
  
  gp = &__global_pointer_;
  return (_Link_type)__x->_M_right;
}



_Link_type std::_Rb_tree<>::_S_left(_Base_ptr __x)

{
  _Base_ptr __x_local;
  
  gp = &__global_pointer_;
  return (_Link_type)__x->_M_left;
}



// DWARF original prototype: void
// _M_drop_node(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __p)

void __thiscall std::_Rb_tree<>::_M_drop_node(_Rb_tree<> *this,_Link_type __p)

{
  _Link_type __p_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  _M_destroy_node(this,__p);
  _M_put_node(this,__p);
  return;
}



// DWARF original prototype: _Link_type
// _M_mbegin(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_mbegin(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (_Link_type)(this->_M_impl).super__Rb_tree_header._M_header._M_parent;
}



// DWARF original prototype: void _Rb_tree_iterator(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this, _Base_ptr __x)

void __thiscall std::_Rb_tree_iterator<>::_Rb_tree_iterator(_Rb_tree_iterator<> *this,_Base_ptr __x)

{
  _Base_ptr __x_local;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  this->_M_node = __x;
  return;
}



// DWARF original prototype: pair<int_const,_int> *
// _M_ptr(__aligned_membuf<std::pair<int_const,_int>_> * this)

pair<> * __thiscall __gnu_cxx::__aligned_membuf<>::_M_ptr(__aligned_membuf<> *this)

{
  pair<> *ppVar1;
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = (pair<> *)_M_addr(this);
  return ppVar1;
}



// DWARF original prototype: iterator
// lower_bound(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, key_type * __k)

iterator __thiscall std::_Rb_tree<>::lower_bound(_Rb_tree<> *this,key_type *__k)

{
  _Link_type __x;
  _Base_ptr __y;
  iterator iVar1;
  key_type *__k_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  __x = _M_begin(this);
  __y = _M_end(this);
  iVar1 = _M_lower_bound(this,__x,__y,__k);
  return (iterator)iVar1._M_node;
}



// DWARF original prototype: less<int>
// key_comp(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

void __thiscall std::_Rb_tree<>::key_comp(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<int const&>

int * std::forward<int_const&>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original prototype: void tuple<>(tuple<int_const&> * this, int * __elements#0)

void __thiscall std::tuple<int_const&>::tuple<>(tuple<int_const&> *this,int *__elements_0)

{
  int *__elements_0_local;
  tuple<int_const&> *this_local;
  
  gp = &__global_pointer_;
  _Tuple_impl<>::_Tuple_impl(&this->super__Tuple_impl<0,_int_const&>,__elements_0);
  return;
}



// DWARF original prototype: void tuple<>(tuple<long_unsigned_int&> * this, ulong * __elements#0)

void __thiscall std::tuple<>::tuple<>(tuple<> *this,ulong *__elements_0)

{
  ulong *__elements_0_local;
  tuple<> *this_local;
  
  gp = &__global_pointer_;
  _Tuple_impl<>::_Tuple_impl(&this->super__Tuple_impl<0,_long_unsigned_int&>,__elements_0);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<const std::piecewise_construct_t&>

piecewise_construct_t * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::tuple<int const&> >

tuple<int_const&> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::tuple<long unsigned int&> >

tuple<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original name: _M_emplace_hint_unique<const std::piecewise_construct_t&, std::tuple<int
// const&>, std::tuple<long unsigned int&> >
// DWARF original prototype: iterator
// _M_emplace_hint_unique<const_std::piecewise_construct_t&,_std::tuple<int_const&>,_std::tuple<long_unsigned_int&>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, const_iterator __pos)

iterator __thiscall std::_Rb_tree<>::_M_emplace_hint_unique<>(_Rb_tree<> *this,const_iterator __pos)

{
  int *__k;
  _Base_ptr __x;
  iterator iVar1;
  _Rb_tree_node_base *extraout_a1;
  type *in_a2;
  type *in_a3;
  type *in_a4;
  const_iterator __pos_local;
  _Rb_tree<> *this_local;
  pair<> __res;
  _Auto_node __z;
  
  gp = &__global_pointer_;
  forward<>(in_a2);
  forward<>(in_a3);
  forward<>(in_a4);
  _Auto_node::_Auto_node<>((_Auto_node *)&__res.second,this);
  __k = _Auto_node::_M_key((_Auto_node *)&__res.second);
  __x = (_Base_ptr)_M_get_insert_hint_unique_pos(this,__pos,__k);
  __res.first = extraout_a1;
  if (extraout_a1 == (_Rb_tree_node_base *)0x0) {
    _Rb_tree_iterator<>::_Rb_tree_iterator((_Rb_tree_iterator<> *)&__z._M_node,__x);
    iVar1._M_node = &(__z._M_node)->super__Rb_tree_node_base;
  }
  else {
    iVar1 = _Auto_node::_M_insert((_Auto_node *)&__res.second,pRam00000010);
  }
  _Auto_node::~_Auto_node((_Auto_node *)&__res.second,(int)__x);
  return (iterator)iVar1._M_node;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::_Rb_tree_iterator<std::pair<int const, int> >&>

_Rb_tree_iterator<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool * std::forward<bool>(type_conflict1 *__t)

{
  type_conflict1 *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original prototype: pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// _M_get_insert_unique_pos(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, key_type * __k)

_Rb_tree_node_base * __thiscall
std::_Rb_tree<>::_M_get_insert_unique_pos(_Rb_tree<> *this,key_type *__k)

{
  bool bVar1;
  undefined3 extraout_var;
  int *piVar2;
  undefined3 extraout_var_00;
  key_type *__k_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_58;
  iterator __j;
  _Base_ptr __y;
  _Link_type __x;
  _Rb_tree_node_base *local_48;
  pair<> local_40;
  pair<> local_38;
  pair<> local_30;
  _Rb_tree_node_base *local_28;
  char local_21;
  bool __comp;
  
  gp = &__global_pointer_;
  __y = &_M_begin(this)->super__Rb_tree_node_base;
  __j._M_node = _M_end(this);
  local_21 = '\x01';
  while (__y != (_Base_ptr)0x0) {
    __j._M_node = __y;
    piVar2 = _S_key((_Const_Link_type)__y);
    local_21 = less<int>::operator()((less<int> *)this,__k,piVar2);
    if ((bool)local_21) {
      __y = &_S_left(__y)->super__Rb_tree_node_base;
    }
    else {
      __y = &_S_right(__y)->super__Rb_tree_node_base;
    }
  }
  _Rb_tree_iterator<>::_Rb_tree_iterator(&local_58,__j._M_node);
  if (local_21 != '\0') {
    __x = (_Link_type)begin(this);
    bVar1 = operator==(&local_58,(_Self *)&__x);
    if (CONCAT31(extraout_var,bVar1) != 0) {
      pair<>::pair<>(&local_40,(_Rb_tree_node<> **)&__y,&__j._M_node);
      return local_40.first;
    }
    _Rb_tree_iterator<>::operator--(&local_58);
  }
  piVar2 = _S_key(local_58._M_node);
  bVar1 = less<int>::operator()((less<int> *)this,piVar2,__k);
  if (CONCAT31(extraout_var_00,bVar1) == 0) {
    local_28 = (_Rb_tree_node_base *)0x0;
    pair<>::pair<>(&local_30,&local_58._M_node,&local_28);
    local_48 = local_30.first;
  }
  else {
    pair<>::pair<>(&local_38,(_Rb_tree_node<> **)&__y,&__j._M_node);
    local_48 = local_38.first;
  }
  return local_48;
}



// DWARF original prototype: first_type * operator()(_Select1st<std::pair<int_const,_int>_> * this,
// pair<int_const,_int> * __x)

first_type * __thiscall std::_Select1st<>::operator()(_Select1st<> *this,pair<> *__x)

{
  pair<> *__x_local;
  _Select1st<> *this_local;
  
  gp = &__global_pointer_;
  return &__x->first;
}



// DWARF original prototype: void _Alloc_node(_Alloc_node * this,
// _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * __t)

void __thiscall std::_Rb_tree<>::_Alloc_node::_Alloc_node(_Alloc_node *this,_Rb_tree<> *__t)

{
  _Rb_tree<> *__t_local;
  _Alloc_node *this_local;
  
  gp = &__global_pointer_;
  this->_M_t = __t;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::pair<int const, int> >

pair<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Variable defined which should be unmapped: __insert_left
// DWARF original name: _M_insert_<std::pair<int const, int>, std::_Rb_tree<int, std::pair<int
// const, int>, std::_Select1st<std::pair<int const, int> >, std::less<int>,
// std::allocator<std::pair<int const, int> > >::_Alloc_node>
// DWARF original prototype: iterator
// _M_insert_<std::pair<int_const,_int>,_std::_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>::_Alloc_node>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Base_ptr __x, _Base_ptr __p, pair<int_const,_int> * __v, _Alloc_node * __node_gen)

iterator __thiscall
std::_Rb_tree<>::_M_insert_<>
          (_Rb_tree<> *this,_Base_ptr __x,_Base_ptr __p,pair<> *__v,_Alloc_node *__node_gen)

{
  bool bVar1;
  _Base_ptr p_Var2;
  first_type *__x_00;
  int *__y;
  undefined3 extraout_var;
  pair<> *__arg;
  _Alloc_node *__node_gen_local;
  pair<> *__v_local;
  _Base_ptr __p_local;
  _Base_ptr __x_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_1c;
  _Link_type local_18;
  _Link_type __z;
  bool __insert_left;
  
  gp = &__global_pointer_;
  if ((__x == (_Base_ptr)0x0) && (p_Var2 = _M_end(this), __p != p_Var2)) {
    __x_00 = _Select1st<>::operator()((_Select1st<> *)&this_local,__v);
    __y = _S_key(__p);
    bVar1 = less<int>::operator()((less<int> *)this,__x_00,__y);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      __z._3_1_ = 0;
      goto LAB_1000b8a8;
    }
  }
  __z._3_1_ = 1;
LAB_1000b8a8:
  __arg = forward<>(__v);
  local_18 = _Alloc_node::operator()<>(__node_gen,__arg);
  _Rb_tree_insert_and_rebalance
            ((bool)__z._3_1_,&local_18->super__Rb_tree_node_base,__p,
             &(this->_M_impl).super__Rb_tree_header._M_header);
  (this->_M_impl).super__Rb_tree_header._M_node_count =
       (this->_M_impl).super__Rb_tree_header._M_node_count + 1;
  _Rb_tree_iterator<>::_Rb_tree_iterator(&local_1c,&local_18->super__Rb_tree_node_base);
  return (iterator)local_1c._M_node;
}



// DWARF original name: pair<std::_Rb_tree_iterator<std::pair<int const, int> >, bool>
// DWARF original prototype: void
// pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>(pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// * this, _Rb_tree_iterator<std::pair<int_const,_int>_> * __x, bool * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_iterator<> *__x,bool *__y)

{
  _Rb_tree_iterator<> *p_Var1;
  bool *pbVar2;
  bool *__y_local;
  _Rb_tree_iterator<> *__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = forward<>(__x);
  (this->first)._M_node = p_Var1->_M_node;
  pbVar2 = forward<bool>(__y);
  this->second = *pbVar2;
  return;
}



// DWARF original prototype:
// pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>
// equal_range(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, int * __k)

_Base_ptr __thiscall std::_Rb_tree<>::equal_range(_Rb_tree<> *this,int *__k)

{
  bool bVar1;
  int *piVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int *__k_local;
  _Rb_tree<> *this_local;
  pair<> local_50;
  _Rb_tree_iterator<> local_48;
  _Rb_tree_iterator<> local_44;
  pair<> local_40;
  _Rb_tree_iterator<> _Stack_38;
  _Rb_tree_iterator<> _Stack_34;
  _Link_type local_30;
  _Base_ptr __yu;
  _Link_type __xu;
  _Base_ptr __y;
  _Link_type __x;
  
  gp = &__global_pointer_;
  __y = &_M_begin(this)->super__Rb_tree_node_base;
  __xu = (_Link_type)_M_end(this);
  while( true ) {
    while( true ) {
      if (__y == (_Base_ptr)0x0) {
        _Rb_tree_iterator<>::_Rb_tree_iterator(&_Stack_38,&__xu->super__Rb_tree_node_base);
        _Rb_tree_iterator<>::_Rb_tree_iterator(&_Stack_34,&__xu->super__Rb_tree_node_base);
        pair<>::pair<>(&local_40,&_Stack_38,&_Stack_34);
        return local_40.first._M_node;
      }
      piVar2 = _S_key((_Const_Link_type)__y);
      bVar1 = less<int>::operator()((less<int> *)this,piVar2,__k);
      if (CONCAT31(extraout_var,bVar1) == 0) break;
      __y = &_S_right(__y)->super__Rb_tree_node_base;
    }
    piVar2 = _S_key((_Const_Link_type)__y);
    bVar1 = less<int>::operator()((less<int> *)this,__k,piVar2);
    if (CONCAT31(extraout_var_00,bVar1) == 0) break;
    __xu = (_Link_type)__y;
    __y = &_S_left(__y)->super__Rb_tree_node_base;
  }
  __yu = __y;
  local_30 = __xu;
  __xu = (_Link_type)__y;
  __y = &_S_left(__y)->super__Rb_tree_node_base;
  __yu = &_S_right(__yu)->super__Rb_tree_node_base;
  local_48._M_node =
       (_Base_ptr)_M_lower_bound(this,(_Link_type)__y,&__xu->super__Rb_tree_node_base,__k);
  local_44._M_node =
       (_Base_ptr)_M_upper_bound(this,(_Link_type)__yu,&local_30->super__Rb_tree_node_base,__k);
  pair<>::pair<>(&local_50,&local_48,&local_44);
  gp = &__global_pointer_;
  return local_50.first._M_node;
}



// DWARF original prototype: size_type
// size(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

size_type __thiscall std::_Rb_tree<>::size(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (this->_M_impl).super__Rb_tree_header._M_node_count;
}



// DWARF original prototype: void
// _M_erase_aux(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, const_iterator __first, const_iterator __last)

void __thiscall
std::_Rb_tree<>::_M_erase_aux(_Rb_tree<> *this,const_iterator __first,const_iterator __last)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  _Self __position;
  undefined3 extraout_var_01;
  _Self local_2c;
  const_iterator __last_local;
  const_iterator __first_local;
  _Rb_tree<> *this_local;
  iterator local_1c;
  _Rb_tree_const_iterator<> _Stack_18;
  iterator local_14 [3];
  
  gp = &__global_pointer_;
  local_2c._M_node = __last._M_node;
  __last_local = __first;
  local_1c._M_node = (_Base_ptr)begin(this);
  _Rb_tree_const_iterator<>::_Rb_tree_const_iterator
            ((_Rb_tree_const_iterator<> *)&this_local,&local_1c);
  bVar1 = operator==(&__last_local,(_Self *)&this_local);
  if (CONCAT31(extraout_var,bVar1) != 0) {
    local_14[0]._M_node = (_Base_ptr)end(this);
    _Rb_tree_const_iterator<>::_Rb_tree_const_iterator(&_Stack_18,local_14);
    bVar1 = operator==(&local_2c,&_Stack_18);
    if (CONCAT31(extraout_var_00,bVar1) != 0) {
      bVar1 = true;
      goto LAB_1000bb74;
    }
  }
  bVar1 = false;
LAB_1000bb74:
  if (bVar1) {
    clear(this);
  }
  else {
    while (bVar1 = operator!=(&__last_local,&local_2c), CONCAT31(extraout_var_01,bVar1) != 0) {
      __position = _Rb_tree_const_iterator<>::operator++(&__last_local,0);
      _M_erase_aux(this,(const_iterator)__position._M_node);
    }
  }
  return;
}



// DWARF original prototype: void
// _M_destroy_node(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __p)

void __thiscall std::_Rb_tree<>::_M_destroy_node(_Rb_tree<> *this,_Link_type __p)

{
  _Link_type __p_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  _M_get_Node_allocator(this);
  _Rb_tree_node<>::_M_valptr(__p);
  return;
}



// DWARF original prototype: void
// _M_put_node(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __p)

void __thiscall std::_Rb_tree<>::_M_put_node(_Rb_tree<> *this,_Link_type __p)

{
  _Node_allocator *this_00;
  _Link_type __p_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  this_00 = _M_get_Node_allocator(this);
  __new_allocator<>::deallocate((__new_allocator<> *)this_00,__p,1);
  return;
}



// DWARF original prototype: void * _M_addr(__aligned_membuf<std::pair<int_const,_int>_> * this)

void * __thiscall __gnu_cxx::__aligned_membuf<>::_M_addr(__aligned_membuf<> *this)

{
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  return this;
}



// DWARF original prototype: _Base_ptr
// _M_end(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Base_ptr __thiscall std::_Rb_tree<>::_M_end(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return &(this->_M_impl).super__Rb_tree_header._M_header;
}



// DWARF original prototype: iterator
// _M_lower_bound(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __x, _Base_ptr __y, int * __k)

iterator __thiscall
std::_Rb_tree<>::_M_lower_bound(_Rb_tree<> *this,_Link_type __x,_Base_ptr __y,int *__k)

{
  bool bVar1;
  int *__x_00;
  int *__k_local;
  _Base_ptr __y_local;
  _Link_type __x_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_14 [2];
  
  gp = &__global_pointer_;
  __k_local = (int *)__y;
  __y_local = &__x->super__Rb_tree_node_base;
  while (__y_local != (_Base_ptr)0x0) {
    __x_00 = _S_key((_Const_Link_type)__y_local);
    bVar1 = less<int>::operator()((less<int> *)this,__x_00,__k);
    if (bVar1) {
      __y_local = &_S_right(__y_local)->super__Rb_tree_node_base;
    }
    else {
      __k_local = (int *)__y_local;
      __y_local = &_S_left(__y_local)->super__Rb_tree_node_base;
    }
  }
  _Rb_tree_iterator<>::_Rb_tree_iterator(local_14,(_Base_ptr)__k_local);
  return (iterator)local_14[0]._M_node;
}



// DWARF original prototype: void _Tuple_impl(_Tuple_impl<0,_int_const&> * this, int * __head)

void __thiscall std::_Tuple_impl<>::_Tuple_impl(_Tuple_impl<> *this,int *__head)

{
  int *__head_local;
  _Tuple_impl<> *this_local;
  
  gp = &__global_pointer_;
  _Head_base<>::_Head_base(&this->super__Head_base<0,_int_const&,_false>,__head);
  return;
}



// DWARF original prototype: void _Tuple_impl(_Tuple_impl<0,_long_unsigned_int&> * this, ulong *
// __head)

void __thiscall std::_Tuple_impl<>::_Tuple_impl(_Tuple_impl<> *this,ulong *__head)

{
  ulong *__head_local;
  _Tuple_impl<> *this_local;
  
  gp = &__global_pointer_;
  _Head_base<>::_Head_base(&this->super__Head_base<0,_long_unsigned_int&,_false>,__head);
  return;
}



// WARNING: Variable defined which should be unmapped: this_local
// DWARF original name: _Auto_node<const std::piecewise_construct_t&, std::tuple<int const&>,
// std::tuple<long unsigned int&> >
// DWARF original prototype: void
// _Auto_node<const_std::piecewise_construct_t&,_std::tuple<int_const&>,_std::tuple<long_unsigned_int&>_>(_Auto_node
// * this,
// _Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * __t)

void __thiscall std::_Rb_tree<>::_Auto_node::_Auto_node<>(_Auto_node *this,_Rb_tree<> *__t)

{
  _Link_type p_Var1;
  type *in_a2;
  type *in_a3;
  type *in_a4;
  _Rb_tree<> *__t_local;
  _Auto_node *this_local;
  
  gp = &__global_pointer_;
  this->_M_t = __t;
  forward<>(in_a2);
  forward<>(in_a3);
  forward<>(in_a4);
  p_Var1 = _M_create_node<>(__t);
  this->_M_node = p_Var1;
  return;
}



// DWARF original prototype: void ~_Auto_node(_Auto_node * this, int __in_chrg)

void __thiscall std::_Rb_tree<>::_Auto_node::~_Auto_node(_Auto_node *this,int __in_chrg)

{
  _Auto_node *this_local;
  
  gp = &__global_pointer_;
  if (this->_M_node != (_Link_type)0x0) {
    _M_drop_node(this->_M_t,this->_M_node);
  }
  return;
}



// DWARF original prototype: pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// _M_get_insert_hint_unique_pos(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, const_iterator __position, key_type * __k)

_Base_ptr __thiscall
std::_Rb_tree<>::_M_get_insert_hint_unique_pos
          (_Rb_tree<> *this,const_iterator __position,key_type *__k)

{
  const_iterator cVar1;
  iterator iVar2;
  bool bVar3;
  iterator iVar4;
  _Base_ptr p_Var5;
  size_type sVar6;
  _Base_ptr *pp_Var7;
  int *piVar8;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  _Base_ptr *__y;
  _Self *p_Var9;
  undefined3 extraout_var_01;
  _Link_type p_Var10;
  _Base_ptr p_Var11;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  key_type *__k_local;
  const_iterator __position_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_88;
  iterator __after;
  iterator __before;
  iterator __pos;
  pair<> local_74;
  _Rb_tree_node_base *local_6c;
  pair<> local_68;
  pair<> local_60;
  _Rb_tree_node_base *local_58;
  pair<> local_54;
  pair<> local_4c;
  _Rb_tree_node_base *local_44;
  pair<> local_40;
  _Rb_tree_node_base *local_38;
  pair<> local_34;
  pair<> local_2c;
  _Rb_tree_node_base *local_24 [4];
  
  gp = &__global_pointer_;
  __k_local = (key_type *)__position._M_node;
  __position_local._M_node = (_Base_ptr)this;
  iVar4 = _Rb_tree_const_iterator<>::_M_const_cast((_Rb_tree_const_iterator<> *)&__k_local);
  __before._M_node = iVar4._M_node;
  p_Var5 = _M_end((_Rb_tree<> *)__position_local._M_node);
  cVar1 = __position_local;
  if (iVar4._M_node != p_Var5) {
    piVar8 = _S_key(__before._M_node);
    bVar3 = less<int>::operator()((less<int> *)cVar1._M_node,__k,piVar8);
    iVar2 = __before;
    cVar1 = __position_local;
    if (CONCAT31(extraout_var_00,bVar3) != 0) {
      __after = __before;
      pp_Var7 = _M_leftmost((_Rb_tree<> *)__position_local._M_node);
      cVar1 = __position_local;
      if (iVar2._M_node == *pp_Var7) {
        pp_Var7 = _M_leftmost((_Rb_tree<> *)__position_local._M_node);
        __y = _M_leftmost((_Rb_tree<> *)__position_local._M_node);
        pair<>::pair<>(&local_68,pp_Var7,__y);
        gp = &__global_pointer_;
        return local_68.first;
      }
      p_Var9 = _Rb_tree_iterator<>::operator--(&__after);
      piVar8 = _S_key(p_Var9->_M_node);
      bVar3 = less<int>::operator()((less<int> *)cVar1._M_node,piVar8,__k);
      if (CONCAT31(extraout_var_01,bVar3) != 0) {
        p_Var10 = _S_right(__after._M_node);
        if (p_Var10 == (_Link_type)0x0) {
          local_58 = (_Rb_tree_node_base *)0x0;
          pair<>::pair<>(&local_60,&local_58,&__after._M_node);
          gp = &__global_pointer_;
          return local_60.first;
        }
        pair<>::pair<>(&local_54,&__before._M_node,&__before._M_node);
        gp = &__global_pointer_;
        return local_54.first;
      }
      p_Var11 = (_Base_ptr)_M_get_insert_unique_pos((_Rb_tree<> *)__position_local._M_node,__k);
      gp = &__global_pointer_;
      return p_Var11;
    }
    piVar8 = _S_key(__before._M_node);
    bVar3 = less<int>::operator()((less<int> *)cVar1._M_node,piVar8,__k);
    iVar2 = __before;
    if (CONCAT31(extraout_var_02,bVar3) == 0) {
      local_24[0] = (_Rb_tree_node_base *)0x0;
      pair<>::pair<>(&local_2c,&__before._M_node,local_24);
      gp = &__global_pointer_;
      return local_2c.first;
    }
    local_88._M_node = __before._M_node;
    pp_Var7 = _M_rightmost((_Rb_tree<> *)__position_local._M_node);
    cVar1 = __position_local;
    if (iVar2._M_node == *pp_Var7) {
      local_44 = (_Rb_tree_node_base *)0x0;
      pp_Var7 = _M_rightmost((_Rb_tree<> *)__position_local._M_node);
      pair<>::pair<>(&local_4c,&local_44,pp_Var7);
      gp = &__global_pointer_;
      return local_4c.first;
    }
    p_Var9 = _Rb_tree_iterator<>::operator++(&local_88);
    piVar8 = _S_key(p_Var9->_M_node);
    bVar3 = less<int>::operator()((less<int> *)cVar1._M_node,__k,piVar8);
    if (CONCAT31(extraout_var_03,bVar3) == 0) {
      p_Var11 = (_Base_ptr)_M_get_insert_unique_pos((_Rb_tree<> *)__position_local._M_node,__k);
      gp = &__global_pointer_;
      return p_Var11;
    }
    p_Var10 = _S_right(__before._M_node);
    if (p_Var10 == (_Link_type)0x0) {
      local_38 = (_Rb_tree_node_base *)0x0;
      pair<>::pair<>(&local_40,&local_38,&__before._M_node);
      gp = &__global_pointer_;
      return local_40.first;
    }
    pair<>::pair<>(&local_34,&local_88._M_node,&local_88._M_node);
    gp = &__global_pointer_;
    return local_34.first;
  }
  sVar6 = size((_Rb_tree<> *)__position_local._M_node);
  cVar1 = __position_local;
  if (sVar6 != 0) {
    pp_Var7 = _M_rightmost((_Rb_tree<> *)__position_local._M_node);
    piVar8 = _S_key(*pp_Var7);
    bVar3 = less<int>::operator()((less<int> *)cVar1._M_node,piVar8,__k);
    if (CONCAT31(extraout_var,bVar3) != 0) {
      bVar3 = true;
      goto LAB_1000be74;
    }
  }
  bVar3 = false;
LAB_1000be74:
  if (bVar3) {
    local_6c = (_Rb_tree_node_base *)0x0;
    pp_Var7 = _M_rightmost((_Rb_tree<> *)__position_local._M_node);
    pair<>::pair<>(&local_74,&local_6c,pp_Var7);
    __pos._M_node = local_74.first;
  }
  else {
    __pos._M_node = (_Base_ptr)_M_get_insert_unique_pos((_Rb_tree<> *)__position_local._M_node,__k);
  }
  return __pos._M_node;
}



// DWARF original prototype: int * _M_key(_Auto_node * this)

int * __thiscall std::_Rb_tree<>::_Auto_node::_M_key(_Auto_node *this)

{
  int *piVar1;
  _Auto_node *this_local;
  
  gp = &__global_pointer_;
  piVar1 = _S_key(this->_M_node);
  return piVar1;
}



// DWARF original prototype: iterator _M_insert(_Auto_node * this,
// pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> __p)

iterator __thiscall std::_Rb_tree<>::_Auto_node::_M_insert(_Auto_node *this,pair<> __p)

{
  iterator iVar1;
  _Base_ptr in_a1;
  _Base_ptr in_a2;
  pair<> __p_local;
  _Auto_node *this_local;
  _Rb_tree_iterator<> __it;
  
  gp = &__global_pointer_;
  iVar1 = _M_insert_node(this->_M_t,in_a1,in_a2,this->_M_node);
  this->_M_node = (_Link_type)0x0;
  return (iterator)iVar1._M_node;
}



int * std::_Rb_tree<>::_S_key(_Const_Link_type __x)

{
  pair<> *__x_00;
  first_type *pfVar1;
  _Const_Link_type __x_local;
  _Select1st<> a_Stack_14 [12];
  
  gp = &__global_pointer_;
  __x_00 = _Rb_tree_node<>::_M_valptr(__x);
  pfVar1 = _Select1st<>::operator()(a_Stack_14,__x_00);
  return pfVar1;
}



// DWARF original name: pair<std::_Rb_tree_node<std::pair<int const, int> >*&,
// std::_Rb_tree_node_base*&>
// DWARF original prototype: void
// pair<std::_Rb_tree_node<std::pair<int_const,_int>_>*&,_std::_Rb_tree_node_base*&>(pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// * this, _Rb_tree_node<std::pair<int_const,_int>_> * * __x, _Rb_tree_node_base * * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_node<> **__x,_Rb_tree_node_base **__y)

{
  _Rb_tree_node<> **pp_Var1;
  _Rb_tree_node_base **pp_Var2;
  _Rb_tree_node_base **__y_local;
  _Rb_tree_node<> **__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pp_Var1 = forward<>(__x);
  this->first = &(*pp_Var1)->super__Rb_tree_node_base;
  pp_Var2 = forward<>(__y);
  this->second = *pp_Var2;
  return;
}



// DWARF original prototype: _Self * operator--(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this)

_Self * __thiscall std::_Rb_tree_iterator<>::operator--(_Rb_tree_iterator<> *this)

{
  _Rb_tree_node_base *p_Var1;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = _Rb_tree_decrement(this->_M_node);
  this->_M_node = p_Var1;
  return this;
}



int * std::_Rb_tree<>::_S_key(_Const_Base_ptr __x)

{
  int *piVar1;
  _Const_Base_ptr __x_local;
  
  gp = &__global_pointer_;
  piVar1 = _S_key((_Const_Link_type)__x);
  return piVar1;
}



// DWARF original prototype: void pair<>(pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*> *
// this, _Rb_tree_node_base * * __a, _Rb_tree_node_base * * __b)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_node_base **__a,_Rb_tree_node_base **__b)

{
  _Rb_tree_node_base **__b_local;
  _Rb_tree_node_base **__a_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  this->first = *__a;
  this->second = *__b;
  return;
}



// DWARF original name: operator()<std::pair<int const, int> >
// DWARF original prototype: _Link_type operator()<std::pair<int_const,_int>_>(_Alloc_node * this,
// pair<int_const,_int> * __arg)

_Link_type __thiscall std::_Rb_tree<>::_Alloc_node::operator()<>(_Alloc_node *this,pair<> *__arg)

{
  _Rb_tree<> *this_00;
  _Link_type p_Var1;
  pair<> *__arg_local;
  _Alloc_node *this_local;
  
  gp = &__global_pointer_;
  this_00 = this->_M_t;
  forward<>(__arg);
  p_Var1 = _M_create_node<>(this_00);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::_Rb_tree_iterator<std::pair<int const, int> > >

_Rb_tree_iterator<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original prototype: iterator
// _M_upper_bound(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __x, _Base_ptr __y, int * __k)

iterator __thiscall
std::_Rb_tree<>::_M_upper_bound(_Rb_tree<> *this,_Link_type __x,_Base_ptr __y,int *__k)

{
  bool bVar1;
  int *__y_00;
  undefined3 extraout_var;
  int *__k_local;
  _Base_ptr __y_local;
  _Link_type __x_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_14 [2];
  
  gp = &__global_pointer_;
  __k_local = (int *)__y;
  __y_local = &__x->super__Rb_tree_node_base;
  while (__y_local != (_Base_ptr)0x0) {
    __y_00 = _S_key((_Const_Link_type)__y_local);
    bVar1 = less<int>::operator()((less<int> *)this,__k,__y_00);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      __y_local = &_S_right(__y_local)->super__Rb_tree_node_base;
    }
    else {
      __k_local = (int *)__y_local;
      __y_local = &_S_left(__y_local)->super__Rb_tree_node_base;
    }
  }
  _Rb_tree_iterator<>::_Rb_tree_iterator(local_14,(_Base_ptr)__k_local);
  return (iterator)local_14[0]._M_node;
}



// DWARF original name: pair<std::_Rb_tree_iterator<std::pair<int const, int> >,
// std::_Rb_tree_iterator<std::pair<int const, int> > >
// DWARF original prototype: void
// pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>(pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_std::_Rb_tree_iterator<std::pair<int_const,_int>_>_>
// * this, _Rb_tree_iterator<std::pair<int_const,_int>_> * __x,
// _Rb_tree_iterator<std::pair<int_const,_int>_> * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_iterator<> *__x,_Rb_tree_iterator<> *__y)

{
  _Rb_tree_iterator<> *p_Var1;
  _Rb_tree_iterator<> *__y_local;
  _Rb_tree_iterator<> *__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = forward<>(__x);
  (this->first)._M_node = p_Var1->_M_node;
  p_Var1 = forward<>(__y);
  (this->second)._M_node = p_Var1->_M_node;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator==(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node == __y->_M_node;
}



// DWARF original prototype: void
// clear(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

void __thiscall std::_Rb_tree<>::clear(_Rb_tree<> *this)

{
  _Link_type __x;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  __x = _M_begin(this);
  _M_erase(this,__x);
  _Rb_tree_header::_M_reset(&(this->_M_impl).super__Rb_tree_header);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator!=(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node != __y->_M_node;
}



// DWARF original prototype: _Self operator++(_Rb_tree_const_iterator<std::pair<int_const,_int>_> *
// this, int param_1)

_Self __thiscall
std::_Rb_tree_const_iterator<>::operator++(_Rb_tree_const_iterator<> *this,int param_1)

{
  _Base_ptr p_Var1;
  _Base_ptr p_Var2;
  int param_1_local;
  _Rb_tree_const_iterator<> *this_local;
  _Self __tmp;
  
  gp = &__global_pointer_;
  p_Var2 = this->_M_node;
  p_Var1 = (_Base_ptr)_Rb_tree_increment(this->_M_node);
  this->_M_node = p_Var1;
  return (_Self)p_Var2;
}



// DWARF original prototype: void
// _M_erase_aux(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, const_iterator __position)

void __thiscall std::_Rb_tree<>::_M_erase_aux(_Rb_tree<> *this,const_iterator __position)

{
  _Link_type __p;
  const_iterator __position_local;
  _Rb_tree<> *this_local;
  _Link_type __y;
  
  gp = &__global_pointer_;
  __p = (_Link_type)
        _Rb_tree_rebalance_for_erase
                  (__position._M_node,&(this->_M_impl).super__Rb_tree_header._M_header);
  _M_drop_node(this,__p);
  (this->_M_impl).super__Rb_tree_header._M_node_count =
       (this->_M_impl).super__Rb_tree_header._M_node_count - 1;
  return;
}



// DWARF original prototype: _Node_allocator *
// _M_get_Node_allocator(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Node_allocator * __thiscall std::_Rb_tree<>::_M_get_Node_allocator(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (_Node_allocator *)this;
}



// DWARF original prototype: void _Head_base(_Head_base<0,_int_const&,_false> * this, int * __h)

void __thiscall std::_Head_base<>::_Head_base(_Head_base<> *this,int *__h)

{
  int *__h_local;
  _Head_base<> *this_local;
  
  gp = &__global_pointer_;
  this->_M_head_impl = __h;
  return;
}



// DWARF original prototype: void _Head_base(_Head_base<0,_long_unsigned_int&,_false> * this, ulong
// * __h)

void __thiscall std::_Head_base<>::_Head_base(_Head_base<> *this,ulong *__h)

{
  ulong *__h_local;
  _Head_base<> *this_local;
  
  gp = &__global_pointer_;
  this->_M_head_impl = __h;
  return;
}



// WARNING: Variable defined which should be unmapped: __tmp
// DWARF original name: _M_create_node<const std::piecewise_construct_t&, std::tuple<int const&>,
// std::tuple<long unsigned int&> >
// DWARF original prototype: _Link_type
// _M_create_node<const_std::piecewise_construct_t&,_std::tuple<int_const&>,_std::tuple<long_unsigned_int&>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_create_node<>(_Rb_tree<> *this)

{
  _Link_type __node;
  type *in_a1;
  type *in_a2;
  type *in_a3;
  _Rb_tree<> *this_local;
  _Link_type __tmp;
  
  gp = &__global_pointer_;
  __node = _M_get_node(this);
  forward<>(in_a1);
  forward<>(in_a2);
  forward<>(in_a3);
  _M_construct_node<>(this,__node);
  return __node;
}



// DWARF original prototype: iterator
// _M_const_cast(_Rb_tree_const_iterator<std::pair<int_const,_int>_> * this)

iterator __thiscall std::_Rb_tree_const_iterator<>::_M_const_cast(_Rb_tree_const_iterator<> *this)

{
  _Rb_tree_const_iterator<> *this_local;
  _Rb_tree_iterator<> local_14 [3];
  
  gp = &__global_pointer_;
  _Rb_tree_iterator<>::_Rb_tree_iterator(local_14,this->_M_node);
  return (iterator)local_14[0]._M_node;
}



// DWARF original prototype: _Base_ptr *
// _M_rightmost(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Base_ptr * __thiscall std::_Rb_tree<>::_M_rightmost(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return &(this->_M_impl).super__Rb_tree_header._M_header._M_right;
}



// DWARF original prototype: _Base_ptr *
// _M_leftmost(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Base_ptr * __thiscall std::_Rb_tree<>::_M_leftmost(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return &(this->_M_impl).super__Rb_tree_header._M_header._M_left;
}



// DWARF original name: pair<std::_Rb_tree_node_base*&, std::_Rb_tree_node_base*&>
// DWARF original prototype: void
// pair<std::_Rb_tree_node_base*&,_std::_Rb_tree_node_base*&>(pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// * this, _Rb_tree_node_base * * __x, _Rb_tree_node_base * * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_node_base **__x,_Rb_tree_node_base **__y)

{
  _Rb_tree_node_base **pp_Var1;
  _Rb_tree_node_base **__y_local;
  _Rb_tree_node_base **__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pp_Var1 = forward<>(__x);
  this->first = *pp_Var1;
  pp_Var1 = forward<>(__y);
  this->second = *pp_Var1;
  return;
}



// WARNING: Variable defined which should be unmapped: __insert_left
// DWARF original prototype: iterator
// _M_insert_node(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Base_ptr __x, _Base_ptr __p, _Link_type __z)

iterator __thiscall
std::_Rb_tree<>::_M_insert_node(_Rb_tree<> *this,_Base_ptr __x,_Base_ptr __p,_Link_type __z)

{
  bool bVar1;
  _Base_ptr p_Var2;
  int *__x_00;
  int *__y;
  undefined3 extraout_var;
  _Link_type __z_local;
  _Base_ptr __p_local;
  _Base_ptr __x_local;
  _Rb_tree<> *this_local;
  _Rb_tree_iterator<> local_18;
  undefined1 local_11;
  bool __insert_left;
  
  gp = &__global_pointer_;
  if ((__x == (_Base_ptr)0x0) && (p_Var2 = _M_end(this), __p != p_Var2)) {
    __x_00 = _S_key(__z);
    __y = _S_key(__p);
    bVar1 = less<int>::operator()((less<int> *)this,__x_00,__y);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      local_11 = false;
      goto LAB_1000c692;
    }
  }
  local_11 = true;
LAB_1000c692:
  _Rb_tree_insert_and_rebalance
            ((bool)local_11,&__z->super__Rb_tree_node_base,__p,
             &(this->_M_impl).super__Rb_tree_header._M_header);
  (this->_M_impl).super__Rb_tree_header._M_node_count =
       (this->_M_impl).super__Rb_tree_header._M_node_count + 1;
  _Rb_tree_iterator<>::_Rb_tree_iterator(&local_18,&__z->super__Rb_tree_node_base);
  return (iterator)local_18._M_node;
}



// DWARF original prototype: pair<int_const,_int> *
// _M_valptr(_Rb_tree_node<std::pair<int_const,_int>_> * this)

pair<> * __thiscall std::_Rb_tree_node<>::_M_valptr(_Rb_tree_node<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_node<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = __gnu_cxx::__aligned_membuf<>::_M_ptr(&this->_M_storage);
  return ppVar1;
}



// DWARF original prototype: first_type * operator()(_Select1st<std::pair<int_const,_int>_> * this,
// pair<int_const,_int> * __x)

first_type * __thiscall std::_Select1st<>::operator()(_Select1st<> *this,pair<> *__x)

{
  pair<> *__x_local;
  _Select1st<> *this_local;
  
  gp = &__global_pointer_;
  return &__x->first;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::_Rb_tree_node<std::pair<int const, int> >*&>

_Rb_tree_node<> ** std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

_Rb_tree_node_base ** std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original name: _M_create_node<std::pair<int const, int> >
// DWARF original prototype: _Link_type
// _M_create_node<std::pair<int_const,_int>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_create_node<>(_Rb_tree<> *this)

{
  _Link_type __node;
  type *in_a1;
  _Rb_tree<> *this_local;
  _Link_type __tmp;
  
  gp = &__global_pointer_;
  __node = _M_get_node(this);
  forward<>(in_a1);
  _M_construct_node<>(this,__node);
  return __node;
}



// DWARF original prototype: void
// deallocate(__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> * this,
// _Rb_tree_node<std::pair<int_const,_int>_> * __p, size_type __n)

void __thiscall
std::__new_allocator<>::deallocate(__new_allocator<> *this,_Rb_tree_node<> *__p,size_type __n)

{
  size_type __n_local;
  _Rb_tree_node<> *__p_local;
  __new_allocator<> *this_local;
  
  gp = &__global_pointer_;
  operator_delete(__p,__n * 0x18);
  return;
}



// DWARF original prototype: _Link_type
// _M_get_node(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_get_node(_Rb_tree<> *this)

{
  _Node_allocator *this_00;
  _Rb_tree_node<> *p_Var1;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  this_00 = _M_get_Node_allocator(this);
  p_Var1 = __new_allocator<>::allocate((__new_allocator<> *)this_00,1,(void *)0x0);
  return p_Var1;
}



// DWARF original name: _M_construct_node<const std::piecewise_construct_t&, std::tuple<int const&>,
// std::tuple<long unsigned int&> >
// DWARF original prototype: void
// _M_construct_node<const_std::piecewise_construct_t&,_std::tuple<int_const&>,_std::tuple<long_unsigned_int&>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __node)

void __thiscall std::_Rb_tree<>::_M_construct_node<>(_Rb_tree<> *this,_Link_type __node)

{
  _Node_allocator *p_Var1;
  pair<> *ppVar2;
  piecewise_construct_t *ppVar3;
  tuple<int_const&> *ptVar4;
  tuple<> *ptVar5;
  type *in_a2;
  type *in_a3;
  type *in_a4;
  _Link_type __node_local;
  _Rb_tree<> *this_local;
  tuple<> tStack_4c;
  _Node_allocator *local_48;
  tuple<> *local_44;
  tuple<int_const&> *local_40;
  type *local_3c;
  pair<> *local_38;
  tuple<> *local_34;
  type *local_30;
  piecewise_construct_t *local_2c;
  pair<> *local_28;
  _Node_allocator *local_24;
  
  gp = &__global_pointer_;
  operator_new(0x18,__node);
  p_Var1 = _M_get_Node_allocator(this);
  ppVar2 = _Rb_tree_node<>::_M_valptr(__node);
  ppVar3 = forward<>(in_a2);
  ptVar4 = forward<>(in_a3);
  local_34 = forward<>(in_a4);
  local_30 = ptVar4;
  local_2c = ppVar3;
  local_28 = ppVar2;
  local_24 = p_Var1;
  ppVar3 = forward<>(ppVar3);
  ptVar4 = forward<>(local_30);
  local_44 = forward<>(local_34);
  local_38 = local_28;
  local_48 = local_24;
  local_40 = ptVar4;
  local_3c = ppVar3;
  ppVar2 = (pair<> *)operator_new(8,local_28);
  forward<>(local_3c);
  ptVar4 = forward<>(local_40);
  tuple<int_const&>::tuple((tuple<int_const&> *)&this_local,ptVar4);
  ptVar5 = forward<>(local_44);
  tuple<>::tuple(&tStack_4c,ptVar5);
  pair<>::pair<>(ppVar2,&this_local,&tStack_4c);
  return;
}



// DWARF original prototype: pair<int_const,_int> *
// _M_ptr(__aligned_membuf<std::pair<int_const,_int>_> * this)

pair<> * __thiscall __gnu_cxx::__aligned_membuf<>::_M_ptr(__aligned_membuf<> *this)

{
  pair<> *ppVar1;
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = (pair<> *)_M_addr(this);
  return ppVar1;
}



// DWARF original name: _M_construct_node<std::pair<int const, int> >
// DWARF original prototype: void
// _M_construct_node<std::pair<int_const,_int>_>(_Rb_tree<int,_std::pair<int_const,_int>,_std::_Select1st<std::pair<int_const,_int>_>,_std::less<int>,_std::allocator<std::pair<int_const,_int>_>_>
// * this, _Link_type __node)

void __thiscall std::_Rb_tree<>::_M_construct_node<>(_Rb_tree<> *this,_Link_type __node)

{
  pair<> *ppVar1;
  pair<> *ppVar2;
  int *piVar3;
  type *in_a2;
  _Link_type __node_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  operator_new(0x18,__node);
  _M_get_Node_allocator(this);
  ppVar1 = _Rb_tree_node<>::_M_valptr(__node);
  ppVar2 = forward<>(in_a2);
  ppVar2 = forward<>(ppVar2);
  piVar3 = (int *)operator_new(8,ppVar1);
  ppVar1 = forward<>(ppVar2);
  *piVar3 = ppVar1->first;
  piVar3[1] = ppVar1->second;
  return;
}



// DWARF original prototype: void * _M_addr(__aligned_membuf<std::pair<int_const,_int>_> * this)

void * __thiscall __gnu_cxx::__aligned_membuf<>::_M_addr(__aligned_membuf<> *this)

{
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  return this;
}



// DWARF original prototype: _Rb_tree_node<std::pair<int_const,_int>_> *
// allocate(__new_allocator<std::_Rb_tree_node<std::pair<int_const,_int>_>_> * this, size_type __n,
// void * param_2)

_Rb_tree_node<> * __thiscall
std::__new_allocator<>::allocate(__new_allocator<> *this,size_type __n,void *param_2)

{
  _Rb_tree_node<> *p_Var1;
  void *param_2_local;
  size_type __n_local;
  __new_allocator<> *this_local;
  
  gp = &__global_pointer_;
  if (0x5555555 < __n) {
    if (0xaaaaaaa < __n) {
      __throw_bad_array_new_length();
    }
    __throw_bad_alloc();
  }
  p_Var1 = (_Rb_tree_node<> *)operator_new(__n * 0x18);
  return p_Var1;
}



// DWARF original prototype: void tuple(tuple<int_const&> * this, tuple<int_const&> * param_1)

void __thiscall std::tuple<int_const&>::tuple(tuple<int_const&> *this,tuple<int_const&> *param_1)

{
  tuple<int_const&> *param_1_local;
  tuple<int_const&> *this_local;
  
  gp = &__global_pointer_;
  _Tuple_impl<>::_Tuple_impl
            (&this->super__Tuple_impl<0,_int_const&>,&param_1->super__Tuple_impl<0,_int_const&>);
  return;
}



// DWARF original prototype: void tuple(tuple<long_unsigned_int&> * this, tuple<long_unsigned_int&>
// * param_1)

void __thiscall std::tuple<>::tuple(tuple<> *this,tuple<> *param_1)

{
  tuple<> *param_1_local;
  tuple<> *this_local;
  
  gp = &__global_pointer_;
  _Tuple_impl<>::_Tuple_impl
            (&this->super__Tuple_impl<0,_long_unsigned_int&>,
             &param_1->super__Tuple_impl<0,_long_unsigned_int&>);
  return;
}



// DWARF original prototype: void _Tuple_impl(_Tuple_impl<0,_int_const&> * this,
// _Tuple_impl<0,_int_const&> * __in)

void __thiscall std::_Tuple_impl<>::_Tuple_impl(_Tuple_impl<> *this,_Tuple_impl<> *__in)

{
  _Tuple_impl<> *__in_local;
  _Tuple_impl<> *this_local;
  
  gp = &__global_pointer_;
  (this->super__Head_base<0,_int_const&,_false>)._M_head_impl =
       (__in->super__Head_base<0,_int_const&,_false>)._M_head_impl;
  return;
}



// DWARF original prototype: void _Tuple_impl(_Tuple_impl<0,_long_unsigned_int&> * this,
// _Tuple_impl<0,_long_unsigned_int&> * __in)

void __thiscall std::_Tuple_impl<>::_Tuple_impl(_Tuple_impl<> *this,_Tuple_impl<> *__in)

{
  _Tuple_impl<> *__in_local;
  _Tuple_impl<> *this_local;
  
  gp = &__global_pointer_;
  (this->super__Head_base<0,_long_unsigned_int&,_false>)._M_head_impl =
       (__in->super__Head_base<0,_long_unsigned_int&,_false>)._M_head_impl;
  return;
}



// DWARF original name: pair<int const&, long unsigned int&>
// DWARF original prototype: void pair<int_const&,_long_unsigned_int&>(pair<int_const,_int> * this,
// piecewise_construct_t param_3, tuple<int_const&> * __first, tuple<long_unsigned_int&> * __second)

void __thiscall
std::pair<>::pair<>(pair<> *this,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  tuple<> *__second_local;
  tuple<int_const&> *__first_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pair<>(this,param_2,param_3,param_4);
  return;
}



// DWARF original name: pair<int const&, 0, long unsigned int&, 0>
// DWARF original prototype: void pair<int_const&,_0,_long_unsigned_int&,_0>(pair<int_const,_int> *
// this, tuple<int_const&> * __tuple1, tuple<long_unsigned_int&> * __tuple2, _Index_tuple<0>
// param_7, _Index_tuple<0> param_8)

void __thiscall std::pair<>::pair<>(pair<> *this,tuple<int_const&> *__tuple1,tuple<> *__tuple2)

{
  int *piVar1;
  ulong *puVar2;
  tuple<> *__tuple2_local;
  tuple<int_const&> *__tuple1_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  piVar1 = get<>(__tuple1);
  piVar1 = forward<int_const&>(piVar1);
  this->first = *piVar1;
  puVar2 = get<>(__tuple2);
  puVar2 = forward<>(puVar2);
  this->second = *puVar2;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: get<0, int const&>

int * std::get<>(tuple<int_const&> *__t)

{
  int *piVar1;
  tuple<int_const&> *__t_local;
  
  gp = &__global_pointer_;
  piVar1 = __get_helper<>(&__t->super__Tuple_impl<0,_int_const&>);
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: get<0, long unsigned int&>

ulong * std::get<>(tuple<> *__t)

{
  ulong *puVar1;
  tuple<> *__t_local;
  
  gp = &__global_pointer_;
  puVar1 = __get_helper<>(&__t->super__Tuple_impl<0,_long_unsigned_int&>);
  return puVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __get_helper<0, int const&>

int * std::__get_helper<>(_Tuple_impl<> *__t)

{
  int *piVar1;
  _Tuple_impl<> *__t_local;
  
  gp = &__global_pointer_;
  piVar1 = _Tuple_impl<>::_M_head(__t);
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: __get_helper<0, long unsigned int&>

ulong * std::__get_helper<>(_Tuple_impl<> *__t)

{
  ulong *puVar1;
  _Tuple_impl<> *__t_local;
  
  gp = &__global_pointer_;
  puVar1 = _Tuple_impl<>::_M_head(__t);
  return puVar1;
}



int * std::_Tuple_impl<>::_M_head(_Tuple_impl<> *__t)

{
  int *piVar1;
  _Tuple_impl<> *__t_local;
  
  gp = &__global_pointer_;
  piVar1 = _Head_base<>::_M_head(&__t->super__Head_base<0,_int_const&,_false>);
  return piVar1;
}



ulong * std::_Tuple_impl<>::_M_head(_Tuple_impl<> *__t)

{
  ulong *puVar1;
  _Tuple_impl<> *__t_local;
  
  gp = &__global_pointer_;
  puVar1 = _Head_base<>::_M_head(&__t->super__Head_base<0,_long_unsigned_int&,_false>);
  return puVar1;
}



int * std::_Head_base<>::_M_head(_Head_base<> *__b)

{
  _Head_base<> *__b_local;
  
  gp = &__global_pointer_;
  return __b->_M_head_impl;
}



ulong * std::_Head_base<>::_M_head(_Head_base<> *__b)

{
  _Head_base<> *__b_local;
  
  gp = &__global_pointer_;
  return __b->_M_head_impl;
}



// DWARF original prototype: void ~SPIClassRP2040(SPIClassRP2040 * this, int __in_chrg)

void __thiscall SPIClassRP2040::~SPIClassRP2040(SPIClassRP2040 *this,int __in_chrg)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  (this->super_HardwareSPI)._vptr_HardwareSPI = (_func_int_varargs **)&PTR__SPIClassRP2040_10023580;
  SPIHelper::~SPIHelper(&this->_helper,__in_chrg);
  arduino::HardwareSPI::~HardwareSPI(&this->super_HardwareSPI,__in_chrg);
  return;
}



// DWARF original prototype: void ~SPIClassRP2040(SPIClassRP2040 * this, int __in_chrg)

void __thiscall SPIClassRP2040::~SPIClassRP2040(SPIClassRP2040 *this,int __in_chrg)

{
  SPIClassRP2040 *this_local;
  
  gp = &__global_pointer_;
  ~SPIClassRP2040(this,__in_chrg);
  operator_delete(this,0x4c);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  arduino::SPISettings::SPISettings(&arduino::DEFAULT_SPI_SETTINGS);
  SPIClassRP2040::SPIClassRP2040(&SPI,(spi_inst_t *)0x40080000,'\x10','\x11','\x12','\x13');
  SPIClassRP2040::SPIClassRP2040(&SPI1,(spi_inst_t *)0x40088000,'\f','\r','\x0e','\x0f');
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN14SPIClassRP2040C2EP8spi_insthhhh(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



// DWARF original prototype: uint length(String * this)

uint __thiscall arduino::String::length(String *this)

{
  String *this_local;
  
  gp = &__global_pointer_;
  return this->len;
}



// DWARF original prototype: char * c_str(String * this)

char * __thiscall arduino::String::c_str(String *this)

{
  String *this_local;
  
  gp = &__global_pointer_;
  return this->buffer;
}



// DWARF original prototype: size_t write(Print * this, char * str)

ssize_t __thiscall arduino::Print::write(Print *this,int __fd,void *__buf,size_t __n)

{
  _func_int_varargs *p_Var1;
  size_t sVar2;
  int iVar3;
  char *str_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  if (__fd == 0) {
    iVar3 = 0;
  }
  else {
    p_Var1 = this->_vptr_Print[1];
    sVar2 = strlen((char *)__fd);
    iVar3 = (*p_Var1)(__fd,sVar2);
  }
  return iVar3;
}



// DWARF original prototype: size_t write(Print * this, char * buffer, size_t size)

ssize_t __thiscall arduino::Print::write(Print *this,int __fd,void *__buf,size_t __n)

{
  int iVar1;
  size_t size_local;
  char *buffer_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  iVar1 = (*this->_vptr_Print[1])(__fd,__buf,this->_vptr_Print[1]);
  return iVar1;
}



// DWARF original prototype: size_t write(Print * this, uint8_t * buffer, size_t size)

ssize_t __thiscall arduino::Print::write(Print *this,int __fd,void *__buf,size_t __n)

{
  int iVar1;
  void *local_2c;
  size_t size_local;
  uint8_t *buffer_local;
  Print *this_local;
  int local_14;
  size_t n;
  
  gp = &__global_pointer_;
  local_14 = 0;
  local_2c = __buf;
  size_local = __fd;
  while( true ) {
    if (local_2c == (void *)0x0) {
      return local_14;
    }
    iVar1 = (**this->_vptr_Print)((uint)*(byte *)size_local,*this->_vptr_Print);
    if (iVar1 == 0) break;
    local_14 = local_14 + 1;
    local_2c = (void *)((int)local_2c + -1);
    size_local = size_local + 1;
  }
  return local_14;
}



// DWARF original prototype: size_t print(Print * this, String * s)

size_t __thiscall arduino::Print::print(Print *this,String *s)

{
  char *__fd;
  void *__buf;
  size_t sVar1;
  size_t in_a3;
  String *s_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  __fd = String::c_str(s);
  __buf = (void *)String::length(s);
  sVar1 = write(this,(int)__fd,__buf,in_a3);
  return sVar1;
}



// DWARF original prototype: size_t print(Print * this, char * str)

size_t __thiscall arduino::Print::print(Print *this,char *str)

{
  size_t sVar1;
  void *in_a2;
  size_t in_a3;
  char *str_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  sVar1 = write(this,(int)str,in_a2,in_a3);
  return sVar1;
}



// DWARF original prototype: size_t print(Print * this, char c)

size_t __thiscall arduino::Print::print(Print *this,char c)

{
  size_t sVar1;
  char c_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  sVar1 = (**this->_vptr_Print)((uint)(byte)c,*this->_vptr_Print);
  return sVar1;
}



// DWARF original prototype: size_t print(Print * this, int n, int base)

size_t __thiscall arduino::Print::print(Print *this,int n,int base)

{
  size_t sVar1;
  int base_local;
  int n_local;
  Print *this_local;
  
  gp = &__global_pointer_;
  sVar1 = print(this,n,base);
  return sVar1;
}



// DWARF original prototype: size_t print(Print * this, long n, int base)

size_t __thiscall arduino::Print::print(Print *this,long n,int base)

{
  size_t sVar1;
  size_t sVar2;
  int base_local;
  long n_local;
  Print *this_local;
  int t;
  
  gp = &__global_pointer_;
  if (base == 0) {
    sVar1 = (**this->_vptr_Print)(n & 0xff,*this->_vptr_Print);
  }
  else if (base == 10) {
    if (n < 0) {
      sVar1 = print(this,'-');
      sVar2 = printNumber(this,-n,'\n');
      sVar1 = sVar1 + sVar2;
    }
    else {
      sVar1 = printNumber(this,n,'\n');
    }
  }
  else {
    sVar1 = printNumber(this,n,(uint8_t)base);
  }
  return sVar1;
}



// DWARF original prototype: size_t printNumber(Print * this, ulong n, uint8_t base)

size_t __thiscall arduino::Print::printNumber(Print *this,ulong n,uint8_t base)

{
  size_t sVar1;
  undefined3 in_register_00002031;
  size_t in_a3;
  char cVar2;
  byte local_49;
  ulong uStack_48;
  uint8_t base_local;
  ulong n_local;
  Print *this_local;
  char buf [33];
  char c;
  char *str;
  
  gp = &__global_pointer_;
  register0x0000203c = buf + 0x1c;
  buf[0x1c] = '\0';
  local_49 = base;
  uStack_48 = n;
  if (base < 2) {
    local_49 = 10;
  }
  do {
    buf[0x1f] = (char)(uStack_48 % (uint)local_49);
    uStack_48 = uStack_48 / local_49;
    if ((byte)buf[0x1f] < 10) {
      cVar2 = buf[0x1f] + 0x30;
    }
    else {
      cVar2 = buf[0x1f] + 0x37;
    }
    register0x00002038 = stack0xffffffec + -1;
    *register0x00002038 = cVar2;
  } while (uStack_48 != 0);
  sVar1 = write(this,(int)register0x00002038,(void *)CONCAT31(in_register_00002031,base),in_a3);
  return sVar1;
}



// DWARF original prototype: void String(String * this, char * cstr)

void __thiscall arduino::String::String(String *this,char *cstr)

{
  EVP_PKEY_CTX *src;
  char *cstr_local;
  String *this_local;
  
  gp = &__global_pointer_;
  init(this,(EVP_PKEY_CTX *)cstr);
  if (cstr != (char *)0x0) {
    src = (EVP_PKEY_CTX *)strlen(cstr);
    copy(this,(EVP_PKEY_CTX *)cstr,src);
  }
  return;
}



// DWARF original prototype: void init(String * this)

int __thiscall arduino::String::init(String *this,EVP_PKEY_CTX *ctx)

{
  String *this_local;
  
  gp = &__global_pointer_;
  this->buffer = (char *)0x0;
  this->capacity = 0;
  this->len = 0;
  return (int)this;
}



// DWARF original prototype: void invalidate(String * this)

void __thiscall arduino::String::invalidate(String *this)

{
  String *this_local;
  
  gp = &__global_pointer_;
  if (this->buffer != (char *)0x0) {
    __wrap_free(this->buffer);
  }
  this->buffer = (char *)0x0;
  this->len = 0;
  this->capacity = this->len;
  return;
}



// DWARF original prototype: bool reserve(String * this, uint size)

bool __thiscall arduino::String::reserve(String *this,uint size)

{
  bool bVar1;
  undefined3 extraout_var;
  uint size_local;
  String *this_local;
  
  gp = &__global_pointer_;
  if ((this->buffer == (char *)0x0) || (this->capacity < size)) {
    bVar1 = changeBuffer(this,size);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      bVar1 = false;
    }
    else {
      if (this->len == 0) {
        *this->buffer = '\0';
      }
      bVar1 = true;
    }
  }
  else {
    bVar1 = true;
  }
  return bVar1;
}



// DWARF original prototype: bool changeBuffer(String * this, uint maxStrLen)

bool __thiscall arduino::String::changeBuffer(String *this,uint maxStrLen)

{
  char *pcVar1;
  uint maxStrLen_local;
  String *this_local;
  char *newbuffer;
  
  gp = &__global_pointer_;
  pcVar1 = (char *)__wrap_realloc(this->buffer,maxStrLen + 1);
  if (pcVar1 != (char *)0x0) {
    this->buffer = pcVar1;
    this->capacity = maxStrLen;
  }
  return pcVar1 != (char *)0x0;
}



// DWARF original prototype: String * copy(String * this, char * cstr, uint length)

int __thiscall arduino::String::copy(String *this,EVP_PKEY_CTX *dst,EVP_PKEY_CTX *src)

{
  bool bVar1;
  uint length_local;
  char *cstr_local;
  String *this_local;
  
  gp = &__global_pointer_;
  bVar1 = reserve(this,(uint)src);
  if (bVar1) {
    this->len = (uint)src;
    memcpy(this->buffer,dst,(size_t)src);
    this->buffer[this->len] = '\0';
  }
  else {
    invalidate(this);
  }
  return (int)this;
}



// DWARF original prototype: String * operator=(String * this, char * cstr)

String * __thiscall arduino::String::operator=(String *this,char *cstr)

{
  EVP_PKEY_CTX *src;
  char *cstr_local;
  String *this_local;
  
  gp = &__global_pointer_;
  if (cstr == (char *)0x0) {
    invalidate(this);
  }
  else {
    src = (EVP_PKEY_CTX *)strlen(cstr);
    copy(this,(EVP_PKEY_CTX *)cstr,src);
  }
  return this;
}



// DWARF original prototype: bool concat(String * this, char * cstr, uint length)

bool __thiscall arduino::String::concat(String *this,char *cstr,uint length)

{
  bool bVar1;
  uint size;
  uint length_local;
  char *cstr_local;
  String *this_local;
  uint newlen;
  
  gp = &__global_pointer_;
  size = this->len + length;
  if (cstr == (char *)0x0) {
    bVar1 = false;
  }
  else if (length == 0) {
    bVar1 = true;
  }
  else {
    bVar1 = reserve(this,size);
    if (bVar1) {
      memcpy(this->buffer + this->len,cstr,length);
      this->len = size;
      this->buffer[this->len] = '\0';
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
  }
  return bVar1;
}



// DWARF original prototype: bool concat(String * this, char c)

bool __thiscall arduino::String::concat(String *this,char c)

{
  bool bVar1;
  char local_15;
  String *pSStack_14;
  char c_local;
  String *this_local;
  
  gp = &__global_pointer_;
  local_15 = c;
  pSStack_14 = this;
  bVar1 = concat(this,&local_15,1);
  return bVar1;
}



undefined4 to_us_since_boot(absolute_time_t t)

{
  undefined4 in_a0;
  absolute_time_t t_local;
  
  gp = &__global_pointer_;
  return in_a0;
}



void update_us_since_boot(absolute_time_t *t,uint64_t us_since_boot)

{
  undefined4 in_a1;
  undefined4 in_a2;
  uint64_t us_since_boot_local;
  absolute_time_t *t_local;
  
  gp = &__global_pointer_;
  *(undefined4 *)t = in_a1;
  *(undefined4 *)((int)t + 4) = in_a2;
  return;
}



// WARNING: Unknown calling convention

undefined4 get_absolute_time(void)

{
  undefined4 local_18;
  absolute_time_t t;
  
  gp = &__global_pointer_;
  time_us_64();
  update_us_since_boot((absolute_time_t *)&local_18,uRam00000010);
  return local_18;
}



uint32_t us_to_ms(uint64_t us)

{
  uint in_a0;
  uint32_t uVar1;
  int in_a1;
  uint64_t us_local;
  
  gp = &__global_pointer_;
  if (in_a1 == 0) {
    uVar1 = in_a0 / 1000;
  }
  else {
    uVar1 = __udivdi3(us,URam00000018);
  }
  return uVar1;
}



uint32_t to_ms_since_boot(absolute_time_t t)

{
  uint32_t uVar1;
  absolute_time_t t_local;
  uint64_t us;
  
  gp = &__global_pointer_;
  to_us_since_boot(t);
  uVar1 = us_to_ms(t);
  return uVar1;
}



void delay(ulong ms)

{
  ulong ms_local;
  
  gp = &__global_pointer_;
  if (ms != 0) {
    sleep_ms(ms);
  }
  return;
}



void delayMicroseconds(uint usec)

{
  uint usec_local;
  
  gp = &__global_pointer_;
  if (usec != 0) {
    sleep_us(uRam00000010);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void yield(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

uint32_t millis(void)

{
  uint32_t uVar1;
  
  gp = &__global_pointer_;
  get_absolute_time();
  uVar1 = to_ms_since_boot(aRam00000010);
  return uVar1;
}



uint _pio_encode_instr_and_args(pio_instr_bits instr_bits,uint arg1,uint arg2)

{
  uint arg2_local;
  uint arg1_local;
  pio_instr_bits instr_bits_local;
  
  gp = &__global_pointer_;
  return arg2 & 0x1f | arg1 << 5 | instr_bits;
}



uint _pio_encode_instr_and_src_dest(pio_instr_bits instr_bits,pio_src_dest dest,uint value)

{
  uint uVar1;
  uint value_local;
  pio_src_dest dest_local;
  pio_instr_bits instr_bits_local;
  
  gp = &__global_pointer_;
  uVar1 = _pio_encode_instr_and_args(instr_bits,dest & 7,value);
  return uVar1;
}



uint pio_encode_set(pio_src_dest dest,uint value)

{
  uint uVar1;
  uint value_local;
  pio_src_dest dest_local;
  
  gp = &__global_pointer_;
  uVar1 = _pio_encode_instr_and_src_dest(pio_instr_bits_set,dest,value);
  return uVar1;
}



void check_sm_param(uint sm)

{
  uint sm_local;
  
  gp = &__global_pointer_;
  return;
}



void check_pio_param(PIO pio)

{
  PIO pio_local;
  
  gp = &__global_pointer_;
  return;
}



void sm_config_set_clkdiv_int_frac8(pio_sm_config *c,uint32_t div_int,uint8_t div_frac8)

{
  uint8_t div_frac8_local;
  uint32_t div_int_local;
  pio_sm_config *c_local;
  
  gp = &__global_pointer_;
  c->clkdiv = (uint)div_frac8 << 8 | div_int << 0x10;
  return;
}



void sm_config_set_wrap(pio_sm_config *c,uint wrap_target,uint wrap)

{
  uint wrap_local;
  uint wrap_target_local;
  pio_sm_config *c_local;
  
  gp = &__global_pointer_;
  c->execctrl = c->execctrl & 0xfffe007f | wrap_target << 7 | wrap << 0xc;
  return;
}



void sm_config_set_in_shift(pio_sm_config *c,bool shift_right,bool autopush,uint push_threshold)

{
  uint push_threshold_local;
  bool autopush_local;
  bool shift_right_local;
  pio_sm_config *c_local;
  
  gp = &__global_pointer_;
  c->shiftctrl = c->shiftctrl & 0xfe0affff | (uint)shift_right << 0x12 | (uint)autopush << 0x10 |
                 (push_threshold & 0x1f) << 0x14;
  return;
}



void sm_config_set_out_shift(pio_sm_config *c,bool shift_right,bool autopull,uint pull_threshold)

{
  uint pull_threshold_local;
  bool autopull_local;
  bool shift_right_local;
  pio_sm_config *c_local;
  
  gp = &__global_pointer_;
  c->shiftctrl = c->shiftctrl & 0xc1f5ffff | (uint)shift_right << 0x13 | (uint)autopull << 0x11 |
                 (pull_threshold & 0x1f) << 0x19;
  return;
}



// WARNING: Unknown calling convention

pio_sm_config * pio_get_default_sm_config(void)

{
  pio_sm_config *in_a0;
  pio_sm_config *c;
  
  gp = &__global_pointer_;
  in_a0->clkdiv = 0;
  in_a0->execctrl = 0;
  in_a0->shiftctrl = 0;
  in_a0->pinctrl = 0;
  in_a0->pinhi = 0;
  in_a0->pinhi = 0xffffffff;
  sm_config_set_clkdiv_int_frac8(in_a0,1,'\0');
  sm_config_set_wrap(in_a0,0,0x1f);
  sm_config_set_in_shift(in_a0,true,false,0x20);
  sm_config_set_out_shift(in_a0,true,false,0x20);
  return in_a0;
}



void pio_sm_set_enabled(PIO pio,uint sm,bool enabled)

{
  bool enabled_local;
  uint sm_local;
  PIO pio_local;
  
  gp = &__global_pointer_;
  check_pio_param(pio);
  check_sm_param(sm);
  pio->ctrl = pio->ctrl & ~(1 << (sm & 0x1f)) | (uint)enabled << (sm & 0x1f);
  return;
}



void pio_sm_exec(PIO pio,uint sm,uint instr)

{
  uint instr_local;
  uint sm_local;
  PIO pio_local;
  
  gp = &__global_pointer_;
  check_pio_param(pio);
  check_sm_param(sm);
  pio->sm[sm].instr = instr;
  return;
}



void check_doorbell_num_param(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void multicore_doorbell_clear_current_core(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  check_doorbell_num_param(doorbell_num);
  _DAT_d000018c = 1 << (doorbell_num & 0x1f);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool multicore_doorbell_is_set_current_core(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  check_doorbell_num_param(doorbell_num);
  return (1 << (doorbell_num & 0x1f) & _DAT_d0000188) != 0;
}



uint multicore_doorbell_irq_num(uint doorbell_num)

{
  uint doorbell_num_local;
  
  gp = &__global_pointer_;
  check_doorbell_num_param(doorbell_num);
  return 0x1a;
}



uint ccount_program_get_default_config(uint offset)

{
  uint in_a1;
  uint offset_local;
  pio_sm_config *c;
  
  gp = &__global_pointer_;
  pio_get_default_sm_config();
  sm_config_set_wrap((pio_sm_config *)offset,in_a1,in_a1 + 1);
  return offset;
}



void ccount_program_init(PIO pio,uint sm,uint offset)

{
  uint uVar1;
  uint offset_local;
  uint sm_local;
  PIO pio_local;
  undefined1 auStack_24 [4];
  pio_sm_config c;
  
  gp = &__global_pointer_;
  ccount_program_get_default_config((uint)auStack_24);
  pio_sm_init(pio,sm,offset,(pio_sm_config_conflict *)auStack_24);
  uVar1 = pio_encode_set(pio_x,0);
  pio_sm_exec(pio,sm,uVar1);
  uVar1 = pio_encode_set(pio_y,0);
  pio_sm_exec(pio,sm,uVar1);
  return;
}



// DWARF original prototype: void _MFIFO(_MFIFO * this)

void __thiscall _MFIFO::_MFIFO(_MFIFO *this)

{
  _MFIFO *this_local;
  
  gp = &__global_pointer_;
  this->_multicore = false;
  return;
}



// DWARF original prototype: void begin(_MFIFO * this, int cores)

void __thiscall _MFIFO::begin(_MFIFO *this,int cores)

{
  int iVar1;
  int cores_local;
  _MFIFO *this_local;
  
  gp = &__global_pointer_;
  if (cores == 1) {
    this->_multicore = false;
  }
  else {
    iVar1 = multicore_doorbell_claim_unused(3,true);
    _doorbell = (uint8_t)iVar1;
    this->_multicore = true;
    __otherCoreIdled = false;
  }
  return;
}



// DWARF original prototype: void registerCore(_MFIFO * this)

void __thiscall _MFIFO::registerCore(_MFIFO *this)

{
  uint num;
  _MFIFO *this_local;
  uint32_t irq;
  
  gp = &__global_pointer_;
  num = multicore_doorbell_irq_num((uint)_doorbell);
  irq_add_shared_handler(num,_irq,0x80);
  irq_set_enabled(num,true);
  return;
}



// DWARF original prototype: void RP2040(RP2040 * this)

void __thiscall RP2040::RP2040(RP2040 *this)

{
  RP2040 *this_local;
  
  gp = &__global_pointer_;
  *(undefined4 *)this->_epoch = 0;
  *(undefined4 *)((int)this->_epoch + 4) = 0;
  *(undefined4 *)(this->_epoch + 1) = 0;
  *(undefined4 *)((int)this->_epoch + 0xc) = 0;
  _MFIFO::_MFIFO(&this->fifo);
  this->memcpyDMAChannel = -1;
  return;
}



// DWARF original prototype: void begin(RP2040 * this, int cpuid)

void __thiscall RP2040::begin(RP2040 *this,int cpuid)

{
  PIOProgram *this_00;
  int cpuid_local;
  RP2040 *this_local;
  uint local_14;
  int off;
  
  gp = &__global_pointer_;
  *(undefined4 *)(this->_epoch + cpuid) = 0;
  *(undefined4 *)((int)(this->_epoch + cpuid) + 4) = 0;
  if (cpuid == 0) {
    local_14 = 0;
    this_00 = (PIOProgram *)operator_new(0xc);
    PIOProgram::PIOProgram(this_00,&ccount_program);
    this->_ccountPgm = this_00;
    PIOProgram::prepare(this->_ccountPgm,&this->_pio,&this->_sm,(int *)&local_14,0,1);
    ccount_program_init(this->_pio,this->_sm,local_14);
    pio_sm_set_enabled(this->_pio,this->_sm,true);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void initVariant(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Removing unreachable block (ram,0x1000db58)
// WARNING: Removing unreachable block (ram,0x1000db66)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void main1(void)

{
  if (!core1_disable_systick) {
    RP2040::begin(&rp2040,1);
  }
  _MFIFO::registerCore(&rp2040.fifo);
  do {
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x1000db8c)
// WARNING: Removing unreachable block (ram,0x1000db9a)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void __loop(void)

{
  gp = &__global_pointer_;
  arduino::serialEventRun();
  return;
}



// WARNING: Removing unreachable block (ram,0x1000dc46)
// WARNING: Removing unreachable block (ram,0x1000dbc0)
// WARNING: Removing unreachable block (ram,0x1000dc7c)
// WARNING: Removing unreachable block (ram,0x1000dcaa)
// WARNING: Removing unreachable block (ram,0x1000dc88)
// WARNING: Unknown calling convention

int main(void)

{
  RP2040::begin(&rp2040,0);
  initVariant();
  USBClass::begin(&USB);
  SerialUSB::begin(&Serial,0x1c200);
  _MFIFO::begin(&rp2040.fifo,1);
  _MFIFO::registerCore(&rp2040.fifo);
  setup();
  do {
    loop();
    __loop();
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

_reent * __wrap___getreent(void)

{
  _reent *p_Var1;
  
  gp = &__global_pointer_;
  p_Var1 = _impure_ptr1;
  if (_DAT_d0000000 == 0) {
    p_Var1 = _impure_ptr;
  }
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  RP2040::RP2040(&rp2040);
  arduino::String::String(&emptyString,"");
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I_rp2040(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



void * __wrap_malloc(size_t size)

{
  void *pvVar1;
  size_t size_local;
  void *rc;
  
  gp = &__global_pointer_;
  noInterrupts();
  pvVar1 = malloc(size);
  interrupts();
  return pvVar1;
}



void * __wrap_calloc(size_t count,size_t size)

{
  void *pvVar1;
  size_t size_local;
  size_t count_local;
  void *rc;
  
  gp = &__global_pointer_;
  noInterrupts();
  pvVar1 = calloc(count,size);
  interrupts();
  return pvVar1;
}



void * __wrap_realloc(void *mem,size_t size)

{
  void *pvVar1;
  size_t size_local;
  void *mem_local;
  void *rc;
  
  gp = &__global_pointer_;
  noInterrupts();
  pvVar1 = realloc(mem,size);
  interrupts();
  return pvVar1;
}



void __wrap_free(void *mem)

{
  void *mem_local;
  
  gp = &__global_pointer_;
  noInterrupts();
  free(mem);
  interrupts();
  return;
}



void gpio_pull_up(uint gpio)

{
  uint gpio_local;
  
  gp = &__global_pointer_;
  gpio_set_pulls(gpio,true,false);
  return;
}



void gpio_pull_down(uint gpio)

{
  uint gpio_local;
  
  gp = &__global_pointer_;
  gpio_set_pulls(gpio,false,true);
  return;
}



void gpio_disable_pulls(uint gpio)

{
  uint gpio_local;
  
  gp = &__global_pointer_;
  gpio_set_pulls(gpio,false,false);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool gpio_get(uint gpio)

{
  uint uVar1;
  uint gpio_local;
  
  gp = &__global_pointer_;
  if (gpio < 0x20) {
    uVar1 = 1 << (gpio & 0x1f) & _DAT_d0000004;
  }
  else {
    uVar1 = 1 << (gpio - 0x20 & 0x1f) & _DAT_d0000008;
  }
  return uVar1 != 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void gpio_put(uint gpio,bool value)

{
  int iVar1;
  int iVar2;
  int iVar3;
  bool value_local;
  uint gpio_local;
  uint32_t mask;
  
  gp = &__global_pointer_;
  iVar3 = 1 << (gpio & 0x1f);
  iVar1 = _DAT_d0000020;
  iVar2 = _DAT_d0000024;
  if (gpio < 0x20) {
    iVar1 = iVar3;
    if (value) {
      _DAT_d0000018 = iVar3;
      iVar1 = _DAT_d0000020;
    }
  }
  else {
    iVar2 = iVar3;
    if (value) {
      _DAT_d000001c = iVar3;
      iVar2 = _DAT_d0000024;
    }
  }
  _DAT_d0000024 = iVar2;
  _DAT_d0000020 = iVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void gpio_set_dir(uint gpio,bool out)

{
  int iVar1;
  int iVar2;
  int iVar3;
  bool out_local;
  uint gpio_local;
  uint32_t mask;
  
  gp = &__global_pointer_;
  iVar3 = 1 << (gpio & 0x1f);
  iVar1 = _DAT_d0000040;
  iVar2 = _DAT_d0000044;
  if (gpio < 0x20) {
    iVar1 = iVar3;
    if (out) {
      _DAT_d0000038 = iVar3;
      iVar1 = _DAT_d0000040;
    }
  }
  else {
    iVar2 = iVar3;
    if (out) {
      _DAT_d000003c = iVar3;
      iVar2 = _DAT_d0000044;
    }
  }
  _DAT_d0000044 = iVar2;
  _DAT_d0000040 = iVar1;
  return;
}



void __pinMode(pin_size_t ulPin,PinMode ulMode)

{
  PinMode ulMode_local;
  pin_size_t ulPin_local;
  
  gp = &__global_pointer_;
  if (ulPin < 0x1e) {
    switch(ulMode) {
    case INPUT:
      gpio_init((uint)ulPin);
      gpio_set_dir((uint)ulPin,false);
      gpio_disable_pulls((uint)ulPin);
      break;
    case OUTPUT:
    case OUTPUT_4MA:
      gpio_init((uint)ulPin);
      gpio_set_drive_strength((uint)ulPin,GPIO_DRIVE_STRENGTH_4MA);
      gpio_set_dir((uint)ulPin,true);
      break;
    case INPUT_PULLUP:
      gpio_init((uint)ulPin);
      gpio_set_dir((uint)ulPin,false);
      gpio_pull_up((uint)ulPin);
      gpio_put((uint)ulPin,false);
      break;
    case INPUT_PULLDOWN:
      gpio_init((uint)ulPin);
      gpio_set_dir((uint)ulPin,false);
      gpio_pull_down((uint)ulPin);
      gpio_put((uint)ulPin,true);
      break;
    default:
      return;
    case OUTPUT_2MA:
      gpio_init((uint)ulPin);
      gpio_set_drive_strength((uint)ulPin,GPIO_DRIVE_STRENGTH_2MA);
      gpio_set_dir((uint)ulPin,true);
      break;
    case OUTPUT_8MA:
      gpio_init((uint)ulPin);
      gpio_set_drive_strength((uint)ulPin,GPIO_DRIVE_STRENGTH_8MA);
      gpio_set_dir((uint)ulPin,true);
      break;
    case OUTPUT_12MA:
      gpio_init((uint)ulPin);
      gpio_set_drive_strength((uint)ulPin,GPIO_DRIVE_STRENGTH_12MA);
      gpio_set_dir((uint)ulPin,true);
    }
    _pm[ulPin] = ulMode;
    if (0x19 < ulPin) {
      __clearADCPin(ulPin);
    }
  }
  return;
}



// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names

void __digitalWrite(pin_size_t ulPin,PinStatus ulVal)

{
  PinStatus ulVal_local;
  pin_size_t ulPin_local;
  
  gp = &__global_pointer_;
  if (ulPin < 0x1e) {
    gpio_set_function((uint)ulPin,GPIO_FUNC_SIO);
    if (_pm[ulPin] == INPUT_PULLDOWN) {
      if (ulVal == LOW) {
        gpio_set_dir((uint)ulPin,false);
      }
      else {
        gpio_set_dir((uint)ulPin,true);
      }
    }
    else if (_pm[ulPin] == INPUT_PULLUP) {
      if (ulVal == HIGH) {
        gpio_set_dir((uint)ulPin,false);
      }
      else {
        gpio_set_dir((uint)ulPin,true);
      }
    }
    else {
      gpio_put((uint)ulPin,ulVal != LOW);
    }
  }
  return;
}



PinStatus __digitalRead(pin_size_t ulPin)

{
  bool bVar1;
  undefined3 extraout_var;
  PinStatus PVar2;
  pin_size_t ulPin_local;
  
  gp = &__global_pointer_;
  if (ulPin < 0x1e) {
    bVar1 = gpio_get((uint)ulPin);
    PVar2 = (PinStatus)(CONCAT31(extraout_var,bVar1) != 0);
  }
  else {
    PVar2 = LOW;
  }
  return PVar2;
}



// DWARF original name: operator bool
// DWARF original prototype: bool operator_bool(CoreMutex * this)

bool __thiscall CoreMutex::operator_bool(CoreMutex *this)

{
  CoreMutex *this_local;
  
  gp = &__global_pointer_;
  return this->_acquired;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void interrupts(void)

{
  uint core;
  
  gp = &__global_pointer_;
  if (_irqStackTop[_DAT_d0000000] != 0) {
    _irqStackTop[_DAT_d0000000] = _irqStackTop[_DAT_d0000000] - 1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void noInterrupts(void)

{
  int iVar1;
  uint32_t uVar2;
  uint32_t in_mstatus;
  uint32_t status;
  uint core;
  
  iVar1 = _DAT_d0000000;
  gp = &__global_pointer_;
  if (_irqStackTop[_DAT_d0000000] != 0xf) {
    uVar2 = _irqStackTop[_DAT_d0000000];
    _irqStackTop[_DAT_d0000000] = uVar2 + 1;
    _irqStack[iVar1][uVar2] = in_mstatus;
    return;
  }
                    // WARNING: Subroutine does not return
  panic("IRQ stack overflow");
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void CoreMutex(CoreMutex * this, mutex_t * mutex, uint8_t option)

void __thiscall CoreMutex::CoreMutex(CoreMutex *this,mutex_t *mutex,uint8_t option)

{
  _Bool _Var1;
  uint8_t option_local;
  mutex_t *mutex_local;
  CoreMutex *this_local;
  uint32_t local_14;
  uint32_t owner;
  
  gp = &__global_pointer_;
  this->_mutex = mutex;
  this->_acquired = false;
  this->_option = option;
  _Var1 = mutex_try_enter(this->_mutex,&local_14);
  if (!_Var1) {
    if (_DAT_d0000000 == local_14) {
      gp = &__global_pointer_;
      return;
    }
    mutex_enter_blocking(this->_mutex);
  }
  this->_acquired = true;
  return;
}



// DWARF original prototype: void ~CoreMutex(CoreMutex * this, int __in_chrg)

void __thiscall CoreMutex::~CoreMutex(CoreMutex *this,int __in_chrg)

{
  CoreMutex *this_local;
  
  gp = &__global_pointer_;
  if (this->_acquired != false) {
    mutex_exit(this->_mutex);
  }
  return;
}



uint pio_get_gpio_base(PIO pio)

{
  PIO pio_local;
  
  gp = &__global_pointer_;
  return pio->gpiobase;
}



PIO pio_get_instance(uint instance)

{
  uint instance_local;
  
  gp = &__global_pointer_;
  return (PIO)((instance + 0x502) * 0x100000);
}



// DWARF original prototype: void
// _Rb_tree(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

void __thiscall std::_Rb_tree<>::_Rb_tree(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree_impl<>::_Rb_tree_impl(&this->_M_impl);
  return;
}



// DWARF original prototype: void
// map(map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

void __thiscall std::map<>::map(map<> *this)

{
  map<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree<>::_Rb_tree(&this->_M_t);
  return;
}



// DWARF original prototype: void PIOProgram(PIOProgram * this, pio_program_t * pgm)

void __thiscall PIOProgram::PIOProgram(PIOProgram *this,pio_program_t *pgm)

{
  pio_program_t *pgm_local;
  PIOProgram *this_local;
  
  gp = &__global_pointer_;
  this->_pgm = pgm;
  this->_pio = (PIO)0x0;
  this->_sm = -1;
  return;
}



// DWARF original prototype: bool prepare(PIOProgram * this, PIO * pio, int * sm, int * offset, int
// start, int cnt)

bool __thiscall PIOProgram::prepare(PIOProgram *this,PIO *pio,int *sm,int *offset,int start,int cnt)

{
  map<> *pmVar1;
  bool bVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  pointer ppVar4;
  PIO ppVar5;
  uint uVar6;
  undefined3 extraout_var_00;
  PIO *pio_00;
  PIO *extraout_a1;
  int cnt_local;
  int start_local;
  int *offset_local;
  int *sm_local;
  PIO *pio_local;
  PIOProgram *this_local;
  int local_78;
  int off_1;
  _Rb_tree_iterator<> p_1;
  uint off;
  uint idx;
  PIO p;
  PIO pi [3];
  CoreMutex m;
  pair<> pStack_44;
  undefined4 local_3c;
  PIO *local_38;
  pair<> pStack_34;
  int local_2c;
  int idx_1;
  int idx_2;
  uint uStack_20;
  bool rc;
  uint gpioBaseNeeded;
  int o_2;
  int o_1;
  int o;
  
  gp = &__global_pointer_;
  CoreMutex::CoreMutex((CoreMutex *)(pi + 2),&_pioMutex,'\x01');
  p = (PIO)0x50200000;
  pi[0] = (PIO)&DAT_50300000;
  pi[1] = (PIO)&DAT_50400000;
  if (start + cnt < 0x20) {
    uStack_20 = 0;
  }
  else {
    uStack_20 = 0x10;
  }
  for (o_1 = 0; o_1 < 3; o_1 = o_1 + 1) {
    off_1 = (int)std::map<>::find(__pioMap + o_1,&this->_pgm);
    m._4_4_ = std::map<>::end(__pioMap + o_1);
    bVar2 = std::operator!=((_Self *)&off_1,(_Self *)&m._acquired);
    if (CONCAT31(extraout_var,bVar2) == 0) {
LAB_1000e58e:
      bVar2 = false;
    }
    else {
      ppVar5 = pio_get_instance(o_1);
      uVar6 = pio_get_gpio_base(ppVar5);
      if (uStack_20 != uVar6) goto LAB_1000e58e;
      bVar2 = true;
    }
    if (bVar2) {
      pio_00 = (PIO *)0x0;
      local_2c = pio_claim_unused_sm(pi[o_1 + -1],false);
      if (-1 < local_2c) {
        this->_pio = pi[o_1 + -1];
        this->_sm = local_2c;
        *pio = pi[o_1 + -1];
        *sm = local_2c;
        ppVar4 = std::_Rb_tree_iterator<>::operator->((_Rb_tree_iterator<> *)&off_1);
        *offset = ppVar4->second;
        bVar2 = true;
        goto LAB_1000e88a;
      }
    }
  }
  o_2 = 0;
  do {
    if (2 < o_2) {
      pio_00 = (PIO *)&idx;
      idx_2._3_1_ = pio_claim_free_sm_and_add_program_for_gpio_range
                              (this->_pgm,pio_00,&off,(uint *)&p_1,start,cnt,true);
      if ((bool)idx_2._3_1_) {
        for (gpioBaseNeeded = 0; pi[gpioBaseNeeded - 1] != (PIO)idx;
            gpioBaseNeeded = gpioBaseNeeded + 1) {
        }
        if (__pioAllocated[gpioBaseNeeded] == true) {
                    // WARNING: Subroutine does not return
          __assert_func("/Users/seadog007/Library/Arduino15/packages/rp2040/hardware/rp2040/5.4.3/cores/rp2040/PIOProgram.cpp"
                        ,0x71,"bool PIOProgram::prepare(pio_hw_t**, int*, int*, int, int)",
                        "!__pioAllocated[o]");
        }
        __pioAllocated[gpioBaseNeeded] = true;
        pmVar1 = __pioMap + gpioBaseNeeded;
        std::pair<>::pair<>(&pStack_34,&this->_pgm,(uint *)&p_1);
        local_3c = std::map<>::insert(pmVar1,&pStack_34);
        local_38 = extraout_a1;
        this->_pio = pi[gpioBaseNeeded - 1];
        this->_sm = off;
        *pio = pi[gpioBaseNeeded - 1];
        *sm = off;
        *offset = (int)p_1._M_node;
        bVar2 = true;
        pio_00 = extraout_a1;
      }
      else {
        bVar2 = false;
      }
LAB_1000e88a:
      CoreMutex::~CoreMutex((CoreMutex *)(pi + 2),(int)pio_00);
      return bVar2;
    }
    if (__pioAllocated[o_2] == false) {
LAB_1000e650:
      bVar2 = false;
    }
    else {
      ppVar5 = pio_get_instance(o_2);
      uVar6 = pio_get_gpio_base(ppVar5);
      if (uStack_20 != uVar6) goto LAB_1000e650;
      bVar2 = true;
    }
    if ((bVar2) &&
       (_Var3 = pio_can_add_program(pi[o_2 + -1],this->_pgm), CONCAT31(extraout_var_00,_Var3) != 0))
    {
      idx_1 = pio_claim_unused_sm(pi[o_2 + -1],false);
      if (-1 < idx_1) {
        local_78 = pio_add_program(pi[o_2 + -1],this->_pgm);
        pmVar1 = __pioMap + o_2;
        std::pair<>::pair<>(&pStack_44,&this->_pgm,&local_78);
        pio_00 = (PIO *)std::map<>::insert(pmVar1,&pStack_44);
        this->_pio = pi[o_2 + -1];
        this->_sm = idx_1;
        *pio = pi[o_2 + -1];
        *sm = idx_1;
        *offset = local_78;
        bVar2 = true;
        goto LAB_1000e88a;
      }
    }
    o_2 = o_2 + 1;
  } while( true );
}



// DWARF original prototype: void _Rb_tree_impl(_Rb_tree_impl<std::less<const_pio_program*>,_true> *
// this)

void __thiscall std::_Rb_tree<>::_Rb_tree_impl<>::_Rb_tree_impl(_Rb_tree_impl<> *this)

{
  _Rb_tree_impl<> *this_local;
  
  gp = &__global_pointer_;
  _Rb_tree_key_compare<>::_Rb_tree_key_compare((_Rb_tree_key_compare<> *)this);
  _Rb_tree_header::_Rb_tree_header(&this->super__Rb_tree_header);
  return;
}



// DWARF original prototype: iterator
// find(map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, key_type * __x)

iterator __thiscall std::map<>::find(map<> *this,key_type *__x)

{
  iterator iVar1;
  key_type *__x_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  iVar1 = _Rb_tree<>::find(&this->_M_t,__x);
  return (iterator)iVar1._M_node;
}



// DWARF original prototype: iterator
// end(map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

iterator __thiscall std::map<>::end(map<> *this)

{
  iterator iVar1;
  map<> *this_local;
  
  gp = &__global_pointer_;
  iVar1 = _Rb_tree<>::end(&this->_M_t);
  return (iterator)iVar1._M_node;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator!=(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node != __y->_M_node;
}



// DWARF original prototype: pointer operator->(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this)

pointer __thiscall std::_Rb_tree_iterator<>::operator->(_Rb_tree_iterator<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = _Rb_tree_node<>::_M_valptr(*(_Rb_tree_node<> **)this);
  return ppVar1;
}



// DWARF original name: pair<const pio_program*&, int&>
// DWARF original prototype: void
// pair<const_pio_program*&,_int&>(pair<const_pio_program*_const,_int> * this, pio_program * * __x,
// int * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,pio_program **__x,int *__y)

{
  pio_program **pppVar1;
  int *piVar2;
  int *__y_local;
  pio_program **__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pppVar1 = forward<>(__x);
  this->first = *pppVar1;
  piVar2 = forward<int&>(__y);
  this->second = *piVar2;
  return;
}



// DWARF original prototype: pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// insert(map<const_pio_program*,_int,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, value_type * __x)

undefined4 __thiscall std::map<>::insert(map<> *this,value_type *__x)

{
  type *__v;
  undefined4 uVar1;
  value_type *__x_local;
  map<> *this_local;
  
  gp = &__global_pointer_;
  __v = move<>(__x);
  uVar1 = _Rb_tree<>::_M_insert_unique<>(&this->_M_t,__v);
  return uVar1;
}



// DWARF original name: pair<const pio_program*&, unsigned int&>
// DWARF original prototype: void
// pair<const_pio_program*&,_unsigned_int&>(pair<const_pio_program*_const,_int> * this, pio_program
// * * __x, uint * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,pio_program **__x,uint *__y)

{
  pio_program **pppVar1;
  uint *puVar2;
  uint *__y_local;
  pio_program **__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pppVar1 = forward<>(__x);
  this->first = *pppVar1;
  puVar2 = forward<>(__y);
  this->second = *puVar2;
  return;
}



// DWARF original prototype: void
// _Rb_tree_key_compare(_Rb_tree_key_compare<std::less<const_pio_program*>_> * this)

void __thiscall std::_Rb_tree_key_compare<>::_Rb_tree_key_compare(_Rb_tree_key_compare<> *this)

{
  _Rb_tree_key_compare<> *this_local;
  
  gp = &__global_pointer_;
  return;
}



// DWARF original prototype: _Link_type
// _M_begin(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_begin(_Rb_tree<> *this)

{
  _Link_type p_Var1;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = _M_mbegin(this);
  return p_Var1;
}



// DWARF original prototype: iterator
// find(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, pio_program * * __k)

iterator __thiscall std::_Rb_tree<>::find(_Rb_tree<> *this,pio_program **__k)

{
  bool bVar1;
  _Link_type __x;
  _Base_ptr __y;
  undefined3 extraout_var;
  pio_program **pppVar2;
  undefined3 extraout_var_00;
  iterator iVar3;
  pio_program *__x_00;
  pio_program **__k_local;
  _Rb_tree<> *this_local;
  _Self local_18;
  iterator __j;
  
  gp = &__global_pointer_;
  __x = _M_begin(this);
  __y = _M_end(this);
  local_18._M_node = (_Base_ptr)_M_lower_bound(this,__x,__y,__k);
  __j = end(this);
  bVar1 = operator==(&local_18,&__j);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    __x_00 = *__k;
    pppVar2 = _S_key(local_18._M_node);
    bVar1 = less<>::operator()((less<> *)this,__x_00,*pppVar2);
    if (CONCAT31(extraout_var_00,bVar1) == 0) {
      return (iterator)local_18._M_node;
    }
  }
  iVar3 = end(this);
  return (iterator)iVar3._M_node;
}



// DWARF original prototype: iterator
// end(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

iterator __thiscall std::_Rb_tree<>::end(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  _Base_ptr local_14 [3];
  
  gp = &__global_pointer_;
  _Rb_tree_iterator<>::_Rb_tree_iterator
            ((_Rb_tree_iterator<> *)local_14,&(this->_M_impl).super__Rb_tree_header._M_header);
  return (iterator)local_14[0];
}



// DWARF original prototype: pair<const_pio_program*_const,_int> *
// _M_valptr(_Rb_tree_node<std::pair<const_pio_program*_const,_int>_> * this)

pair<> * __thiscall std::_Rb_tree_node<>::_M_valptr(_Rb_tree_node<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_node<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = __gnu_cxx::__aligned_membuf<>::_M_ptr(&this->_M_storage);
  return ppVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<const pio_program*&>

pio_program ** std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: move<std::pair<const pio_program* const, int>&>

type * std::move<>(pair<> *__t)

{
  pair<> *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original name: _M_insert_unique<std::pair<const pio_program* const, int> >
// DWARF original prototype: pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// _M_insert_unique<std::pair<const_pio_program*_const,_int>_>(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, pair<const_pio_program*_const,_int> * __v)

undefined4 __thiscall std::_Rb_tree<>::_M_insert_unique<>(_Rb_tree<> *this,pair<> *__v)

{
  _Alloc_node __x;
  _Rb_tree_node_base *__p;
  first_type *__k;
  pair<> *__v_00;
  _Rb_tree_node_base *extraout_a1;
  pair<> *__v_local;
  _Rb_tree<> *this_local;
  _Alloc_node _Stack_58;
  _Alloc_node __an;
  pair<> __res;
  undefined4 local_48;
  undefined4 local_40 [2];
  _Rb_tree_iterator<> local_38;
  bool local_31;
  undefined4 local_30 [2];
  _Rb_tree_iterator<> _Stack_28;
  bool local_21 [9];
  
  gp = &__global_pointer_;
  __k = _Select1st<>::operator()((_Select1st<> *)&__res.second,__v);
  __an._M_t = (_Rb_tree<> *)_M_get_insert_unique_pos(this,__k);
  __res.first = extraout_a1;
  if (extraout_a1 == (_Rb_tree_node_base *)0x0) {
    _Rb_tree_iterator<>::_Rb_tree_iterator((_Rb_tree_iterator<> *)&_Stack_28,(_Base_ptr)__an._M_t);
    local_21[0] = false;
    pair<>::pair<>((pair<> *)local_30,&_Stack_28,local_21);
    local_48 = local_30[0];
  }
  else {
    _Alloc_node::_Alloc_node(&_Stack_58,this);
    __p = __res.first;
    __x._M_t = __an._M_t;
    __v_00 = forward<>(__v);
    local_38._M_node = (_Base_ptr)_M_insert_<>(this,(_Base_ptr)__x._M_t,__p,__v_00,&_Stack_58);
    local_31 = true;
    pair<>::pair<>((pair<> *)local_40,&local_38,&local_31);
    local_48 = local_40[0];
  }
  return local_48;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<unsigned int&>

uint * std::forward<>(type_conflict *__t)

{
  type_conflict *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



_Link_type std::_Rb_tree<>::_S_right(_Base_ptr __x)

{
  _Base_ptr __x_local;
  
  gp = &__global_pointer_;
  return (_Link_type)__x->_M_right;
}



_Link_type std::_Rb_tree<>::_S_left(_Base_ptr __x)

{
  _Base_ptr __x_local;
  
  gp = &__global_pointer_;
  return (_Link_type)__x->_M_left;
}



// DWARF original prototype: _Link_type
// _M_mbegin(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_mbegin(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (_Link_type)(this->_M_impl).super__Rb_tree_header._M_header._M_parent;
}



// DWARF original prototype: _Base_ptr
// _M_end(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Base_ptr __thiscall std::_Rb_tree<>::_M_end(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return &(this->_M_impl).super__Rb_tree_header._M_header;
}



// DWARF original prototype: iterator
// _M_lower_bound(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, _Link_type __x, _Base_ptr __y, pio_program * * __k)

iterator __thiscall
std::_Rb_tree<>::_M_lower_bound(_Rb_tree<> *this,_Link_type __x,_Base_ptr __y,pio_program **__k)

{
  bool bVar1;
  pio_program **pppVar2;
  pio_program **__k_local;
  _Base_ptr __y_local;
  _Link_type __x_local;
  _Rb_tree<> *this_local;
  _Base_ptr local_14 [2];
  
  gp = &__global_pointer_;
  __k_local = (pio_program **)__y;
  __y_local = &__x->super__Rb_tree_node_base;
  while (__y_local != (_Base_ptr)0x0) {
    pppVar2 = _S_key((_Const_Link_type)__y_local);
    bVar1 = less<>::operator()((less<> *)this,*pppVar2,*__k);
    if (bVar1) {
      __y_local = &_S_right(__y_local)->super__Rb_tree_node_base;
    }
    else {
      __k_local = (pio_program **)__y_local;
      __y_local = &_S_left(__y_local)->super__Rb_tree_node_base;
    }
  }
  _Rb_tree_iterator<>::_Rb_tree_iterator((_Rb_tree_iterator<> *)local_14,(_Base_ptr)__k_local);
  return (iterator)local_14[0];
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

bool std::operator==(_Self *__x,_Self *__y)

{
  _Self *__y_local;
  _Self *__x_local;
  
  gp = &__global_pointer_;
  return __x->_M_node == __y->_M_node;
}



pio_program ** std::_Rb_tree<>::_S_key(_Const_Base_ptr __x)

{
  pio_program **pppVar1;
  _Const_Base_ptr __x_local;
  
  gp = &__global_pointer_;
  pppVar1 = _S_key((_Const_Link_type)__x);
  return pppVar1;
}



// WARNING: Removing unreachable block (ram,0x1000ee12)
// DWARF original prototype: bool operator()(less<const_pio_program*> * this, pio_program * __x,
// pio_program * __y)

bool __thiscall std::less<>::operator()(less<> *this,pio_program *__x,pio_program *__y)

{
  pio_program *__y_local;
  pio_program *__x_local;
  less<> *this_local;
  
  gp = &__global_pointer_;
  return __x < __y;
}



// DWARF original prototype: void _Rb_tree_iterator(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this, _Base_ptr __x)

void __thiscall std::_Rb_tree_iterator<>::_Rb_tree_iterator(_Rb_tree_iterator<> *this,_Base_ptr __x)

{
  _Base_ptr __x_local;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  *(_Base_ptr *)this = __x;
  return;
}



// DWARF original prototype: pair<const_pio_program*_const,_int> *
// _M_ptr(__aligned_membuf<std::pair<const_pio_program*_const,_int>_> * this)

pair<> * __thiscall __gnu_cxx::__aligned_membuf<>::_M_ptr(__aligned_membuf<> *this)

{
  pair<> *ppVar1;
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = (pair<> *)_M_addr(this);
  return ppVar1;
}



// DWARF original prototype: pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// _M_get_insert_unique_pos(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, key_type * __k)

_Rb_tree_node_base * __thiscall
std::_Rb_tree<>::_M_get_insert_unique_pos(_Rb_tree<> *this,key_type *__k)

{
  bool bVar1;
  undefined3 extraout_var;
  pio_program **pppVar2;
  undefined3 extraout_var_00;
  pio_program *__x_00;
  key_type *__k_local;
  _Rb_tree<> *this_local;
  _Self local_58;
  iterator __j;
  _Base_ptr __y;
  _Link_type __x;
  _Rb_tree_node_base *local_48;
  pair<> local_40;
  pair<> local_38;
  pair<> local_30;
  _Rb_tree_node_base *local_28;
  char local_21;
  bool __comp;
  
  gp = &__global_pointer_;
  __y = &_M_begin(this)->super__Rb_tree_node_base;
  __j._M_node = _M_end(this);
  local_21 = '\x01';
  while (__y != (_Base_ptr)0x0) {
    __j._M_node = __y;
    __x_00 = *__k;
    pppVar2 = _S_key((_Const_Link_type)__y);
    local_21 = less<>::operator()((less<> *)this,__x_00,*pppVar2);
    if ((bool)local_21) {
      __y = &_S_left(__y)->super__Rb_tree_node_base;
    }
    else {
      __y = &_S_right(__y)->super__Rb_tree_node_base;
    }
  }
  _Rb_tree_iterator<>::_Rb_tree_iterator((_Rb_tree_iterator<> *)&local_58,__j._M_node);
  if (local_21 != '\0') {
    __x = (_Link_type)begin(this);
    bVar1 = operator==(&local_58,(_Self *)&__x);
    if (CONCAT31(extraout_var,bVar1) != 0) {
      pair<>::pair<>(&local_40,(_Rb_tree_node<> **)&__y,&__j._M_node);
      return local_40.first;
    }
    _Rb_tree_iterator<>::operator--((_Rb_tree_iterator<> *)&local_58);
  }
  pppVar2 = _S_key(local_58._M_node);
  bVar1 = less<>::operator()((less<> *)this,*pppVar2,*__k);
  if (CONCAT31(extraout_var_00,bVar1) == 0) {
    local_28 = (_Rb_tree_node_base *)0x0;
    pair<>::pair<>(&local_30,&local_58._M_node,&local_28);
    local_48 = local_30.first;
  }
  else {
    pair<>::pair<>(&local_38,(_Rb_tree_node<> **)&__y,&__j._M_node);
    local_48 = local_38.first;
  }
  return local_48;
}



// DWARF original prototype: first_type *
// operator()(_Select1st<std::pair<const_pio_program*_const,_int>_> * this,
// pair<const_pio_program*_const,_int> * __x)

first_type * __thiscall std::_Select1st<>::operator()(_Select1st<> *this,pair<> *__x)

{
  pair<> *__x_local;
  _Select1st<> *this_local;
  
  gp = &__global_pointer_;
  return &__x->first;
}



// DWARF original prototype: void _Alloc_node(_Alloc_node * this,
// _Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * __t)

void __thiscall std::_Rb_tree<>::_Alloc_node::_Alloc_node(_Alloc_node *this,_Rb_tree<> *__t)

{
  _Rb_tree<> *__t_local;
  _Alloc_node *this_local;
  
  gp = &__global_pointer_;
  this->_M_t = __t;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::pair<const pio_program* const, int> >

pair<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// WARNING: Variable defined which should be unmapped: __insert_left
// DWARF original name: _M_insert_<std::pair<const pio_program* const, int>, std::_Rb_tree<const
// pio_program*, std::pair<const pio_program* const, int>, std::_Select1st<std::pair<const
// pio_program* const, int> >, std::less<const pio_program*>, std::allocator<std::pair<const
// pio_program* const, int> > >::_Alloc_node>
// DWARF original prototype: iterator
// _M_insert_<std::pair<const_pio_program*_const,_int>,_std::_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>::_Alloc_node>(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, _Base_ptr __x, _Base_ptr __p, pair<const_pio_program*_const,_int> * __v, _Alloc_node *
// __node_gen)

iterator __thiscall
std::_Rb_tree<>::_M_insert_<>
          (_Rb_tree<> *this,_Base_ptr __x,_Base_ptr __p,pair<> *__v,_Alloc_node *__node_gen)

{
  bool bVar1;
  _Base_ptr p_Var2;
  first_type *pppVar3;
  pio_program **pppVar4;
  undefined3 extraout_var;
  pair<> *__arg;
  pio_program *__x_00;
  _Alloc_node *__node_gen_local;
  pair<> *__v_local;
  _Base_ptr __p_local;
  _Base_ptr __x_local;
  _Rb_tree<> *this_local;
  _Base_ptr local_1c;
  _Link_type local_18;
  _Link_type __z;
  bool __insert_left;
  
  gp = &__global_pointer_;
  if ((__x == (_Base_ptr)0x0) && (p_Var2 = _M_end(this), __p != p_Var2)) {
    pppVar3 = _Select1st<>::operator()((_Select1st<> *)&this_local,__v);
    __x_00 = *pppVar3;
    pppVar4 = _S_key(__p);
    bVar1 = less<>::operator()((less<> *)this,__x_00,*pppVar4);
    if (CONCAT31(extraout_var,bVar1) == 0) {
      __z._3_1_ = 0;
      goto LAB_1000f0e0;
    }
  }
  __z._3_1_ = 1;
LAB_1000f0e0:
  __arg = forward<>(__v);
  local_18 = _Alloc_node::operator()<>(__node_gen,__arg);
  _Rb_tree_insert_and_rebalance
            ((bool)__z._3_1_,&local_18->super__Rb_tree_node_base,__p,
             &(this->_M_impl).super__Rb_tree_header._M_header);
  (this->_M_impl).super__Rb_tree_header._M_node_count =
       (this->_M_impl).super__Rb_tree_header._M_node_count + 1;
  _Rb_tree_iterator<>::_Rb_tree_iterator
            ((_Rb_tree_iterator<> *)&local_1c,&local_18->super__Rb_tree_node_base);
  return (iterator)local_1c;
}



// DWARF original name: pair<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> >,
// bool>
// DWARF original prototype: void
// pair<std::_Rb_tree_iterator<std::pair<const_pio_program*_const,_int>_>,_bool>(pair<std::_Rb_tree_iterator<std::pair<int_const,_int>_>,_bool>
// * this, _Rb_tree_iterator<std::pair<int_const,_int>_> * __x, bool * __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_iterator<> *__x,bool *__y)

{
  _Rb_tree_iterator<> *p_Var1;
  pair<> *ppVar2;
  bool *__y_local;
  _Rb_tree_iterator<> *__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = forward<>(__x);
  *(_Base_ptr *)this = p_Var1->_M_node;
  ppVar2 = (pair<> *)forward<bool>(__y);
  this[4] = *ppVar2;
  return;
}



pio_program ** std::_Rb_tree<>::_S_key(_Const_Link_type __x)

{
  pair<> *__x_00;
  first_type *pppVar1;
  _Const_Link_type __x_local;
  _Select1st<> a_Stack_14 [12];
  
  gp = &__global_pointer_;
  __x_00 = _Rb_tree_node<>::_M_valptr(__x);
  pppVar1 = _Select1st<>::operator()(a_Stack_14,__x_00);
  return pppVar1;
}



// DWARF original prototype: void *
// _M_addr(__aligned_membuf<std::pair<const_pio_program*_const,_int>_> * this)

void * __thiscall __gnu_cxx::__aligned_membuf<>::_M_addr(__aligned_membuf<> *this)

{
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  return this;
}



// DWARF original prototype: iterator
// begin(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

iterator __thiscall std::_Rb_tree<>::begin(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  _Base_ptr local_14 [3];
  
  gp = &__global_pointer_;
  _Rb_tree_iterator<>::_Rb_tree_iterator
            ((_Rb_tree_iterator<> *)local_14,(this->_M_impl).super__Rb_tree_header._M_header._M_left
            );
  return (iterator)local_14[0];
}



// DWARF original name: pair<std::_Rb_tree_node<std::pair<const pio_program* const, int> >*&,
// std::_Rb_tree_node_base*&>
// DWARF original prototype: void
// pair<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>*&,_std::_Rb_tree_node_base*&>(pair<std::_Rb_tree_node_base*,_std::_Rb_tree_node_base*>
// * this, _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> * * __x, _Rb_tree_node_base * *
// __y)

void __thiscall std::pair<>::pair<>(pair<> *this,_Rb_tree_node<> **__x,_Rb_tree_node_base **__y)

{
  _Rb_tree_node<> **pp_Var1;
  _Rb_tree_node_base **pp_Var2;
  _Rb_tree_node_base **__y_local;
  _Rb_tree_node<> **__x_local;
  pair<> *this_local;
  
  gp = &__global_pointer_;
  pp_Var1 = forward<>(__x);
  this->first = &(*pp_Var1)->super__Rb_tree_node_base;
  pp_Var2 = forward<>(__y);
  this->second = *pp_Var2;
  return;
}



// DWARF original prototype: _Self * operator--(_Rb_tree_iterator<std::pair<int_const,_int>_> *
// this)

_Self * __thiscall std::_Rb_tree_iterator<>::operator--(_Rb_tree_iterator<> *this)

{
  _Rb_tree_node_base *p_Var1;
  _Rb_tree_iterator<> *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = _Rb_tree_decrement(*(_Rb_tree_node_base **)this);
  *(_Rb_tree_node_base **)this = p_Var1;
  return (_Self *)this;
}



// DWARF original name: operator()<std::pair<const pio_program* const, int> >
// DWARF original prototype: _Link_type
// operator()<std::pair<const_pio_program*_const,_int>_>(_Alloc_node * this,
// pair<const_pio_program*_const,_int> * __arg)

_Link_type __thiscall std::_Rb_tree<>::_Alloc_node::operator()<>(_Alloc_node *this,pair<> *__arg)

{
  _Rb_tree<> *this_00;
  _Link_type p_Var1;
  pair<> *__arg_local;
  _Alloc_node *this_local;
  
  gp = &__global_pointer_;
  this_00 = this->_M_t;
  forward<>(__arg);
  p_Var1 = _M_create_node<>(this_00);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::_Rb_tree_iterator<std::pair<const pio_program* const, int> > >

_Rb_tree_iterator<> * std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original prototype: _Node_allocator *
// _M_get_Node_allocator(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Node_allocator * __thiscall std::_Rb_tree<>::_M_get_Node_allocator(_Rb_tree<> *this)

{
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  return (_Node_allocator *)this;
}



// DWARF original prototype: pair<const_pio_program*_const,_int> *
// _M_valptr(_Rb_tree_node<std::pair<const_pio_program*_const,_int>_> * this)

pair<> * __thiscall std::_Rb_tree_node<>::_M_valptr(_Rb_tree_node<> *this)

{
  pair<> *ppVar1;
  _Rb_tree_node<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = __gnu_cxx::__aligned_membuf<>::_M_ptr(&this->_M_storage);
  return ppVar1;
}



// DWARF original prototype: first_type *
// operator()(_Select1st<std::pair<const_pio_program*_const,_int>_> * this,
// pair<const_pio_program*_const,_int> * __x)

first_type * __thiscall std::_Select1st<>::operator()(_Select1st<> *this,pair<> *__x)

{
  pair<> *__x_local;
  _Select1st<> *this_local;
  
  gp = &__global_pointer_;
  return &__x->first;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// DWARF original name: forward<std::_Rb_tree_node<std::pair<const pio_program* const, int> >*&>

_Rb_tree_node<> ** std::forward<>(type *__t)

{
  type *__t_local;
  
  gp = &__global_pointer_;
  return __t;
}



// DWARF original name: _M_create_node<std::pair<const pio_program* const, int> >
// DWARF original prototype: _Link_type
// _M_create_node<std::pair<const_pio_program*_const,_int>_>(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_create_node<>(_Rb_tree<> *this)

{
  _Link_type __node;
  type *in_a1;
  _Rb_tree<> *this_local;
  _Link_type __tmp;
  
  gp = &__global_pointer_;
  __node = _M_get_node(this);
  forward<>(in_a1);
  _M_construct_node<>(this,__node);
  return __node;
}



// DWARF original prototype: pair<const_pio_program*_const,_int> *
// _M_ptr(__aligned_membuf<std::pair<const_pio_program*_const,_int>_> * this)

pair<> * __thiscall __gnu_cxx::__aligned_membuf<>::_M_ptr(__aligned_membuf<> *this)

{
  pair<> *ppVar1;
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  ppVar1 = (pair<> *)_M_addr(this);
  return ppVar1;
}



// DWARF original prototype: _Link_type
// _M_get_node(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this)

_Link_type __thiscall std::_Rb_tree<>::_M_get_node(_Rb_tree<> *this)

{
  _Node_allocator *this_00;
  _Rb_tree_node<> *p_Var1;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  this_00 = _M_get_Node_allocator(this);
  p_Var1 = __new_allocator<>::allocate((__new_allocator<> *)this_00,1,(void *)0x0);
  return p_Var1;
}



// DWARF original name: _M_construct_node<std::pair<const pio_program* const, int> >
// DWARF original prototype: void
// _M_construct_node<std::pair<const_pio_program*_const,_int>_>(_Rb_tree<const_pio_program*,_std::pair<const_pio_program*_const,_int>,_std::_Select1st<std::pair<const_pio_program*_const,_int>_>,_std::less<const_pio_program*>,_std::allocator<std::pair<const_pio_program*_const,_int>_>_>
// * this, _Link_type __node)

void __thiscall std::_Rb_tree<>::_M_construct_node<>(_Rb_tree<> *this,_Link_type __node)

{
  pair<> *ppVar1;
  pair<> *ppVar2;
  undefined4 *puVar3;
  type *in_a2;
  _Link_type __node_local;
  _Rb_tree<> *this_local;
  
  gp = &__global_pointer_;
  operator_new(0x18,__node);
  _M_get_Node_allocator(this);
  ppVar1 = _Rb_tree_node<>::_M_valptr(__node);
  ppVar2 = forward<>(in_a2);
  ppVar2 = forward<>(ppVar2);
  puVar3 = (undefined4 *)operator_new(8,ppVar1);
  ppVar1 = forward<>(ppVar2);
  *puVar3 = ppVar1->first;
  puVar3[1] = ppVar1->second;
  return;
}



// DWARF original prototype: void *
// _M_addr(__aligned_membuf<std::pair<const_pio_program*_const,_int>_> * this)

void * __thiscall __gnu_cxx::__aligned_membuf<>::_M_addr(__aligned_membuf<> *this)

{
  __aligned_membuf<> *this_local;
  
  gp = &__global_pointer_;
  return this;
}



// DWARF original prototype: _Rb_tree_node<std::pair<const_pio_program*_const,_int>_> *
// allocate(__new_allocator<std::_Rb_tree_node<std::pair<const_pio_program*_const,_int>_>_> * this,
// size_type __n, void * param_2)

_Rb_tree_node<> * __thiscall
std::__new_allocator<>::allocate(__new_allocator<> *this,size_type __n,void *param_2)

{
  _Rb_tree_node<> *p_Var1;
  void *param_2_local;
  size_type __n_local;
  __new_allocator<> *this_local;
  
  gp = &__global_pointer_;
  if (0x5555555 < __n) {
    if (0xaaaaaaa < __n) {
      __throw_bad_array_new_length();
    }
    __throw_bad_alloc();
  }
  p_Var1 = (_Rb_tree_node<> *)operator_new(__n * 0x18);
  return p_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  int iVar1;
  map<> *this;
  
  gp = &__global_pointer_;
  this = __pioMap;
  for (iVar1 = 2; -1 < iVar1; iVar1 = iVar1 + -1) {
    std::map<>::map(this);
    this = this + 1;
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN10PIOProgramC2EPK11pio_program(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



// DWARF original prototype: void begin(SerialUSB * this, ulong baud, uint16_t config)

void __thiscall SerialUSB::begin(SerialUSB *this,ulong baud,uint16_t config)

{
  _func_int_varargs *p_Var1;
  uint16_t config_local;
  ulong baud_local;
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  p_Var1 = (this->super_HardwareSerial).super_Stream.super_Print._vptr_Print[7];
  (*p_Var1)(baud,p_Var1);
  return;
}



void SerialUSB::_cb(int itf,uint8_t *dst,int len,void *param)

{
  void *param_local;
  int len_local;
  uint8_t *dst_local;
  int itf_local;
  
  gp = &__global_pointer_;
  interfaceCB((SerialUSB *)param,itf,dst,len);
  return;
}



// DWARF original prototype: void HardwareSerial(HardwareSerial * this)

void __thiscall arduino::HardwareSerial::HardwareSerial(HardwareSerial *this)

{
  HardwareSerial *this_local;
  
  gp = &__global_pointer_;
  Stream::Stream(&this->super_Stream);
  (this->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&DAT_10023670;
  return;
}



void reset_usb_boot(uint32_t usb_activity_gpio_pin_mask,uint32_t disable_interface_mask)

{
  uint32_t disable_interface_mask_local;
  uint32_t usb_activity_gpio_pin_mask_local;
  
  gp = &__global_pointer_;
                    // WARNING: Subroutine does not return
  rom_reset_usb_boot(usb_activity_gpio_pin_mask,disable_interface_mask);
}



// DWARF original prototype: void SerialUSB(SerialUSB * this)

void __thiscall SerialUSB::SerialUSB(SerialUSB *this)

{
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  arduino::HardwareSerial::HardwareSerial(&this->super_HardwareSerial);
  (this->super_HardwareSerial).super_Stream.super_Print._vptr_Print =
       (_func_int_varargs **)&PTR_write_1002363c;
  this->_running = false;
  this->_ss = (SyntheticState)((uint)this->_ss & 0xfffffffe);
  this->_ss = (SyntheticState)((uint)this->_ss & 0xfffffffd);
  this->_ss = (SyntheticState)((uint)this->_ss & 0xfffffffb);
  this->_ss = (SyntheticState)((uint)this->_ss & 0xfffffff7);
  this->_ss = (SyntheticState)((uint)this->_ss & 0xf | 0x1c2000);
  return;
}



// DWARF original prototype: void begin(SerialUSB * this, ulong baud)

void __thiscall SerialUSB::begin(SerialUSB *this,ulong baud)

{
  uint8_t uVar1;
  int __fd;
  code *__addr;
  SerialUSB *__len;
  ulong baud_local;
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  if (this->_running == false) {
    USBClass::disconnect(&USB);
    uVar1 = USBClass::registerEndpointIn(&USB);
    this->_epIn = uVar1;
    uVar1 = USBClass::registerEndpointOut(&USB);
    this->_epOut = uVar1;
    uVar1 = USBClass::registerEndpointIn(&USB);
    this->_epIn2 = uVar1;
    uVar1 = USBClass::registerString(&USB,"Pico Serial");
    this->_strID = uVar1;
    __addr = _cb;
    __fd = 2;
    __len = this;
    uVar1 = USBClass::registerInterface(&USB,2,_cb,this,0x42,1,0);
    this->_id = uVar1;
    USBClass::connect(&USB,__fd,(sockaddr *)__addr,(socklen_t)__len);
    this->_running = true;
  }
  return;
}



// DWARF original prototype: void interfaceCB(SerialUSB * this, int itf, uint8_t * dst, int len)

void __thiscall SerialUSB::interfaceCB(SerialUSB *this,int itf,uint8_t *dst,int len)

{
  int len_local;
  uint8_t *dst_local;
  int itf_local;
  SerialUSB *this_local;
  undefined1 local_54;
  undefined1 local_53;
  uint8_t local_52;
  undefined1 local_51;
  uint8_t desc [66];
  
  gp = &__global_pointer_;
  memset(&local_54,0,0x42);
  local_54 = 8;
  local_53 = 0xb;
  local_51 = 2;
  desc[0] = '\x02';
  desc[1] = '\x02';
  desc[4] = '\t';
  desc[5] = '\x04';
  desc[8] = '\x01';
  desc[9] = '\x02';
  desc[10] = '\x02';
  desc[0xd] = '\x05';
  desc[0xe] = '$';
  builtin_memcpy(desc + 0x10," \x01\x05$\x01",5);
  builtin_memcpy(desc + 0x17,"\x04$\x02\x06\x05$\x06",7);
  desc[0x20] = '\a';
  desc[0x21] = '\x05';
  desc[0x23] = '\x03';
  desc[0x24] = '\b';
  desc[0x26] = '\x10';
  desc[0x27] = '\t';
  desc[0x28] = '\x04';
  desc[0x2b] = '\x02';
  desc[0x2c] = '\n';
  desc[0x30] = '\a';
  desc[0x31] = '\x05';
  desc[0x33] = '\x02';
  desc[0x34] = '@';
  desc[0x37] = '\a';
  desc[0x38] = '\x05';
  desc[0x3a] = '\x02';
  desc[0x3b] = '@';
  local_52 = (uint8_t)itf;
  desc[0xc] = this->_strID;
  desc[0x16] = local_52 + '\x01';
  desc[0x1f] = local_52 + '\x01';
  desc[0x22] = this->_epIn;
  desc[0x29] = local_52 + '\x01';
  desc[0x32] = this->_epOut;
  desc[0x39] = this->_epIn2;
  desc[6] = local_52;
  desc[0x1e] = local_52;
  memcpy(dst,&local_54,len);
  return;
}



// DWARF original prototype: void end(SerialUSB * this)

void __thiscall SerialUSB::end(SerialUSB *this)

{
  sockaddr *in_a2;
  socklen_t in_a3;
  uint ep;
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  if (this->_running != false) {
    USBClass::disconnect(&USB);
    USBClass::unregisterInterface(&USB,(uint)this->_id);
    USBClass::unregisterEndpointIn(&USB,(uint)this->_epIn);
    ep = (uint)this->_epOut;
    USBClass::unregisterEndpointOut(&USB,ep);
    this->_running = false;
    USBClass::connect(&USB,ep,in_a2,in_a3);
  }
  return;
}



// DWARF original prototype: int peek(SerialUSB * this)

int __thiscall SerialUSB::peek(SerialUSB *this)

{
  uint uVar1;
  bool bVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  USBClass *chr;
  SerialUSB *this_local;
  undefined1 auStack_1c [3];
  uint8_t c;
  CoreMutex m;
  
  gp = &__global_pointer_;
  chr = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_1c,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar2 = CoreMutex::operator_bool((CoreMutex *)auStack_1c), bVar2)
     ) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  if (bVar2) {
    uVar1 = 0;
  }
  else {
    tud_task_ext(0xffffffff,false);
    chr = (USBClass *)((int)&this_local + 3);
    m._4_4_ = chr;
    _Var3 = tud_cdc_n_peek('\0',(uint8_t *)chr);
    if (CONCAT31(extraout_var,_Var3) == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      uVar1 = (uint)this_local._3_1_;
    }
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_1c,(int)chr);
  return uVar1;
}



// DWARF original prototype: int read(SerialUSB * this)

ssize_t __thiscall SerialUSB::read(SerialUSB *this,int __fd,void *__buf,size_t __nbytes)

{
  uint uVar1;
  bool bVar2;
  uint32_t uVar3;
  USBClass *buffer;
  SerialUSB *this_local;
  undefined1 auStack_1c [3];
  uint8_t ch;
  CoreMutex m;
  
  gp = &__global_pointer_;
  buffer = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_1c,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar2 = CoreMutex::operator_bool((CoreMutex *)auStack_1c), bVar2)
     ) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  if (bVar2) {
    uVar1 = 0xffffffff;
  }
  else {
    buffer = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
    uVar3 = tud_cdc_n_available('\0');
    if (uVar3 == 0) {
      uVar1 = 0xffffffff;
    }
    else {
      m._7_1_ = 0;
      buffer = (USBClass *)((int)&this_local + 3);
      uVar3 = tud_cdc_n_read('\0',buffer,1);
      if (uVar3 == 0) {
        uVar1 = 0xffffffff;
      }
      else {
        uVar1 = (uint)this_local._3_1_;
      }
    }
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_1c,(int)buffer);
  return uVar1;
}



// DWARF original prototype: int available(SerialUSB * this)

int __thiscall SerialUSB::available(SerialUSB *this)

{
  uint32_t uVar1;
  bool bVar2;
  USBClass *__in_chrg;
  SerialUSB *this_local;
  undefined1 auStack_18 [4];
  CoreMutex m;
  
  gp = &__global_pointer_;
  __in_chrg = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_18,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar2 = CoreMutex::operator_bool((CoreMutex *)auStack_18), bVar2)
     ) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  if (bVar2) {
    uVar1 = 0;
  }
  else {
    __in_chrg = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
    uVar1 = tud_cdc_n_available('\0');
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_18,(int)__in_chrg);
  return uVar1;
}



// DWARF original prototype: int availableForWrite(SerialUSB * this)

int __thiscall SerialUSB::availableForWrite(SerialUSB *this)

{
  uint32_t uVar1;
  bool bVar2;
  USBClass *__in_chrg;
  SerialUSB *this_local;
  undefined1 auStack_18 [4];
  CoreMutex m;
  
  gp = &__global_pointer_;
  __in_chrg = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_18,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar2 = CoreMutex::operator_bool((CoreMutex *)auStack_18), bVar2)
     ) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  if (bVar2) {
    uVar1 = 0;
  }
  else {
    __in_chrg = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
    uVar1 = tud_cdc_n_write_available('\0');
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_18,(int)__in_chrg);
  return uVar1;
}



// DWARF original prototype: void flush(SerialUSB * this)

void __thiscall SerialUSB::flush(SerialUSB *this)

{
  bool bVar1;
  USBClass *__in_chrg;
  SerialUSB *this_local;
  undefined1 auStack_18 [4];
  CoreMutex m;
  
  gp = &__global_pointer_;
  __in_chrg = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_18,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar1 = CoreMutex::operator_bool((CoreMutex *)auStack_18), bVar1)
     ) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (!bVar1) {
    tud_cdc_n_write_flush('\0');
    __in_chrg = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_18,(int)__in_chrg);
  return;
}



// DWARF original prototype: size_t write(SerialUSB * this, uint8_t c)

ssize_t __thiscall SerialUSB::write(SerialUSB *this,int __fd,void *__buf,size_t __n)

{
  int iVar1;
  _func_int_varargs *p_Var2;
  undefined1 local_15;
  SerialUSB *pSStack_14;
  uint8_t c_local;
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  local_15 = (undefined1)__fd;
  p_Var2 = (this->super_HardwareSerial).super_Stream.super_Print._vptr_Print[1];
  pSStack_14 = this;
  iVar1 = (*p_Var2)(&local_15,1,p_Var2);
  return iVar1;
}



// DWARF original prototype: size_t write(SerialUSB * this, uint8_t * buf, size_t length)

ssize_t __thiscall SerialUSB::write(SerialUSB *this,int __fd,void *__buf,size_t __n)

{
  bool bVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  uint32_t uVar3;
  uint uVar4;
  USBClass *__in_chrg;
  int extraout_a1;
  uint extraout_a1_00;
  uint uVar5;
  size_t length_local;
  uint8_t *buf_local;
  SerialUSB *this_local;
  undefined1 auStack_34 [4];
  CoreMutex m;
  int n2;
  int avail;
  int n;
  size_t i;
  int written;
  
  gp = &__global_pointer_;
  __in_chrg = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_34,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar1 = CoreMutex::operator_bool((CoreMutex *)auStack_34), bVar1)
     ) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    i = 0;
  }
  else {
    i = 0;
    _Var2 = tud_cdc_n_connected('\0');
    if ((CONCAT31(extraout_var,_Var2) == 0) && (((uint)this->_ss & 2) == 0)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    if (bVar1) {
      n = 0;
      do {
        while( true ) {
          if (__buf <= (uint)n) goto LAB_1000fe68;
          uVar3 = tud_cdc_n_write_available('\0');
          avail = (int)__buf - n;
          if ((int)uVar3 < (int)__buf - n) {
            avail = uVar3;
          }
          if (avail == 0) break;
          m._acquired = (bool)(undefined1)avail;
          m._option = avail._1_1_;
          m._6_2_ = avail._2_2_;
          uVar3 = tud_cdc_n_write('\0',(void *)(__fd + n),avail);
          tud_task_ext(0xffffffff,false);
          tud_cdc_n_write_flush('\0');
          n = uVar3 + n;
          i = uVar3 + i;
          write::last_avail_time._0_4_ = time_us_64();
          write::last_avail_time._4_4_ = extraout_a1;
        }
        tud_task_ext(0xffffffff,false);
        tud_cdc_n_write_flush('\0');
        _Var2 = tud_cdc_n_connected('\0');
        if (_Var2) {
          uVar3 = tud_cdc_n_write_available('\0');
          if (uVar3 == 0) {
            uVar4 = time_us_64();
            uVar5 = (uint)((uint)write::last_avail_time + 1000000 < (uint)write::last_avail_time) +
                    write::last_avail_time._4_4_;
            if ((uVar5 < extraout_a1_00) ||
               ((extraout_a1_00 == uVar5 && ((uint)write::last_avail_time + 1000000 < uVar4))))
            goto LAB_1000fe42;
          }
          bVar1 = false;
        }
        else {
LAB_1000fe42:
          bVar1 = true;
        }
      } while (!bVar1);
    }
    else {
      write::last_avail_time._0_4_ = 0;
      write::last_avail_time._4_4_ = 0;
    }
LAB_1000fe68:
    __in_chrg = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_34,(int)__in_chrg);
  return i;
}



// DWARF original name: operator bool
// DWARF original prototype: bool operator_bool(SerialUSB * this)

bool __thiscall SerialUSB::operator_bool(SerialUSB *this)

{
  bool bVar1;
  _Bool _Var2;
  USBClass *__in_chrg;
  SerialUSB *this_local;
  undefined1 auStack_18 [4];
  CoreMutex m;
  
  gp = &__global_pointer_;
  __in_chrg = &USB;
  CoreMutex::CoreMutex((CoreMutex *)auStack_18,&USB.mutex,'\0');
  if ((this->_running == true) && (bVar1 = CoreMutex::operator_bool((CoreMutex *)auStack_18), bVar1)
     ) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    _Var2 = false;
  }
  else {
    __in_chrg = (USBClass *)0x0;
    tud_task_ext(0xffffffff,false);
    _Var2 = tud_cdc_n_connected('\0');
  }
  CoreMutex::~CoreMutex((CoreMutex *)auStack_18,(int)__in_chrg);
  return _Var2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// DWARF original prototype: void checkSerialReset(SerialUSB * this)

void __thiscall SerialUSB::checkSerialReset(SerialUSB *this)

{
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  if (((((uint)this->_ss & 1) == 0) && (((uint)this->_ss & 0xfffffff0) == 0x4b00)) &&
     (((uint)this->_ss & 4) == 0)) {
    this->_ss = (SyntheticState)((uint)this->_ss | 1);
    irq_set_enabled(0xe,false);
    _DAT_40022000 = 0x10000000;
    _DAT_40023000 = 0x10000000;
    busy_wait_ms(3);
                    // WARNING: Subroutine does not return
    reset_usb_boot(0,0);
  }
  return;
}



void tud_cdc_line_state_cb(uint8_t itf,bool dtr,bool rts)

{
  bool rts_local;
  bool dtr_local;
  uint8_t itf_local;
  
  gp = &__global_pointer_;
  SerialUSB::tud_cdc_line_state_cb(&Serial,itf,dtr,rts);
  return;
}



// DWARF original prototype: void tud_cdc_line_state_cb(SerialUSB * this, uint8_t itf, bool dtr,
// bool rts)

void __thiscall SerialUSB::tud_cdc_line_state_cb(SerialUSB *this,uint8_t itf,bool dtr,bool rts)

{
  bool rts_local;
  bool dtr_local;
  uint8_t itf_local;
  SerialUSB *this_local;
  
  gp = &__global_pointer_;
  this->_ss = (SyntheticState)((uint)dtr << 2 | (uint)this->_ss & 0xfffffffb);
  this->_ss = (SyntheticState)((uint)rts << 3 | (uint)this->_ss & 0xfffffff7);
  checkSerialReset(this);
  return;
}



void tud_cdc_line_coding_cb(uint8_t itf,cdc_line_coding_t *p_line_coding)

{
  cdc_line_coding_t *p_line_coding_local;
  uint8_t itf_local;
  
  gp = &__global_pointer_;
  SerialUSB::tud_cdc_line_coding_cb(&Serial,itf,p_line_coding);
  return;
}



// DWARF original prototype: void tud_cdc_line_coding_cb(SerialUSB * this, uint8_t itf, void * p)

void __thiscall SerialUSB::tud_cdc_line_coding_cb(SerialUSB *this,uint8_t itf,void *p)

{
  void *p_local;
  uint8_t itf_local;
  SerialUSB *this_local;
  cdc_line_coding_t *p_line_coding;
  
  gp = &__global_pointer_;
                    // WARNING: Load size is inaccurate
  this->_ss = (SyntheticState)(*p << 4 | (uint)this->_ss & 0xf);
  checkSerialReset(this);
  return;
}



// WARNING: Removing unreachable block (ram,0x10010156)
// WARNING: Removing unreachable block (ram,0x10010166)
// WARNING: Removing unreachable block (ram,0x1001016e)

void arduino::serialEventRun(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  SerialUSB::SerialUSB(&Serial);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I__ZN9SerialUSBC2Ev(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



undefined4 to_us_since_boot(absolute_time_t t)

{
  undefined4 in_a0;
  absolute_time_t t_local;
  
  gp = &__global_pointer_;
  return in_a0;
}



void update_us_since_boot(absolute_time_t *t,uint64_t us_since_boot)

{
  undefined4 in_a1;
  undefined4 in_a2;
  uint64_t us_since_boot_local;
  absolute_time_t *t_local;
  
  gp = &__global_pointer_;
  *(undefined4 *)t = in_a1;
  *(undefined4 *)((int)t + 4) = in_a2;
  return;
}



// WARNING: Unknown calling convention

undefined4 get_absolute_time(void)

{
  undefined4 local_18;
  absolute_time_t t;
  
  gp = &__global_pointer_;
  time_us_64();
  update_us_since_boot((absolute_time_t *)&local_18,uRam00000010);
  return local_18;
}



undefined4 delayed_by_us(absolute_time_t t,uint64_t us)

{
  int extraout_a1;
  int in_a2;
  int in_a3;
  uint64_t us_local;
  absolute_time_t t_local;
  undefined4 local_28;
  absolute_time_t t2;
  uint64_t base;
  uint64_t delayed;
  
  gp = &__global_pointer_;
  t2._4_4_ = to_us_since_boot(t);
  base._4_4_ = t2._4_4_ + in_a2;
  delayed._0_4_ = (uint)(base._4_4_ < t2._4_4_) + extraout_a1 + in_a3;
  if ((int)delayed < 0) {
    base._4_4_ = 0xffffffff;
    delayed._0_4_ = 0x7fffffff;
  }
  base._0_4_ = extraout_a1;
  update_us_since_boot((absolute_time_t *)&local_28,t);
  return local_28;
}



alarm_id_t
alarm_pool_add_alarm_in_us
          (alarm_pool_t *pool,uint64_t us,alarm_callback_t callback,void *user_data,
          bool fire_if_past)

{
  alarm_callback_t callback_00;
  alarm_id_t aVar1;
  void *user_data_00;
  bool fire_if_past_local;
  void *user_data_local;
  uint64_t us_local;
  alarm_callback_t callback_local;
  alarm_pool_t *pool_local;
  
  gp = &__global_pointer_;
  get_absolute_time();
  callback_00 = (alarm_callback_t)delayed_by_us(us,uRam00000018);
  aVar1 = alarm_pool_add_alarm_at(pool,us,callback_00,user_data_00,fire_if_past);
  return aVar1;
}



alarm_id_t add_alarm_in_us(uint64_t us,alarm_callback_t callback,void *user_data,bool fire_if_past)

{
  alarm_pool_t *pool;
  alarm_id_t aVar1;
  bool fire_if_past_local;
  void *user_data_local;
  alarm_callback_t callback_local;
  uint64_t us_local;
  
  gp = &__global_pointer_;
  pool = alarm_pool_get_default();
  aVar1 = alarm_pool_add_alarm_in_us(pool,us,callback,user_data,fire_if_past);
  return aVar1;
}



// DWARF original prototype: void USBClass(USBClass * this)

void __thiscall USBClass::USBClass(USBClass *this)

{
  USBClass *this_local;
  
  gp = &__global_pointer_;
  this->_hids = (Entry *)0x0;
  this->_interfaces = (Entry *)0x0;
  this->usbd_desc_str = (char **)0x0;
  this->usbd_desc_str_cnt = '\0';
  this->usbd_desc_str_alloc = '\0';
  this->_hid_interface = 0xff;
  this->_hid_endpoint = '\0';
  this->_hid_report_len = 0;
  this->_hid_report = (uint8_t *)0x0;
  this->usbd_desc_cfg = (uint8_t *)0x0;
  this->usbd_desc_cfg_len = 0;
  this->_endpointIn = 0xfffe;
  this->_endpointOut = 0xfffe;
  this->_forceVID = 0;
  this->_forcePID = 0;
  this->_forceManuf = '\0';
  this->_forceProd = '\0';
  this->_forceSerial = '\0';
  return;
}



void USBClass::simpleInterface(int itf,uint8_t *dst,int len,void *data)

{
  void *data_local;
  int len_local;
  uint8_t *dst_local;
  int itf_local;
  
  gp = &__global_pointer_;
  memcpy(dst,data,len);
  dst[2] = (uint8_t)itf;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint8_t registerEndpointIn(USBClass * this)

uint8_t __thiscall USBClass::registerEndpointIn(USBClass *this)

{
  USBClass *this_local;
  int firstFree;
  
  gp = &__global_pointer_;
  if (this->_endpointIn == 0) {
    return '\0';
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: void unregisterEndpointIn(USBClass * this, int ep)

void __thiscall USBClass::unregisterEndpointIn(USBClass *this,int ep)

{
  int ep_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint8_t registerEndpointOut(USBClass * this)

uint8_t __thiscall USBClass::registerEndpointOut(USBClass *this)

{
  USBClass *this_local;
  int firstFree;
  
  gp = &__global_pointer_;
  if (this->_endpointOut == 0) {
    return '\0';
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: void unregisterEndpointOut(USBClass * this, int ep)

void __thiscall USBClass::unregisterEndpointOut(USBClass *this,int ep)

{
  int ep_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint8_t addEntry(USBClass * this, Entry * * head, int interfaces,
// _func_void_int_uint8_t_ptr_int_void_ptr * cb, void * param, size_t len, int ordering, uint32_t
// pidMask)

uint8_t __thiscall
USBClass::addEntry(USBClass *this,Entry **head,int interfaces,
                  _func_void_int_uint8_t_ptr_int_void_ptr *cb,void *param,size_t len,int ordering,
                  uint32_t pidMask)

{
  undefined4 *puVar1;
  uint32_t pidMask_local;
  int ordering_local;
  size_t len_local;
  void *param_local;
  _func_void_int_uint8_t_ptr_int_void_ptr *cb_local;
  int interfaces_local;
  Entry **head_local;
  USBClass *this_local;
  Entry *n;
  Entry *cur;
  Entry *prev;
  
  gp = &__global_pointer_;
  puVar1 = (undefined4 *)__wrap_malloc(0x18);
  *puVar1 = cb;
  puVar1[1] = param;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// DWARF original prototype: void removeEntry(USBClass * this, Entry * * head, uint localid)

void __thiscall USBClass::removeEntry(USBClass *this,Entry **head,uint localid)

{
  Entry *pEVar1;
  uint localid_local;
  Entry **head_local;
  USBClass *this_local;
  Entry *p;
  Entry *cur;
  Entry *prev;
  
  gp = &__global_pointer_;
  cur = (Entry *)0x0;
  p = *head;
  while ((p != (Entry *)0x0 && (localid != (*(uint *)&p->field_0xc >> 0x12 & 0x3f)))) {
    cur = p;
    p = p->next;
  }
  if (p != (Entry *)0x0) {
    if (p == *head) {
      pEVar1 = p->next;
      __wrap_free(*head);
      *head = pEVar1;
    }
    else {
      cur->next = p->next;
      __wrap_free(p);
    }
  }
  return;
}



// DWARF original prototype: uint8_t registerInterface(USBClass * this, int interfaces,
// _func_void_int_uint8_t_ptr_int_void_ptr * cb, void * param, size_t len, int ordering, uint32_t
// pidMask)

uint8_t __thiscall
USBClass::registerInterface
          (USBClass *this,int interfaces,_func_void_int_uint8_t_ptr_int_void_ptr *cb,void *param,
          size_t len,int ordering,uint32_t pidMask)

{
  uint8_t uVar1;
  uint32_t pidMask_local;
  int ordering_local;
  size_t len_local;
  void *param_local;
  _func_void_int_uint8_t_ptr_int_void_ptr *cb_local;
  int interfaces_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  uVar1 = addEntry(this,&this->_interfaces,interfaces,cb,param,len,ordering,pidMask);
  return uVar1;
}



// DWARF original prototype: void unregisterInterface(USBClass * this, uint localid)

void __thiscall USBClass::unregisterInterface(USBClass *this,uint localid)

{
  uint localid_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  removeEntry(this,&this->_interfaces,localid);
  return;
}



// DWARF original prototype: uint8_t registerString(USBClass * this, char * str)

uint8_t __thiscall USBClass::registerString(USBClass *this,char *str)

{
  uint8_t uVar1;
  char **ppcVar2;
  int iVar3;
  char *str_local;
  USBClass *this_local;
  uint local_14;
  size_t i;
  
  gp = &__global_pointer_;
  if (this->usbd_desc_str_alloc <= this->usbd_desc_str_cnt) {
    this->usbd_desc_str_alloc = this->usbd_desc_str_alloc + '\x04';
    ppcVar2 = (char **)__wrap_realloc(this->usbd_desc_str,(uint)this->usbd_desc_str_alloc << 2);
    this->usbd_desc_str = ppcVar2;
  }
  if (this->usbd_desc_str_cnt == '\0') {
    *this->usbd_desc_str = "";
    this->usbd_desc_str_cnt = this->usbd_desc_str_cnt + '\x01';
  }
  local_14 = 0;
  while( true ) {
    if (this->usbd_desc_str_cnt <= local_14) {
      this->usbd_desc_str[this->usbd_desc_str_cnt] = str;
      uVar1 = this->usbd_desc_str_cnt;
      this->usbd_desc_str_cnt = uVar1 + '\x01';
      return uVar1;
    }
    iVar3 = strcmp(str,this->usbd_desc_str[local_14]);
    if (iVar3 == 0) break;
    local_14 = local_14 + 1;
  }
  gp = &__global_pointer_;
  return (uint8_t)local_14;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint8_t * tud_descriptor_device_cb(USBClass * this)

uint8_t * __thiscall USBClass::tud_descriptor_device_cb(USBClass *this)

{
  undefined1 uVar1;
  USBClass *this_local;
  Entry *h;
  
  gp = &__global_pointer_;
  if (tud_descriptor_device_cb::idString[0] == '\0') {
    pico_get_unique_board_id_string(tud_descriptor_device_cb::idString,0x19);
  }
  if (this->_forceVID == 0) {
    uVar1 = 0x8a;
  }
  else {
    uVar1 = (undefined1)this->_forceVID;
  }
  if (this->_forceManuf == '\0') {
    registerString(&USB,"Generic");
  }
  if (this->_forceProd == '\0') {
    registerString(&USB,"RP2350");
  }
  if (this->_forceSerial == '\0') {
    registerString(&USB,tud_descriptor_device_cb::idString);
  }
  (this->usbd_desc_device).bLength = '\x12';
  (this->usbd_desc_device).bDescriptorType = '\x01';
  *(undefined1 *)&(this->usbd_desc_device).bcdUSB = 0;
  *(undefined1 *)((int)&(this->usbd_desc_device).bcdUSB + 1) = 2;
  (this->usbd_desc_device).bDeviceClass = 0xef;
  (this->usbd_desc_device).bDeviceSubClass = '\x02';
  (this->usbd_desc_device).bDeviceProtocol = '\x01';
  (this->usbd_desc_device).bMaxPacketSize0 = '@';
  *(undefined1 *)&(this->usbd_desc_device).idVendor = uVar1;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

uint8_t * tud_descriptor_device_cb(void)

{
  uint8_t *puVar1;
  
  gp = &__global_pointer_;
  puVar1 = USBClass::tud_descriptor_device_cb(&USB);
  return puVar1;
}



// DWARF original prototype: uint8_t * getDescHIDReport(USBClass * this, int * len)

uint8_t * __thiscall USBClass::getDescHIDReport(USBClass *this,int *len)

{
  int *len_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  if (len != (int *)0x0) {
    *len = (uint)this->_hid_report_len;
  }
  return this->_hid_report;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: void setupDescHIDReport(USBClass * this)

void __thiscall USBClass::setupDescHIDReport(USBClass *this)

{
  uint8_t *puVar1;
  USBClass *this_local;
  char buff [2];
  uint8_t id;
  uint8_t *p;
  Entry *h;
  
  gp = &__global_pointer_;
  this->_hid_report_len = 0;
  if (this->_hids != (Entry *)0x0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if (this->_hid_report_len == 0) {
    this->_hid_report = (uint8_t *)0x0;
  }
  else {
    puVar1 = (uint8_t *)__wrap_malloc((uint)this->_hid_report_len);
    this->_hid_report = puVar1;
    if (this->_hids != (Entry *)0x0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
  return;
}



uint8_t * tud_hid_descriptor_report_cb(uint8_t instance)

{
  uint8_t *puVar1;
  uint8_t instance_local;
  
  gp = &__global_pointer_;
  puVar1 = USBClass::tud_hid_descriptor_report_cb(&USB,instance);
  return puVar1;
}



// DWARF original prototype: uint8_t * tud_hid_descriptor_report_cb(USBClass * this, uint8_t
// instance)

uint8_t * __thiscall USBClass::tud_hid_descriptor_report_cb(USBClass *this,uint8_t instance)

{
  uint8_t *puVar1;
  uint8_t instance_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  puVar1 = getDescHIDReport(this,(int *)0x0);
  return puVar1;
}



uint8_t * tud_descriptor_configuration_cb(uint8_t index)

{
  uint8_t *puVar1;
  uint8_t index_local;
  
  gp = &__global_pointer_;
  puVar1 = USBClass::tud_descriptor_configuration_cb(&USB,index);
  return puVar1;
}



// DWARF original prototype: uint8_t * tud_descriptor_configuration_cb(USBClass * this, uint8_t
// index)

uint8_t * __thiscall USBClass::tud_descriptor_configuration_cb(USBClass *this,uint8_t index)

{
  uint8_t index_local;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  return USB.usbd_desc_cfg;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: void setupUSBDescriptor(USBClass * this)

void __thiscall USBClass::setupUSBDescriptor(USBClass *this)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  USBClass *this_local;
  undefined4 local_4c;
  uint8_t hid_desc [25];
  uint8_t tud_cfg_desc [9];
  undefined2 uStack_23;
  int hid_report_len;
  int id;
  uint8_t *p;
  Entry *h;
  uint8_t interface_count;
  
  gp = &__global_pointer_;
  if (this->usbd_desc_cfg != (uint8_t *)0x0) {
    return;
  }
  unique0x1000004d = uStack_23;
  puVar2 = getDescHIDReport(this,(int *)(tud_cfg_desc + 8));
  if (puVar2 != (uint8_t *)0x0) {
    hid_desc[0x14] = '\0';
    local_4c = 0x10409;
    hid_desc[0] = '\x01';
    hid_desc[1] = '\x03';
    hid_desc[2] = '\0';
    hid_desc[3] = '\0';
    hid_desc[4] = '\0';
    hid_desc[5] = '\t';
    hid_desc[6] = '!';
    hid_desc[7] = '\x11';
    hid_desc[8] = '\x01';
    hid_desc[9] = '\0';
    hid_desc[10] = '\x01';
    hid_desc[0xb] = '\"';
    hid_desc[0x10] = '\0';
    hid_desc[0x11] = '\x03';
    hid_desc[0x12] = '@';
    hid_desc[0x13] = '\0';
    hid_desc[0xe] = '\a';
    hid_desc[0xf] = '\x05';
    hid_desc[0xc] = tud_cfg_desc[8];
    hid_desc[0xd] = (undefined1)uStack_23;
    uVar1 = registerEndpointIn(&USB);
    this->_hid_endpoint = uVar1;
    hid_desc[0x10] = this->_hid_endpoint;
    hid_desc[0x14] = (uint8_t)usb_hid_poll_interval;
    uVar1 = registerInterface(&USB,1,simpleInterface,&local_4c,0x19,10,0);
    this->_hid_interface = uVar1;
  }
  this->usbd_desc_cfg_len = 9;
  if (this->_interfaces == (Entry *)0x0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



uint16_t * tud_descriptor_string_cb(uint8_t index,uint16_t langid)

{
  uint16_t *puVar1;
  uint16_t langid_local;
  uint8_t index_local;
  
  gp = &__global_pointer_;
  puVar1 = USBClass::tud_descriptor_string_cb(&USB,index,langid);
  return puVar1;
}



// WARNING: Control flow encountered unimplemented instructions
// DWARF original prototype: uint16_t * tud_descriptor_string_cb(USBClass * this, uint8_t index,
// uint16_t langid)

uint16_t * __thiscall
USBClass::tud_descriptor_string_cb(USBClass *this,uint8_t index,uint16_t langid)

{
  char *pcVar1;
  uint16_t langid_local;
  uint8_t index_local;
  USBClass *this_local;
  char *str;
  uint8_t len;
  
  gp = &__global_pointer_;
  if (index == '\0') {
    tud_descriptor_string_cb::desc_str[1] = 0x409;
  }
  else {
    if (this->usbd_desc_str_cnt <= index) {
      return (uint16_t *)0x0;
    }
    pcVar1 = this->usbd_desc_str[index];
    for (str._3_1_ = 0; (str._3_1_ < 0x1f && (pcVar1[str._3_1_] != '\0')); str._3_1_ = str._3_1_ + 1
        ) {
      tud_descriptor_string_cb::desc_str[str._3_1_ + 1] = (ushort)(byte)pcVar1[str._3_1_];
    }
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



void USBClass::usbIRQ(void)

{
  _Bool _Var1;
  undefined3 extraout_var;
  
  gp = &__global_pointer_;
  _Var1 = mutex_try_enter(&USB.mutex,(uint32_t *)0x0);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    tud_task_ext(0xffffffff,false);
    mutex_exit(&USB.mutex);
  }
  return;
}



undefined4 USBClass::timerTask(alarm_id_t id,void *user_data)

{
  void *user_data_local;
  alarm_id_t id_local;
  
  gp = &__global_pointer_;
  irq_set_pending((uint)USB.usbTaskIRQ);
  return 1000;
}



// DWARF original prototype: void disconnect(USBClass * this)

void __thiscall USBClass::disconnect(USBClass *this)

{
  _Bool _Var1;
  USBClass *this_local;
  bool wasConnected;
  
  gp = &__global_pointer_;
  _Var1 = tud_connected();
  mutex_enter_blocking(&USB.mutex);
  tud_disconnect();
  if (_Var1) {
    sleep_ms(500);
  }
  mutex_exit(&USB.mutex);
  __wrap_free(this->usbd_desc_cfg);
  this->usbd_desc_cfg = (uint8_t *)0x0;
  this->usbd_desc_cfg_len = 0;
  if (this->_hid_report != (uint8_t *)0x0) {
    unregisterInterface(this,(uint)this->_hid_interface);
    unregisterEndpointIn(this,(uint)this->_hid_endpoint);
  }
  __wrap_free(this->_hid_report);
  this->_hid_report = (uint8_t *)0x0;
  this->_hid_report_len = 0;
  return;
}



// DWARF original prototype: void connect(USBClass * this)

int __thiscall USBClass::connect(USBClass *this,int __fd,sockaddr *__addr,socklen_t __len)

{
  int extraout_a0;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  setupDescHIDReport(this);
  setupUSBDescriptor(this);
  mutex_enter_blocking(&USB.mutex);
  tud_connect();
  mutex_exit(&USB.mutex);
  return extraout_a0;
}



// DWARF original prototype: void begin(USBClass * this)

void __thiscall USBClass::begin(USBClass *this)

{
  _Bool _Var1;
  undefined3 extraout_var;
  int iVar2;
  USBClass *this_local;
  
  gp = &__global_pointer_;
  _Var1 = tusb_inited();
  if (CONCAT31(extraout_var,_Var1) == 0) {
    setupDescHIDReport(this);
    setupUSBDescriptor(this);
    mutex_init(&this->mutex);
    tusb_rhport_init('\0',(tusb_rhport_init_t_conflict *)0x0);
    iVar2 = user_irq_claim_unused(true);
    this->usbTaskIRQ = (uint8_t)iVar2;
    irq_set_exclusive_handler((uint)this->usbTaskIRQ,usbIRQ);
    irq_set_enabled((uint)this->usbTaskIRQ,true);
    add_alarm_in_us(uRam00000010,(alarm_callback_t)&DAT_000003e8,(void *)0x0,true);
  }
  return;
}



uint16_t tud_hid_get_report_cb
                   (uint8_t instance,uint8_t report_id,hid_report_type_t report_type,uint8_t *buffer
                   ,uint16_t reqlen)

{
  uint8_t *buffer_local;
  hid_report_type_t report_type_local;
  uint16_t reqlen_local;
  uint8_t report_id_local;
  uint8_t instance_local;
  
  gp = &__global_pointer_;
  return 0;
}



void tud_hid_set_report_cb
               (uint8_t instance,uint8_t report_id,hid_report_type_t report_type,uint8_t *buffer,
               uint16_t bufsize)

{
  uint8_t *buffer_local;
  hid_report_type_t report_type_local;
  uint16_t bufsize_local;
  uint8_t report_id_local;
  uint8_t instance_local;
  
  gp = &__global_pointer_;
  return;
}



int32_t tud_msc_read10_cb(uint8_t lun,uint32_t lba,uint32_t offset,void *buffer,uint32_t bufsize)

{
  uint32_t bufsize_local;
  void *buffer_local;
  uint32_t offset_local;
  uint32_t lba_local;
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  return -1;
}



bool tud_msc_test_unit_ready_cb(uint8_t lun)

{
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  return false;
}



int32_t tud_msc_write10_cb(uint8_t lun,uint32_t lba,uint32_t offset,uint8_t *buffer,uint32_t bufsize
                          )

{
  uint32_t bufsize_local;
  uint8_t *buffer_local;
  uint32_t offset_local;
  uint32_t lba_local;
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  return -1;
}



int32_t tud_msc_scsi_cb(uint8_t lun,uint8_t *scsi_cmd,void *buffer,uint16_t bufsize)

{
  void *buffer_local;
  uint8_t *scsi_cmd_local;
  uint16_t bufsize_local;
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  return 0;
}



void tud_msc_capacity_cb(uint8_t lun,uint32_t *block_count,uint16_t *block_size)

{
  uint16_t *block_size_local;
  uint32_t *block_count_local;
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  *block_count = 0;
  *block_size = 0;
  return;
}



void tud_msc_inquiry_cb(uint8_t lun,uint8_t *vendor_id,uint8_t *product_id,uint8_t *product_rev)

{
  uint8_t *product_rev_local;
  uint8_t *product_id_local;
  uint8_t *vendor_id_local;
  uint8_t lun_local;
  
  gp = &__global_pointer_;
  *vendor_id = '\0';
  *product_id = '\0';
  *product_rev = '\0';
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __static_initialization_and_destruction_0(void)

{
  gp = &__global_pointer_;
  USBClass::USBClass(&USB);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _GLOBAL__sub_I_USB(void)

{
  gp = &__global_pointer_;
  __static_initialization_and_destruction_0();
  return;
}



void __clearADCPin(pin_size_t p)

{
  uint uVar1;
  uint uVar2;
  pin_size_t p_local;
  
  gp = &__global_pointer_;
  uVar1 = p - 0x20;
  if ((int)uVar1 < 0) {
    uVar2 = 0;
    uVar1 = 1 << (p & 0x1f);
  }
  else {
    uVar2 = 1 << (uVar1 & 0x1f);
    uVar1 = 0;
  }
  _adcGPIOInit._0_4_ = ~uVar1 & (uint)_adcGPIOInit;
  _adcGPIOInit._4_4_ = ~uVar2 & _adcGPIOInit._4_4_;
  return;
}



// WARNING: Unknown calling convention

void panic(char *fmt,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  gp = &__global_pointer_;
  uStack_1c = in_a1;
  uStack_18 = in_a2;
  uStack_14 = in_a3;
  uStack_10 = in_a4;
  uStack_c = in_a5;
  uStack_8 = in_a6;
  uStack_4 = in_a7;
  puts("\n*** PANIC ***\n");
  if (fmt != (char *)0x0) {
    vprintf(fmt,&uStack_1c);
    puts("\n");
  }
                    // WARNING: Subroutine does not return
  _exit(1);
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void _gpio_set_irq_enabled
               (uint gpio,uint32_t events,_Bool enabled,
               io_bank0_irq_ctrl_hw_t_conflict *irq_ctrl_base)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention
// WARNING: Enum "gpio_function_rp2350": Some values do not have unique names

void gpio_set_function(uint gpio,gpio_function_t fn)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void gpio_set_pulls(uint gpio,_Bool up,_Bool down)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void gpio_set_drive_strength(uint gpio,gpio_drive_strength drive)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void gpio_set_irq_enabled(uint gpio,uint32_t events,_Bool enabled)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = 0x248;
  if (_DAT_d0000000 != 0) {
    iVar1 = 0x290;
  }
  _gpio_set_irq_enabled(gpio,events,enabled,(io_bank0_irq_ctrl_hw_t_conflict *)(iVar1 + 0x40028000))
  ;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void gpio_init(uint gpio)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

uint32_t riscv_encode_imm_j(uint32_t x)

{
  gp = &__global_pointer_;
  return (x & 0x800) << 9 | (x >> 0x14) << 0x1f | x & 0xff000 | (x & 0x7fe) << 0x14;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t riscv_encode_imm_cj(uint32_t x)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void * resolve_j_16(uint16_t *inst)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x100118c4)
// WARNING: Unknown calling convention

void set_raw_irq_handler_and_unlock(uint num,irq_handler_t handler,uint32_t save)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void irq_set_mask_n_enabled_internal(uint n,uint32_t mask,_Bool enabled)

{
  undefined3 in_register_00002031;
  
  gp = &__global_pointer_;
  if (CONCAT31(in_register_00002031,enabled) != 0) {
    return;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void irq_set_enabled(uint num,_Bool enabled)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool irq_is_enabled(uint num)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void irq_set_pending(uint num)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x1001194e)
// WARNING: Unknown calling convention

irq_handler_t irq_get_vtable_handler(uint num)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void irq_set_exclusive_handler(uint num,irq_handler_t handler)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void irq_add_shared_handler(uint num,irq_handler_t handler,uint8_t order_priority)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void irq_remove_handler(uint num,irq_handler_t handler)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void irq_set_priority(uint num,uint8_t hardware_priority)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_per_core_irq_priorities(void)

{
  uint num;
  uint uVar1;
  
  gp = &__global_pointer_;
  num = 0;
  do {
    uVar1 = num + 1;
    irq_set_priority(num,0x80);
    num = uVar1;
  } while (uVar1 != 0x34);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10011e48)
// WARNING: Unknown calling convention

void irq_add_tail_to_free_list(irq_handler_chain_slot *slot)

{
  uint32_t save;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

int user_irq_claim_unused(_Bool required)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = hw_claim_unused_from_range(&user_irq_claimed,required,0,5,"No user IRQs are available");
  if (-1 < iVar1) {
    iVar1 = 0x33 - iVar1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void mutex_init(mutex_t *mtx)

{
  uint lock_num;
  
  gp = &__global_pointer_;
  lock_num = next_striped_spin_lock_num();
  lock_init(&mtx->core,lock_num);
  mtx->owner = -1;
  fence();
  return;
}



// WARNING: Unknown calling convention

void recursive_mutex_init(recursive_mutex_t *mtx)

{
  uint lock_num;
  
  gp = &__global_pointer_;
  lock_num = next_striped_spin_lock_num();
  lock_init(&mtx->core,lock_num);
  mtx->owner = -1;
  mtx->enter_count = '\0';
  fence();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_mutex(void)

{
  __FILE *mtx;
  
  gp = &__global_pointer_;
  mtx = (__FILE *)&_irqMutex;
  while (mtx < __sf) {
    if (mtx->_p == (uchar *)0x0) {
      mutex_init((mutex_t *)mtx);
      mtx = (__FILE *)&mtx->_w;
    }
    else {
      recursive_mutex_init((recursive_mutex_t *)mtx);
      mtx = (__FILE *)&mtx->_w;
    }
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void sleep_until_callback(alarm_id_t id,void *user_data)

{
  uint32_t save;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10012034)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void alarm_pool_irq_handler(void)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void alarm_pool_post_alloc_init
               (alarm_pool_t *pool,alarm_pool_timer_t *timer,uint hardware_alarm_num,uint max_timers
               )

{
  undefined4 uVar1;
  uint uVar2;
  
  gp = &__global_pointer_;
  pool->timer = timer;
  uVar2 = next_striped_spin_lock_num();
  pool->timer_alarm_num = (uint8_t)hardware_alarm_num;
  uVar1 = _DAT_d0000000;
  pool->lock = _sw_spin_locks + uVar2;
  pool->core_num = (uint8_t)uVar1;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_default_alarm_pool(void)

{
  gp = &__global_pointer_;
  if (default_alarm_pool.lock == (spin_lock_t *)0x0) {
    timer_hardware_alarm_claim((timer_hw_t_conflict *)0x400b0000,3);
    alarm_pool_post_alloc_init(&default_alarm_pool,(alarm_pool_timer_t *)0x400b0000,3,0x10);
  }
  lock_init(&sleep_notifier,10);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool time_reached(absolute_time_t t)

{
  _Bool _Var1;
  uint in_a0;
  uint in_a1;
  
  gp = &__global_pointer_;
  if (_DAT_400b0024 < in_a1) {
    _Var1 = false;
  }
  else {
    _Var1 = true;
    if (_DAT_400b0028 < in_a0) {
      return in_a1 != _DAT_400b0024;
    }
  }
  return _Var1;
}



// WARNING: Unknown calling convention

alarm_pool_t * alarm_pool_get_default(void)

{
  gp = &__global_pointer_;
  return &default_alarm_pool;
}



// WARNING: Control flow encountered unimplemented instructions

alarm_id_t
alarm_pool_add_alarm_at_force_in_context
          (alarm_pool_t *pool,absolute_time_t time,alarm_callback_t callback,void *user_data)

{
  uint32_t save;
  alarm_pool_entry_t *entry;
  int16_t index;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



alarm_id_t
alarm_pool_add_alarm_at
          (alarm_pool_t *pool,absolute_time_t time,alarm_callback_t callback,void *user_data,
          _Bool fire_if_past)

{
  alarm_id_t aVar1;
  int iVar2;
  int extraout_a1;
  int in_a5;
  
  gp = &__global_pointer_;
  if (in_a5 == 0) {
    iVar2 = time_us_64();
    if ((int)((int)user_data + (-(uint)(callback < callback + -iVar2) - extraout_a1)) < 0) {
      return 0;
    }
  }
  aVar1 = alarm_pool_add_alarm_at_force_in_context(pool,time,callback,user_data);
  return aVar1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool alarm_pool_cancel_alarm(alarm_pool_t *pool,alarm_id_t alarm_id)

{
  uint32_t save;
  
  gp = &__global_pointer_;
  if (alarm_id >> 0x10 < (int)(uint)pool->num_entries) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return false;
}



// WARNING: Control flow encountered unimplemented instructions

void sleep_until(absolute_time_t t)

{
  alarm_callback_t callback;
  void *user_data;
  _Bool _Var1;
  alarm_callback_t in_a0;
  alarm_callback_t p_Var2;
  alarm_id_t aVar3;
  undefined3 extraout_var;
  void *in_a1;
  int extraout_a1;
  uint32_t save;
  
  gp = &__global_pointer_;
  callback = in_a0 + -6;
  user_data = (void *)((int)in_a1 + ((callback < in_a0) - 1));
  if ((in_a1 < user_data) || ((user_data == in_a1 && (in_a0 < callback)))) {
    callback = (alarm_callback_t)0x0;
    user_data = (void *)0x0;
  }
  p_Var2 = (alarm_callback_t)time_us_64();
  if ((((0 < (int)(((int)user_data - extraout_a1) - (uint)(callback < callback + -(int)p_Var2))) ||
       (((int)user_data - extraout_a1 == (uint)(callback < callback + -(int)p_Var2) &&
        (callback != p_Var2)))) &&
      (aVar3 = alarm_pool_add_alarm_at(&default_alarm_pool,t,callback,user_data,true), aVar3 != -1))
     && (_Var1 = time_reached(t), CONCAT31(extraout_var,_Var1) == 0)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  busy_wait_until(t);
  return;
}



void sleep_us(uint64_t us)

{
  gp = &__global_pointer_;
  time_us_64();
  sleep_until(us);
  return;
}



// WARNING: Unknown calling convention

void sleep_ms(uint32_t ms)

{
  gp = &__global_pointer_;
  sleep_us(uRam00000010);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x100126fe)

_Bool best_effort_wfe_or_timeout(absolute_time_t timeout_timestamp)

{
  _Bool _Var1;
  int in_csrbe5;
  
  gp = &__global_pointer_;
  if (-1 < in_csrbe5 << 0x10) {
    _Var1 = time_reached(timeout_timestamp);
    return _Var1;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void timer_hardware_alarm_claim(timer_hw_t_conflict *timer,uint alarm_num)

{
  gp = &__global_pointer_;
  hw_claim_or_assert(claimed + (timer == (timer_hw_t_conflict *)0x400b8000),alarm_num,
                     "Hardware alarm %d already claimed");
  return;
}



// WARNING: Unknown calling convention

io_ro_32 timer_time_us_64(timer_hw_t_conflict *timer)

{
  bool bVar1;
  uint32_t next_hi;
  
  gp = &__global_pointer_;
  next_hi = timer->timerawh;
  do {
    bVar1 = next_hi != timer->timerawh;
    next_hi = timer->timerawh;
  } while (bVar1);
  return timer->timerawl;
}



void timer_busy_wait_until(timer_hw_t_conflict *timer,absolute_time_t t)

{
  uint in_a1;
  uint in_a2;
  io_ro_32 iVar1;
  
  gp = &__global_pointer_;
  do {
    iVar1 = timer->timerawh;
  } while (iVar1 < in_a2);
  while ((iVar1 == in_a2 && (timer->timerawl < in_a1))) {
    iVar1 = timer->timerawh;
  }
  return;
}



void timer_busy_wait_us(timer_hw_t_conflict *timer,uint64_t delay_us)

{
  gp = &__global_pointer_;
  timer_time_us_64(timer);
  timer_busy_wait_until(timer,delay_us);
  return;
}



// WARNING: Unknown calling convention

void time_us_64(void)

{
  gp = &__global_pointer_;
  timer_time_us_64((timer_hw_t_conflict *)0x400b0000);
  return;
}



void busy_wait_us(uint64_t delay_us)

{
  gp = &__global_pointer_;
  timer_busy_wait_us((timer_hw_t_conflict *)0x400b0000,delay_us);
  return;
}



// WARNING: Unknown calling convention

void timer_busy_wait_us_32(timer_hw_t_conflict *timer,uint32_t delay_us)

{
  gp = &__global_pointer_;
  if (-1 < (int)delay_us) {
    do {
    } while (timer->timerawl - timer->timerawl < delay_us);
    return;
  }
  busy_wait_us(uRam00000010);
  return;
}



// WARNING: Unknown calling convention

void timer_busy_wait_ms(timer_hw_t_conflict *timer,uint32_t delay_ms)

{
  gp = &__global_pointer_;
  if (delay_ms < 0x20c49c) {
    timer_busy_wait_us_32(timer,delay_ms * 1000);
    return;
  }
  timer_busy_wait_us(timer,uRam00000010);
  return;
}



// WARNING: Unknown calling convention

void busy_wait_ms(uint32_t delay_ms)

{
  gp = &__global_pointer_;
  timer_busy_wait_ms((timer_hw_t_conflict *)0x400b0000,delay_ms);
  return;
}



void busy_wait_until(absolute_time_t t)

{
  gp = &__global_pointer_;
  timer_busy_wait_until((timer_hw_t_conflict *)0x400b0000,t);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void clock_configure_internal
               (clock_handle_t clock,uint32_t src,uint32_t auxsrc,uint32_t actual_freq,uint32_t div)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = clock * 0xc;
  if (*(uint *)(iVar1 + 0x40010004) < div) {
    *(uint32_t *)(iVar1 + 0x40010004) = div;
  }
  if ((1 < clock - clk_ref) || (src != 1)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  *(undefined4 *)(iVar1 + 0x40013000) = 3;
  do {
  } while ((*(uint *)(iVar1 + 0x40010008) & 1) == 0);
  *(uint *)(iVar1 + 0x40011000) = (auxsrc << 5 ^ *(uint *)(iVar1 + 0x40010000)) & 0xe0;
  if (clock - clk_ref < 2) {
    *(uint *)(iVar1 + 0x40011000) = (*(uint *)(iVar1 + 0x40010000) ^ 1) & 3;
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void clock_configure_undivided(clock_handle_t clock,uint32_t src,uint32_t auxsrc,uint32_t src_freq)

{
  gp = &__global_pointer_;
  clock_configure_internal(clock,src,auxsrc,src_freq,0x10000);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint32_t clock_get_hz(clock_handle_t clock)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void pll_init(PLL pll,uint refdiv,uint vco_freq,uint post_div1,uint post_div2)

{
  gp = &__global_pointer_;
  if (((((int)pll->cs < 0) && ((pll->cs & 0x3f) == refdiv)) &&
      ((pll->fbdiv_int & 0xfff) == vco_freq / (12000000 / refdiv))) &&
     ((pll->prim & 0x77000) == (post_div2 << 0xc | post_div1 << 0x10))) {
    return;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void watchdog_update(void)

{
  gp = &__global_pointer_;
  _DAT_400d8004 = load_value;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void _watchdog_enable(uint32_t delay_ms,_Bool pause_on_debug)

{
  undefined3 in_register_0000202d;
  undefined4 *puVar1;
  
  gp = &__global_pointer_;
  puVar1 = (undefined4 *)&DAT_400db000;
  _DAT_400db000 = 0x40000000;
  _DAT_4001a008 = 0x1fffff3;
  if (CONCAT31(in_register_0000202d,pause_on_debug) != 0) {
    puVar1 = (undefined4 *)&DAT_400da000;
  }
  *puVar1 = 0x7000000;
  if (delay_ms == 0) {
    _DAT_400da000 = 0x80000000;
    return;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void watchdog_reboot(uint32_t pc,uint32_t sp,uint32_t delay_ms)

{
  gp = &__global_pointer_;
  _DAT_400db000 = 0x40000000;
  if (pc == 0) {
    _DAT_400d801c = 0;
  }
  else {
    _DAT_400d801c = 0xb007c0d3;
    _DAT_400d8020 = pc ^ 0x4ff83f2d;
    _DAT_400d8024 = sp;
    _DAT_400d8028 = pc;
  }
  _watchdog_enable(delay_ms,false);
  return;
}



// WARNING: Unknown calling convention

void tick_start(tick_gen_num_t tick,uint cycles)

{
  gp = &__global_pointer_;
  *(uint *)(tick * 0xc + 0x40108004) = cycles;
  *(undefined4 *)(tick * 0xc + 0x40108000) = 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int rom_reboot(uint32_t flags,uint32_t delay_ms,uint32_t p0,uint32_t p1)

{
  code *UNRECOVERED_JUMPTABLE;
  int iVar1;
  
  gp = &__global_pointer_;
  UNRECOVERED_JUMPTABLE =
       (code *)(*(code *)(uint)_DAT_00007dfa)(0x4252,1,(code *)(uint)_DAT_00007dfa);
                    // WARNING: Could not recover jumptable at 0x10012ad2. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*UNRECOVERED_JUMPTABLE)(0x102,10,flags,delay_ms,UNRECOVERED_JUMPTABLE);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void * rom_func_lookup(uint32_t code)

{
  void *pvVar1;
  
  gp = &__global_pointer_;
                    // WARNING: Could not recover jumptable at 0x10012adc. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*(code *)(uint)_DAT_00007dfa)(1,(code *)(uint)_DAT_00007dfa);
  return pvVar1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void rom_reset_usb_boot(uint32_t usb_activity_gpio_pin_mask,uint32_t disable_interface_mask)

{
  uint32_t in_a2;
  uint32_t in_a3;
  
  gp = &__global_pointer_;
  if (usb_activity_gpio_pin_mask != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  rom_reboot(disable_interface_mask,0,in_a2,in_a3);
  do {
  } while (_DAT_400e0828 == 0);
  fence();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_bootrom_locking_enable(void)

{
  do {
  } while (_DAT_400e0828 == 0);
  fence();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void boot_locks_reset(void)

{
  undefined4 *puVar1;
  
  gp = &__global_pointer_;
  puVar1 = (undefined4 *)&DAT_400e080c;
  do {
    fence();
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined4 *)0x400e082c);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_boot_locks_reset(void)

{
  undefined4 *puVar1;
  
  gp = &__global_pointer_;
  puVar1 = (undefined4 *)&DAT_400e080c;
  do {
    fence();
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined4 *)0x400e082c);
  return;
}



// WARNING: Unknown calling convention

void dma_channel_unclaim(uint channel)

{
  gp = &__global_pointer_;
  hw_claim_clear((uint8_t *)&_claimed,channel);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void dma_channel_cleanup(uint channel)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

int i2c_write_blocking_internal
              (i2c_inst_t *i2c,uint8_t addr,uint8_t *src,size_t len,_Bool nostop,
              check_timeout_fn timeout_check,timeout_state *ts)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  _Bool _Var4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002039;
  uint uVar5;
  i2c_hw_t *piVar6;
  uint uVar7;
  int iVar8;
  io_ro_32 iVar9;
  
  gp = &__global_pointer_;
  piVar6 = i2c->hw;
  piVar6->enable = 0;
  piVar6->tar = CONCAT31(in_register_0000202d,addr);
  piVar6->enable = 1;
  iVar3 = 0;
  iVar9 = 0;
  iVar2 = 0;
  do {
    if ((int)len <= iVar3) {
LAB_10012bcc:
      i2c->restart_on_next = nostop;
      return iVar3;
    }
    if (timeout_check != (check_timeout_fn)0x0) {
      (*timeout_check)(ts,true);
    }
    uVar7 = 0;
    if (iVar3 == 0) {
      uVar7 = (uint)i2c->restart_on_next;
    }
    uVar5 = 0;
    if (len - 1 == iVar3) {
      uVar5 = CONCAT31(in_register_00002039,nostop) ^ 1;
    }
    i2c->hw->data_cmd = (uint)src[iVar3] | uVar7 << 10 | uVar5 << 9;
    bVar1 = 0;
    iVar8 = iVar2;
    do {
      if (timeout_check != (check_timeout_fn)0x0) {
        _Var4 = (*timeout_check)(ts,false);
        iVar8 = CONCAT31(extraout_var,_Var4);
        bVar1 = bVar1 | _Var4;
      }
      if (iVar8 != 0) goto LAB_10012c72;
    } while ((i2c->hw->raw_intr_stat & 0x10) == 0);
    iVar9 = i2c->hw->tx_abrt_source;
    if (iVar9 == 0) {
      if ((bVar1 != 0) ||
         ((iVar2 = 0, len - 1 == iVar3 && (CONCAT31(in_register_00002039,nostop) == 0))))
      goto LAB_10012c52;
    }
    else {
      bVar1 = 1;
LAB_10012c52:
      do {
        if (timeout_check != (check_timeout_fn)0x0) {
          _Var4 = (*timeout_check)(ts,false);
          iVar2 = CONCAT31(extraout_var_00,_Var4);
          bVar1 = bVar1 | _Var4;
          if (iVar2 != 0) goto LAB_10012c9e;
        }
      } while ((i2c->hw->raw_intr_stat & 0x200) == 0);
LAB_10012c72:
      iVar2 = iVar8;
      if (bVar1 != 0) {
LAB_10012c9e:
        if (iVar2 == 0) {
          if (((iVar9 == 0) || ((iVar9 & 1) != 0)) || ((iVar9 & 8) == 0)) {
            iVar3 = -1;
          }
        }
        else {
          iVar3 = -2;
        }
        goto LAB_10012bcc;
      }
    }
    iVar3 = iVar3 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int i2c_read_blocking_internal
              (i2c_inst_t *i2c,uint8_t addr,uint8_t *dst,size_t len,_Bool nostop,
              check_timeout_fn timeout_check,timeout_state_t *ts)

{
  bool bVar1;
  uint uVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002039;
  i2c_hw_t *piVar4;
  uint uVar5;
  uint8_t *puVar6;
  uint uVar7;
  
  gp = &__global_pointer_;
  piVar4 = i2c->hw;
  piVar4->enable = 0;
  piVar4->tar = CONCAT31(in_register_0000202d,addr);
  piVar4->enable = 1;
  uVar2 = 0;
  do {
    if ((int)len <= (int)uVar2) {
LAB_10012ce2:
      i2c->restart_on_next = nostop;
      return uVar2;
    }
    if (timeout_check != (check_timeout_fn)0x0) {
      (*timeout_check)(ts,true);
    }
    piVar4 = i2c->hw;
    do {
    } while (piVar4->txflr == 0x10);
    uVar5 = 0;
    if (uVar2 == 0) {
      uVar5 = (uint)i2c->restart_on_next;
    }
    uVar7 = 0;
    if (len - 1 == uVar2) {
      uVar7 = CONCAT31(in_register_00002039,nostop) ^ 1;
    }
    piVar4->data_cmd = uVar7 << 9 | uVar5 << 10 | 0x100;
    do {
      if ((piVar4->raw_intr_stat & 0x40) != 0) {
        if (timeout_check != (check_timeout_fn)0x0) {
          bVar1 = true;
          goto LAB_10012d4c;
        }
        uVar5 = 0;
LAB_10012d78:
        uVar2 = ~uVar5;
        goto LAB_10012ce2;
      }
      bVar1 = false;
      if (timeout_check != (check_timeout_fn)0x0) {
LAB_10012d4c:
        _Var3 = (*timeout_check)(ts,false);
        uVar5 = CONCAT31(extraout_var,_Var3);
        if ((uVar5 != 0) || (bVar1)) goto LAB_10012d78;
      }
      piVar4 = i2c->hw;
    } while (piVar4->rxflr == 0);
    puVar6 = dst + uVar2;
    uVar2 = uVar2 + 1;
    *puVar6 = (uint8_t)piVar4->data_cmd;
  } while( true );
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void i2c_deinit(i2c_inst_t *i2c)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint i2c_set_baudrate(i2c_inst_t *i2c,uint baudrate)

{
  uint hcnt;
  uint period;
  
  gp = &__global_pointer_;
  clock_get_hz(clk_sys);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint i2c_init(i2c_inst_t *i2c,uint baudrate)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void i2c_set_slave_mode(i2c_inst_t *i2c,_Bool slave,uint8_t addr)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  i2c_hw_t *piVar1;
  
  gp = &__global_pointer_;
  piVar1 = i2c->hw;
  piVar1->enable = 0;
  if (CONCAT31(in_register_0000202d,slave) == 0) {
    piVar1[0x10].con = (piVar1->con ^ 0x41) & 0x241;
  }
  else {
    piVar1[0x10].con = (piVar1->con ^ 0x200) & 0x241;
    piVar1->sar = CONCAT31(in_register_00002031,addr);
  }
  piVar1->enable = 1;
  return;
}



// WARNING: Variable defined which should be unmapped: ts

int i2c_write_blocking_until
              (i2c_inst_t *i2c,uint8_t addr,uint8_t *src,size_t len,_Bool nostop,
              absolute_time_t until)

{
  check_timeout_fn timeout_check;
  int iVar1;
  undefined1 auStack_20 [4];
  timeout_state_t ts;
  
  gp = &__global_pointer_;
  timeout_check = init_single_timeout_until((timeout_state_t *)auStack_20,until);
  iVar1 = i2c_write_blocking_internal
                    (i2c,addr,src,len,nostop,timeout_check,(timeout_state *)auStack_20);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: ts

int i2c_read_blocking_until
              (i2c_inst_t *i2c,uint8_t addr,uint8_t *dst,size_t len,_Bool nostop,
              absolute_time_t until)

{
  check_timeout_fn timeout_check;
  int iVar1;
  undefined1 auStack_20 [4];
  timeout_state_t ts;
  
  gp = &__global_pointer_;
  timeout_check = init_single_timeout_until((timeout_state_t *)auStack_20,until);
  iVar1 = i2c_read_blocking_internal
                    (i2c,addr,dst,len,nostop,timeout_check,(timeout_state_t *)auStack_20);
  return iVar1;
}



// WARNING: Unknown calling convention

int pio_sm_set_config(PIO pio,uint sm,pio_sm_config_conflict *config)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  gp = &__global_pointer_;
  pio->sm[sm].clkdiv = config->clkdiv;
  pio->sm[sm].shiftctrl = config->shiftctrl;
  uVar3 = pio->gpiobase;
  uVar4 = ~config->pinhi;
  uVar1 = uVar4 >> 4 & 0x108421;
  uVar2 = config->pinhi >> 1 & uVar1;
  if ((uVar4 >> 1 & uVar4 & uVar1) == 0) {
    if (uVar2 == 0) {
      uVar4 = config->execctrl;
      uVar2 = 0;
      if (uVar3 == 0) goto LAB_10012f9c;
    }
    else {
      if (uVar3 == 0) {
        return -0xb;
      }
      uVar4 = config->execctrl;
    }
    uVar2 = (uVar1 >> 0x14) << 0x1c;
  }
  else {
    if (uVar3 != 0 || uVar2 != 0) {
      return -0xb;
    }
    uVar4 = config->execctrl;
    uVar2 = 0;
  }
LAB_10012f9c:
  pio->sm[sm].execctrl = uVar2 ^ uVar4;
  if (uVar3 != 0) {
    uVar3 = (uVar1 << 0xc) >> 8;
  }
  pio->sm[sm].pinctrl = config->pinctrl ^ uVar3;
  return 0;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

int pio_set_gpio_base_unsafe(PIO pio,uint gpio_base)

{
  gp = &__global_pointer_;
  if ((gpio_base & 0xffffffef) == 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return -0xb;
}



// WARNING: Control flow encountered unimplemented instructions

int find_offset_for_program(PIO pio,pio_program_t *program)

{
  uint32_t used_mask;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

int add_program_at_offset_check(PIO pio,pio_program_t *program,uint offset)

{
  gp = &__global_pointer_;
  if (pio->gpiobase == 0) {
    if ((program->used_gpio_ranges & 4) != 0) {
      gp = &__global_pointer_;
      return -0xb;
    }
  }
  else if ((program->used_gpio_ranges & 1) != 0) {
    return -0xb;
  }
  if ((-1 < program->origin) && ((int)program->origin != offset)) {
    return -0xb;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

int add_program_at_offset(PIO pio,pio_program_t *program,uint offset)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = add_program_at_offset_check(pio,program,offset);
  if (iVar1 != 0) {
    return iVar1;
  }
  if (program->length == '\0') {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void pio_sm_unclaim(PIO pio,uint sm)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

int pio_claim_unused_sm(PIO pio,_Bool required)

{
  uint uVar1;
  uint bit_lsb;
  int iVar2;
  
  gp = &__global_pointer_;
  uVar1 = (uint)(pio[-0x345398].instr_mem + 0x1e) >> 0x14;
  bit_lsb = uVar1 * 4;
  iVar2 = hw_claim_unused_from_range
                    (claimed,required,bit_lsb,bit_lsb + 3,"No PIO state machines are available");
  if (iVar2 < (int)bit_lsb) {
    iVar2 = -1;
  }
  else {
    iVar2 = iVar2 + uVar1 * -4;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

_Bool pio_can_add_program(PIO pio,pio_program_t *program)

{
  uint32_t save;
  uint offset;
  
  gp = &__global_pointer_;
  save = hw_claim_lock();
  offset = find_offset_for_program(pio,(pio_program_t *)(uint)program->length);
  if (-1 < (int)offset) {
    offset = add_program_at_offset_check(pio,program,offset);
  }
  hw_claim_unlock(save);
  return offset == 0;
}



// WARNING: Unknown calling convention

int pio_add_program(PIO pio,pio_program_t *program)

{
  uint32_t save;
  uint offset;
  
  gp = &__global_pointer_;
  save = hw_claim_lock();
  offset = find_offset_for_program(pio,(pio_program_t *)(uint)program->length);
  if (-1 < (int)offset) {
    offset = add_program_at_offset(pio,program,offset);
  }
  hw_claim_unlock(save);
  return offset;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

int pio_sm_init(PIO pio,uint sm,uint initial_pc,pio_sm_config_conflict *config)

{
  pio_sm_config_conflict c;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool pio_claim_free_sm_and_add_program_for_gpio_range
                (pio_program_t *program,PIO *pio,uint *sm,uint *offset,uint gpio_base,
                uint gpio_count,_Bool set_gpio_base)

{
  int8_t sm_index [4];
  
  gp = &__global_pointer_;
  if (gpio_count != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  *pio = (PIO)&DAT_50400000;
  pio_claim_unused_sm(*pio,false);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void spi_deinit(spi_inst_t *spi)

{
  gp = &__global_pointer_;
  *(undefined4 *)(spi + 0x3004) = 2;
  *(undefined4 *)(spi + 0x3024) = 3;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

uint spi_set_baudrate(spi_inst_t *spi,uint baudrate)

{
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint32_t enable_mask;
  
  gp = &__global_pointer_;
  uVar1 = clock_get_hz(clk_peri);
  iVar6 = 2;
  *(undefined4 *)(spi + 0x3004) = 2;
  uVar2 = baudrate * 0x200;
  uVar3 = baudrate >> 0x17;
  do {
    if ((uVar3 != 0) || (uVar1 < uVar2)) break;
    uVar7 = uVar2 + baudrate * 0x200;
    iVar6 = iVar6 + 2;
    uVar3 = (uint)(uVar7 < uVar2) + (baudrate >> 0x17);
    uVar2 = uVar7;
  } while (iVar6 != 0x100);
  uVar2 = iVar6 * 0xff;
  iVar5 = 0x100;
  do {
    iVar4 = iVar5 + -1;
    if (baudrate < uVar1 / uVar2) goto LAB_100134b2;
    uVar2 = uVar2 - iVar6;
    iVar5 = iVar4;
  } while (iVar4 != 1);
  iVar4 = 0;
LAB_100134b2:
  *(int *)(spi + 0x10) = iVar6;
  *(uint *)(spi + 0x1000) = (iVar4 << 8 ^ *(uint *)spi) & 0xff00;
  *(uint *)(spi + 0x2004) = *(uint *)(spi + 4) & 2;
  return uVar1 / (uint)(iVar5 * iVar6);
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint spi_init(spi_inst_t *spi,uint baudrate)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

uint32_t multicore_fifo_pop_blocking_inline(void)

{
  gp = &__global_pointer_;
  do {
  } while ((_DAT_d0000050 & 1) == 0);
  return _DAT_d0000058;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void core1_trampoline(void)

{
  undefined4 in_stack_00000000;
  undefined4 in_stack_00000004;
  code *UNRECOVERED_JUMPTABLE;
  undefined4 in_stack_0000000c;
  
  gp = in_stack_0000000c;
                    // WARNING: Could not recover jumptable at 0x10013574. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(in_stack_00000000,in_stack_00000004,UNRECOVERED_JUMPTABLE);
  return;
}



// WARNING: Unknown calling convention

int core1_wrapper(_func_int *entry,void *stack_base)

{
  int iVar1;
  
  gp = &__global_pointer_;
  runtime_run_per_core_initializers();
                    // WARNING: Could not recover jumptable at 0x10013588. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*entry)(entry);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void multicore_fifo_push_blocking_inline(uint32_t data)

{
  gp = &__global_pointer_;
  do {
  } while ((_DAT_d0000050 & 2) == 0);
  _DAT_d0000054 = data;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool multicore_doorbell_claim_under_lock(uint doorbell_num,uint core_mask,_Bool required)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void multicore_launch_core1_raw(_func_void *entry,uint32_t *sp,uint32_t vector_table)

{
  uint32_t cmd_sequence [6];
  
  gp = &__global_pointer_;
  irq_is_enabled(0x19);
  irq_set_enabled(0x19,false);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Removing unreachable block (ram,0x100136aa)
// WARNING: Unknown calling convention

void multicore_launch_core1_with_stack
               (_func_void *entry,uint32_t *stack_bottom,size_t stack_size_bytes)

{
  uint uVar1;
  uint32_t in_mtvec;
  
  gp = &__global_pointer_;
  uVar1 = stack_size_bytes & 0xfffffffc;
  *(undefined **)((int)stack_bottom + (uVar1 - 4)) = &__global_pointer_;
  *(_func_void **)((int)stack_bottom + (uVar1 - 0x10)) = entry;
  *(uint32_t **)((int)stack_bottom + (uVar1 - 0xc)) = stack_bottom;
  *(code **)((int)stack_bottom + (uVar1 - 8)) = core1_wrapper;
  multicore_launch_core1_raw
            (core1_trampoline,(uint32_t *)((int)stack_bottom + (uVar1 - 0x10)),in_mtvec);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void multicore_launch_core1(_func_void *entry)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

int multicore_doorbell_claim_unused(uint core_mask,_Bool required)

{
  uint doorbell_num;
  _Bool _Var1;
  uint32_t save;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  gp = &__global_pointer_;
  save = hw_claim_lock();
  doorbell_num = 7;
  do {
    _Var1 = multicore_doorbell_claim_under_lock(doorbell_num,core_mask,false);
    if (CONCAT31(extraout_var,_Var1) != 0) goto LAB_1001372a;
    doorbell_num = doorbell_num - 1;
  } while (doorbell_num != 0xffffffff);
  if (CONCAT31(in_register_0000202d,required) != 0) {
                    // WARNING: Subroutine does not return
    panic("No free doorbells");
  }
  doorbell_num = 0xfffffff7;
LAB_1001372a:
  hw_claim_unlock(save);
  return doorbell_num;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _retrieve_unique_id_on_boot(void)

{
  code *pcVar1;
  int iVar2;
  undefined1 *puVar3;
  undefined1 auStack_34 [4];
  anon_union_36_2_f8194b7f out;
  
  gp = &__global_pointer_;
  pcVar1 = (code *)rom_func_lookup(0x5347);
  (*pcVar1)(auStack_34,9,1,pcVar1);
  puVar3 = auStack_34;
  iVar2 = 0;
  do {
    retrieved_id.id[iVar2] = puVar3[0xf];
    iVar2 = iVar2 + 1;
    puVar3 = puVar3 + -1;
  } while (iVar2 != 8);
  return;
}



// WARNING: Unknown calling convention

void pico_get_unique_board_id_string(char *id_out,uint len)

{
  char cVar1;
  char cVar2;
  uint uVar3;
  int nibble;
  uint uVar4;
  
  gp = &__global_pointer_;
  for (uVar3 = 0; (uVar3 < len - 1 && (uVar3 != 0x10)); uVar3 = uVar3 + 1) {
    uVar4 = (int)(uint)retrieved_id.id[uVar3 >> 1] >> ((~uVar3 & 1) << 2) & 0xf;
    cVar1 = (char)uVar4;
    cVar2 = cVar1 + '7';
    if (uVar4 < 10) {
      cVar2 = cVar1 + '0';
    }
    id_out[uVar3] = cVar2;
  }
  id_out[uVar3] = '\0';
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void first_per_core_initializer(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hard_assertion_failure(void)

{
  gp = &__global_pointer_;
                    // WARNING: Subroutine does not return
  panic("Hard assert");
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_run_initializers(void)

{
  uintptr_t *puVar1;
  
  gp = &__global_pointer_;
  for (puVar1 = &__pre_init_runtime_init_bootrom_reset; puVar1 < &__preinit_array_end;
      puVar1 = (uintptr_t *)((undefined **)puVar1 + 1)) {
    (*(code *)*puVar1)((code *)*puVar1);
  }
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_run_per_core_initializers(void)

{
  uintptr_t *puVar1;
  
  gp = &__global_pointer_;
  for (puVar1 = &__pre_init_first_per_core_initializer; puVar1 < &__preinit_array_end;
      puVar1 = (uintptr_t *)((undefined **)puVar1 + 1)) {
    (*(code *)*puVar1)((code *)*puVar1);
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_early_resets(void)

{
  gp = &__global_pointer_;
  _DAT_40022000 = 0xefef3b7f;
  _DAT_40023000 = 0x3f3fff6;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_usb_power_down(void)

{
  gp = &__global_pointer_;
  if (_DAT_5011004c == 0x8000) {
    _DAT_5011204c = 0x40000;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_post_clock_resets(void)

{
  gp = &__global_pointer_;
  _DAT_40023000 = 0x1fffffff;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_bootrom_reset(void)

{
  code *UNRECOVERED_JUMPTABLE;
  
  gp = &__global_pointer_;
  UNRECOVERED_JUMPTABLE = (code *)rom_func_lookup(0x5253);
                    // WARNING: Could not recover jumptable at 0x100138b6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(4,UNRECOVERED_JUMPTABLE);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_per_core_bootrom_reset(void)

{
  code *UNRECOVERED_JUMPTABLE;
  
  gp = &__global_pointer_;
  UNRECOVERED_JUMPTABLE = (code *)rom_func_lookup(0x5253);
                    // WARNING: Could not recover jumptable at 0x100138ce. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(1,UNRECOVERED_JUMPTABLE);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_spin_locks_reset(void)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = 0;
  do {
    fence();
    _sw_spin_locks[iVar1] = '\0';
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init_clocks(void)

{
  tick_gen_num_t tick;
  tick_gen_num_t tVar1;
  uint32_t uVar2;
  
  gp = &__global_pointer_;
  _DAT_40010084 = 0;
  xosc_init();
  _DAT_4001303c = 1;
  do {
  } while (_DAT_40010044 != 1);
  _DAT_40013030 = 3;
  do {
  } while (_DAT_40010038 != 1);
  pll_init((PLL)&DAT_40050000,1,1500000000,5,2);
  pll_init((PLL)&DAT_40058000,1,1200000000,5,5);
  clock_configure_undivided(clk_ref,2,0,12000000);
  clock_configure_undivided(clk_sys,1,0,150000000);
  clock_configure_undivided(clk_usb,0,0,48000000);
  clock_configure_undivided(clk_adc,0,0,48000000);
  clock_configure_undivided(clk_peri,0,0,150000000);
  clock_configure_undivided(clk_hstx,0,0,150000000);
  uVar2 = clock_get_hz(clk_ref);
  tick = TICK_PROC0;
  do {
    tVar1 = tick + TICK_PROC1;
    tick_start(tick,uVar2 / 1000000);
    tick = tVar1;
  } while (tVar1 != TICK_COUNT);
  return;
}



// WARNING: Removing unreachable block (ram,0x100139ee)

undefined4
_xrv32i2p1_m2p0_a2p1_c2p0_zicsr2p0_zifencei2p0_zmmul1p0_zaamo1p0_zalrsc1p0_zba1p0_zbb1p0_zbkb1p0_zbs1p0
          (void)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = 3;
  do {
    iVar1 = iVar1 + -1;
  } while (-1 < iVar1);
  return 0x800;
}



// WARNING: Unknown calling convention

_Bool tud_vendor_control_xfer_cb(uint8_t rhport,uint8_t stage,tusb_control_request_t *request)

{
  gp = &__global_pointer_;
  return false;
}



// WARNING: Unknown calling convention

_Bool invoke_class_control
                (uint8_t rhport,usbd_class_driver_t *driver,tusb_control_request_t *request)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  usbd_control_set_complete_callback(driver->control_xfer_cb);
                    // WARNING: Could not recover jumptable at 0x10013a1c. Too many branches
                    // WARNING: Treating indirect jump as call
  _Var1 = (*driver->control_xfer_cb)(rhport,'\x01',request);
  return _Var1;
}



// WARNING: Unknown calling convention

void configuration_reset(uint8_t rhport)

{
  uint uVar1;
  uint uVar2;
  usbd_class_driver_t *puVar3;
  
  gp = &__global_pointer_;
  uVar1 = 0;
  do {
    uVar2 = (uint)_app_driver_count;
    if (uVar2 + 3 < uVar1) {
      memset(&_usbd_dev,0,0x54);
      memset(_usbd_dev.itf2drv,0xff,0x10);
      memset(_usbd_dev.ep2drv,0xff,0x20);
      return;
    }
    if (uVar1 < uVar2) {
      puVar3 = _app_driver + uVar1;
      if (puVar3 == (usbd_class_driver_t *)0x0) {
        ebreak();
        return;
      }
    }
    else {
      puVar3 = _usbd_driver + (uVar1 - uVar2);
    }
    (*puVar3->reset)(rhport);
    uVar1 = uVar1 + 1 & 0xff;
  } while( true );
}



// WARNING: Unknown calling convention

void tud_event_hook_cb(uint8_t rhport,uint32_t eventid,_Bool in_isr)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

void tud_sof_cb(uint32_t frame_count)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

uint8_t * tud_descriptor_bos_cb(void)

{
  gp = &__global_pointer_;
  return (uint8_t *)0x0;
}



undefined4 tud_descriptor_device_qualifier_cb(void)

{
  gp = &__global_pointer_;
  return 0;
}



// WARNING: Unknown calling convention

uint8_t * tud_descriptor_other_speed_configuration_cb(uint8_t index)

{
  gp = &__global_pointer_;
  return (uint8_t *)0x0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void tud_mount_cb(void)

{
  gp = &__global_pointer_;
  return;
}



void tud_umount_cb(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

void tud_suspend_cb(_Bool remote_wakeup_en)

{
  gp = &__global_pointer_;
  return;
}



void tud_resume_cb(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

_Bool tud_connected(void)

{
  gp = &__global_pointer_;
  return (_Bool)((byte)_usbd_dev.field_0 & 1);
}



// WARNING: Unknown calling convention

_Bool tud_mounted(void)

{
  gp = &__global_pointer_;
  return _usbd_dev.cfg_num != '\0';
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tud_suspended(void)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tud_disconnect(void)

{
  gp = &__global_pointer_;
  dcd_disconnect(_usbd_rhport);
  return true;
}



// WARNING: Unknown calling convention

_Bool tud_connect(void)

{
  gp = &__global_pointer_;
  dcd_connect(_usbd_rhport);
  return true;
}



// WARNING: Unknown calling convention

_Bool tud_inited(void)

{
  gp = &__global_pointer_;
  return _usbd_rhport != 0xff;
}



// WARNING: Removing unreachable block (ram,0x10013bd4)
// WARNING: Unknown calling convention

_Bool tud_rhport_init(uint8_t rhport,tusb_rhport_init_t_conflict *rh_init)

{
  uint uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  uint uVar3;
  usbd_class_driver_t *puVar4;
  
  gp = &__global_pointer_;
  if (_usbd_rhport == 0xff) {
    if (rh_init != (tusb_rhport_init_t_conflict *)0x0) {
      memset(&_usbd_dev,0,0x54);
      _usbd_queued_setup = '\0';
      mutex_init(&_ubsd_mutexdef);
      _usbd_mutex = &_ubsd_mutexdef;
      critical_section_init(&_usbd_qdef.critsec);
      tu_fifo_clear(&_usbd_qdef.ff);
      _usbd_q = &_usbd_qdef;
      for (uVar1 = 0; uVar3 = (uint)_app_driver_count, uVar1 <= uVar3 + 3; uVar1 = uVar1 + 1 & 0xff)
      {
        if (uVar1 < uVar3) {
          puVar4 = _app_driver + uVar1;
          if (puVar4 == (usbd_class_driver_t *)0x0) goto LAB_10013b6e;
        }
        else {
          puVar4 = _usbd_driver + (uVar1 - uVar3);
        }
        if (puVar4->init == (_func_void *)0x0) goto LAB_10013b6e;
        (*puVar4->init)();
      }
      _usbd_rhport = rhport;
      _Var2 = dcd_init(rhport,rh_init);
      if (CONCAT31(extraout_var,_Var2) != 0) {
        dcd_int_enable(rhport);
        goto LAB_10013c0a;
      }
    }
LAB_10013b6e:
    ebreak();
    _Var2 = false;
  }
  else {
LAB_10013c0a:
    _Var2 = true;
  }
  return _Var2;
}



// WARNING: Unknown calling convention

_Bool usbd_edpt_open(uint8_t rhport,tusb_desc_endpoint_t *desc_ep)

{
  uint8_t rhport_00;
  _Bool _Var1;
  undefined3 extraout_var;
  
  rhport_00 = rhport;
  gp = &__global_pointer_;
  if ((desc_ep->bEndpointAddress & 0x70) != 0) {
    ebreak();
    return false;
  }
  _Var1 = tu_edpt_validate(desc_ep,(uint)_usbd_dev.speed);
  if (CONCAT31(extraout_var,_Var1) == 0) {
    ebreak();
    return false;
  }
  _Var1 = dcd_edpt_open(rhport_00,desc_ep);
  return _Var1;
}



// WARNING: Unknown calling convention

_Bool usbd_open_edpt_pair(uint8_t rhport,uint8_t *p_desc,uint8_t ep_count,uint8_t xfer_type,
                         uint8_t *ep_out,uint8_t *ep_in)

{
  uint8_t uVar1;
  int iVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 in_register_00002031;
  undefined3 in_register_00002035;
  
  gp = &__global_pointer_;
  iVar2 = 0;
  while( true ) {
    if (CONCAT31(in_register_00002031,ep_count) <= iVar2) {
      return true;
    }
    if (((((tusb_desc_endpoint_t *)p_desc)->bDescriptorType != '\x05') ||
        (((byte)((tusb_desc_endpoint_t *)p_desc)->bmAttributes & 3) !=
         CONCAT31(in_register_00002035,xfer_type))) ||
       (_Var3 = usbd_edpt_open(_usbd_rhport,(tusb_desc_endpoint_t *)p_desc),
       CONCAT31(extraout_var,_Var3) == 0)) break;
    uVar1 = ((tusb_desc_endpoint_t *)p_desc)->bEndpointAddress;
    if ((char)uVar1 < '\0') {
      *ep_in = uVar1;
    }
    else {
      *ep_out = uVar1;
    }
    iVar2 = iVar2 + 1;
    p_desc = &((tusb_desc_endpoint_t *)p_desc)->bLength + ((tusb_desc_endpoint_t *)p_desc)->bLength;
  }
  ebreak();
  gp = &__global_pointer_;
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_edpt_claim(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_edpt_release(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_edpt_xfer(uint8_t rhport,uint8_t ep_addr,uint8_t *buffer,uint16_t total_bytes)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_edpt_busy(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void usbd_edpt_stall(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
  dcd_edpt_stall(rhport,ep_addr);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void usbd_edpt_clear_stall(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
  dcd_edpt_clear_stall(rhport,ep_addr);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_edpt_stalled(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void tud_task_ext(uint32_t timeout_ms,_Bool in_isr)

{
  uint8_t *desc_str;
  uint16_t status;
  dcd_event_t event;
  
  gp = &__global_pointer_;
  if (_usbd_rhport == 0xff) {
    return;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool data_stage_xact(uint8_t rhport)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



_Bool status_stage_xact(uint8_t rhport,tusb_control_request_t *request)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  _Var1 = usbd_edpt_xfer(_usbd_rhport,~(byte)request & 0x80,(uint8_t *)0x0,0);
  return _Var1;
}



// WARNING: Unknown calling convention

_Bool tud_control_status(uint8_t rhport,tusb_control_request_t *request)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  memcpy(&_ctrl_xfer,request,8);
  _ctrl_xfer.buffer = (uint8_t *)0x0;
  _ctrl_xfer.data_len = 0;
  _ctrl_xfer.total_xferred = 0;
  _Var1 = status_stage_xact(rhport,(tusb_control_request_t *)(uint)(request->field_0).bmRequestType)
  ;
  return _Var1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tud_control_xfer(uint8_t rhport,tusb_control_request_t *request,void *buffer,uint16_t len)

{
  gp = &__global_pointer_;
  memcpy(&_ctrl_xfer,request,8);
  _ctrl_xfer.buffer = (uint8_t *)buffer;
  _ctrl_xfer.total_xferred = 0;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void usbd_control_reset(void)

{
  gp = &__global_pointer_;
  _ctrl_xfer.request.field_0 = (anon_union_1_2_33686c6f_for_tusb_control_request_t_0)0x0;
  _ctrl_xfer.request.bRequest = '\0';
  _ctrl_xfer.request.wValue = 0;
  _ctrl_xfer.request.wIndex = 0;
  _ctrl_xfer.request.wLength = 0;
  _ctrl_xfer.buffer = (uint8_t *)0x0;
  _ctrl_xfer.data_len = 0;
  _ctrl_xfer.total_xferred = 0;
  _ctrl_xfer.complete_cb = (usbd_control_xfer_cb_t)0x0;
  return;
}



// WARNING: Unknown calling convention

void usbd_control_set_complete_callback(usbd_control_xfer_cb_t fp)

{
  gp = &__global_pointer_;
  _ctrl_xfer.complete_cb = fp;
  return;
}



// WARNING: Unknown calling convention

void usbd_control_set_request(tusb_control_request_t *request)

{
  gp = &__global_pointer_;
  memcpy(&_ctrl_xfer,request,8);
  _ctrl_xfer.buffer = (uint8_t *)0x0;
  _ctrl_xfer.data_len = 0;
  _ctrl_xfer.total_xferred = 0;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool usbd_control_xfer_cb
                (uint8_t rhport,uint8_t ep_addr,xfer_result_t result,uint32_t xferred_bytes)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool _prep_out_transaction(uint8_t itf)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_02;
  undefined3 extraout_var_01;
  undefined2 extraout_var_03;
  uint uVar4;
  
  iVar3 = CONCAT31(in_register_00002029,itf);
  gp = &__global_pointer_;
  _Var1 = tud_mounted();
  uVar4 = CONCAT31(extraout_var,_Var1);
  if (uVar4 != 0) {
    _Var1 = tud_suspended();
    uVar4 = CONCAT31(extraout_var_00,_Var1);
    if ((uVar4 == 0) && (_cdcd_itf[iVar3].ep_out != '\0')) {
      uVar2 = tu_fifo_remaining(&_cdcd_itf[iVar3].rx_ff);
      uVar4 = CONCAT22(extraout_var_02,uVar2);
      if (0x3f < uVar4) {
        _Var1 = usbd_edpt_claim('\0',_cdcd_itf[iVar3].ep_out);
        uVar4 = CONCAT31(extraout_var_01,_Var1);
        if (uVar4 != 0) {
          uVar2 = tu_fifo_remaining(&_cdcd_itf[iVar3].rx_ff);
          if (0x3f < CONCAT22(extraout_var_03,uVar2)) {
            _Var1 = usbd_edpt_xfer(_usbd_rhport,_cdcd_itf[iVar3].ep_out,
                                   (uint8_t *)(_cdcd_epbuf + iVar3),0x40);
            return _Var1;
          }
          _Var1 = usbd_edpt_release('\0',_cdcd_itf[iVar3].ep_out);
          return _Var1;
        }
      }
    }
  }
  return SUB41(uVar4,0);
}



// WARNING: Unknown calling convention

_Bool tud_cdc_n_connected(uint8_t itf)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  gp = &__global_pointer_;
  _Var1 = tud_mounted();
  if ((CONCAT31(extraout_var,_Var1) == 0) ||
     (_Var1 = tud_suspended(), CONCAT31(extraout_var_00,_Var1) != 0)) {
    _Var1 = false;
  }
  else {
    _Var1 = (_Bool)(_cdcd_itf[CONCAT31(in_register_00002029,itf)].line_state & 1);
  }
  return _Var1;
}



// WARNING: Unknown calling convention

uint32_t tud_cdc_n_available(uint8_t itf)

{
  uint16_t uVar1;
  undefined3 in_register_00002029;
  undefined2 extraout_var;
  
  gp = &__global_pointer_;
  uVar1 = tu_fifo_count(&_cdcd_itf[CONCAT31(in_register_00002029,itf)].rx_ff);
  return CONCAT22(extraout_var,uVar1);
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint32_t tud_cdc_n_read(uint8_t itf,void *buffer,uint32_t bufsize)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tud_cdc_n_peek(uint8_t itf,uint8_t *chr)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  
  gp = &__global_pointer_;
  _Var1 = tu_fifo_peek(&_cdcd_itf[CONCAT31(in_register_00002029,itf)].rx_ff,chr);
  return _Var1;
}



// WARNING: Unknown calling convention

uint32_t tud_cdc_n_write_flush(uint8_t itf)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_03;
  undefined3 extraout_var_01;
  undefined2 extraout_var_04;
  undefined3 extraout_var_02;
  
  iVar3 = CONCAT31(in_register_00002029,itf);
  gp = &__global_pointer_;
  _Var1 = tud_mounted();
  if ((CONCAT31(extraout_var,_Var1) != 0) &&
     (_Var1 = tud_suspended(), CONCAT31(extraout_var_00,_Var1) == 0)) {
    uVar2 = tu_fifo_count(&_cdcd_itf[iVar3].tx_ff);
    if ((CONCAT22(extraout_var_03,uVar2) != 0) &&
       (_Var1 = usbd_edpt_claim('\0',_cdcd_itf[iVar3].ep_in), CONCAT31(extraout_var_01,_Var1) != 0))
    {
      uVar2 = tu_fifo_read_n(&_cdcd_itf[iVar3].tx_ff,&_cdcd_epbuf[iVar3].field_1,0x40);
      if (CONCAT22(extraout_var_04,uVar2) == 0) {
        usbd_edpt_release((uint8_t)uVar2,_cdcd_itf[iVar3].ep_in);
      }
      else {
        _Var1 = usbd_edpt_xfer(_usbd_rhport,_cdcd_itf[iVar3].ep_in,_cdcd_epbuf[iVar3].field_1.epin,
                               uVar2);
        if (CONCAT31(extraout_var_02,_Var1) != 0) {
          gp = &__global_pointer_;
          return CONCAT22(extraout_var_04,uVar2);
        }
        ebreak();
      }
    }
  }
  return 0;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint32_t tud_cdc_n_write(uint8_t itf,void *buffer,uint32_t bufsize)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

uint32_t tud_cdc_n_write_available(uint8_t itf)

{
  uint16_t uVar1;
  undefined3 in_register_00002029;
  undefined2 extraout_var;
  
  gp = &__global_pointer_;
  uVar1 = tu_fifo_remaining(&_cdcd_itf[CONCAT31(in_register_00002029,itf)].tx_ff);
  return CONCAT22(extraout_var,uVar1);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void cdcd_init(void)

{
  gp = &__global_pointer_;
  memset(_cdcd_itf,0,0x248);
  _cdcd_fifo_cfg = (tud_cdc_configure_fifo_t)0x0;
  _cdcd_itf[0].wanted_char = -1;
  _cdcd_itf[0].line_coding.bit_rate = 0x1c200;
  _cdcd_itf[0].line_coding.data_bits = '\b';
  tu_fifo_config(&_cdcd_itf[0].rx_ff,_cdcd_itf[0].rx_ff_buf,0x100,1,false);
  tu_fifo_config(&_cdcd_itf[0].tx_ff,_cdcd_itf[0].tx_ff_buf,0x100,1,true);
  mutex_init(&_cdcd_itf[0].rx_ff_mutex);
  mutex_init(&_cdcd_itf[0].tx_ff_mutex);
  _cdcd_itf[0].rx_ff.mutex_rd = &_cdcd_itf[0].rx_ff_mutex;
  _cdcd_itf[0].tx_ff.mutex_wr = &_cdcd_itf[0].tx_ff_mutex;
  _cdcd_itf[0].rx_ff.mutex_wr = (osal_mutex_t)0x0;
  _cdcd_itf[0].tx_ff.mutex_rd = (osal_mutex_t)0x0;
  return;
}



// WARNING: Unknown calling convention

_Bool cdcd_deinit(void)

{
  osal_mutex_t mutex_wr;
  
  gp = &__global_pointer_;
  if (_cdcd_itf[0].rx_ff.mutex_rd != (osal_mutex_t)0x0) {
    _cdcd_itf[0].rx_ff.mutex_wr = (osal_mutex_t)0x0;
  }
  if (_cdcd_itf[0].tx_ff.mutex_wr != (osal_mutex_t)0x0) {
    _cdcd_itf[0].tx_ff.mutex_rd = (osal_mutex_t)0x0;
    _cdcd_itf[0].tx_ff.mutex_wr = (osal_mutex_t)0x0;
  }
  if (_cdcd_itf[0].rx_ff.mutex_rd != (osal_mutex_t)0x0) {
    _cdcd_itf[0].rx_ff.mutex_rd = (osal_mutex_t)0x0;
  }
  return true;
}



// WARNING: Unknown calling convention

void cdcd_reset(uint8_t rhport)

{
  gp = &__global_pointer_;
  _cdcd_itf[0].itf_num = '\0';
  _cdcd_itf[0].ep_notif = '\0';
  _cdcd_itf[0].ep_in = '\0';
  _cdcd_itf[0].ep_out = '\0';
  _cdcd_itf[0].line_state = '\0';
  if (((byte)_cdcd_fifo_cfg & 1) == 0) {
    tu_fifo_clear(&_cdcd_itf[0].rx_ff);
  }
  if (((byte)_cdcd_fifo_cfg & 2) == 0) {
    tu_fifo_clear(&_cdcd_itf[0].tx_ff);
  }
  tu_fifo_set_overwritable(&_cdcd_itf[0].tx_ff,true);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t cdcd_open(uint8_t rhport,tusb_desc_interface_t *itf_desc,uint16_t max_len)

{
  tusb_desc_endpoint_t *desc_ep;
  _Bool _Var1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  if (itf_desc->bInterfaceClass != '\x02') {
    return 0;
  }
  if (itf_desc->bInterfaceSubClass != '\x02') {
    return 0;
  }
  if (_cdcd_itf[0].ep_in == '\0') {
    _cdcd_itf[0].itf_num = itf_desc->bInterfaceNumber;
    desc_ep = (tusb_desc_endpoint_t *)(&itf_desc->bLength + itf_desc->bLength);
    if (desc_ep->bDescriptorType == '$') {
      if (8 < CONCAT22(in_register_00002032,max_len)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
    }
    else if (desc_ep->bDescriptorType == '\x05') {
      _Var1 = usbd_edpt_open(_usbd_rhport,desc_ep);
      if (CONCAT31(extraout_var_00,_Var1) != 0) {
        _cdcd_itf[0].ep_notif = desc_ep->bEndpointAddress;
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
      goto LAB_10014b18;
    }
    if ((desc_ep->bDescriptorType != '\x04') ||
       (*(char *)((int)&desc_ep->wMaxPacketSize + 1) != '\n')) {
      _prep_out_transaction('\0');
      gp = &__global_pointer_;
      return 9;
    }
    _Var1 = usbd_open_edpt_pair(rhport,&desc_ep->bLength + desc_ep->bLength,'\x02','\x02',
                                &_cdcd_itf[0].ep_out,&_cdcd_itf[0].ep_in);
    if (CONCAT31(extraout_var,_Var1) != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
LAB_10014b18:
  ebreak();
  return 0;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10014cd8)
// WARNING: Unknown calling convention

_Bool cdcd_control_xfer_cb(uint8_t rhport,uint8_t stage,tusb_control_request_t *request)

{
  byte bVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_0000202d,stage);
  gp = &__global_pointer_;
  if ((((request->field_0).bmRequestType & 0x60) != 0x20) ||
     ((ushort)_cdcd_itf[0].itf_num != request->wIndex)) {
    return false;
  }
  bVar1 = request->bRequest;
  if (bVar1 == 0x22) {
    if (iVar2 != 1) {
      if (iVar2 != 3) {
        return true;
      }
      _cdcd_itf[0].line_state = (uint8_t)request->wValue;
      tu_fifo_set_overwritable(&_cdcd_itf[0].tx_ff,(_Bool)(_cdcd_itf[0].line_state & 1 ^ 1));
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
  else {
    if (bVar1 < 0x23) {
      if (bVar1 == 0x20) {
        if (iVar2 != 1) {
          if (iVar2 != 3) {
            return true;
          }
          tud_cdc_line_coding_cb('\0',(cdc_line_coding_t *)&_cdcd_itf[0].line_coding);
          return true;
        }
      }
      else {
        if (bVar1 != 0x21) {
          return false;
        }
        if (iVar2 != 1) {
          return true;
        }
      }
      tud_control_xfer(rhport,request,&_cdcd_itf[0].line_coding,7);
      return true;
    }
    if (bVar1 != 0x23) {
      return false;
    }
    if (iVar2 != 1) {
      return true;
    }
  }
  tud_control_status(rhport,request);
  return true;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10014dcc)
// WARNING: Unknown calling convention

_Bool cdcd_xfer_cb(uint8_t rhport,uint8_t ep_addr,xfer_result_t result,uint32_t xferred_bytes)

{
  _Bool _Var1;
  uint16_t uVar2;
  uint32_t uVar3;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  uint uVar4;
  
  uVar4 = CONCAT31(in_register_0000202d,ep_addr);
  gp = &__global_pointer_;
  if (_cdcd_itf[0].ep_out == uVar4) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if (_cdcd_itf[0].ep_in == uVar4) {
    if ((((_cdcd_itf[0].ep_in == uVar4) && (uVar3 = tud_cdc_n_write_flush('\0'), uVar3 == 0)) &&
        (uVar2 = tu_fifo_count(&_cdcd_itf[0].tx_ff), CONCAT22(extraout_var_00,uVar2) == 0)) &&
       (((xferred_bytes != 0 && ((xferred_bytes & 0x3f) == 0)) &&
        (_Var1 = usbd_edpt_claim(rhport,_cdcd_itf[0].ep_in), CONCAT31(extraout_var,_Var1) != 0)))) {
      usbd_edpt_xfer(_usbd_rhport,_cdcd_itf[0].ep_in,(uint8_t *)0x0,0);
    }
    _Var1 = true;
  }
  else {
    ebreak();
    _Var1 = false;
  }
  return _Var1;
}



// WARNING: Unknown calling convention

void tud_hid_set_protocol_cb(uint8_t instance,uint8_t protocol)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

_Bool tud_hid_set_idle_cb(uint8_t instance,uint8_t idle_rate)

{
  gp = &__global_pointer_;
  return true;
}



// WARNING: Unknown calling convention

void tud_hid_report_complete_cb(uint8_t instance,uint8_t *report,uint16_t len)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

void tud_hid_report_failed_cb
               (uint8_t instance,hid_report_type_t_conflict report_type,uint8_t *report,
               uint16_t xferred_bytes)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention

_Bool hidd_deinit(void)

{
  gp = &__global_pointer_;
  return true;
}



// WARNING: Unknown calling convention

void hidd_reset(uint8_t rhport)

{
  gp = &__global_pointer_;
  memset(_hidd_itf,0,0x18);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void hidd_init(void)

{
  gp = &__global_pointer_;
  hidd_reset('\0');
  return;
}



// WARNING: Unknown calling convention

uint16_t hidd_open(uint8_t rhport,tusb_desc_interface_t *desc_itf,uint16_t max_len)

{
  int iVar1;
  byte ep_count;
  int iVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint8_t *puVar4;
  undefined2 in_register_00002032;
  uint uVar5;
  
  gp = &__global_pointer_;
  if (desc_itf->bInterfaceClass == '\x03') {
    ep_count = desc_itf->bNumEndpoints;
    uVar5 = (uint)ep_count * 7 + 0x12;
    if (uVar5 <= CONCAT22(in_register_00002032,max_len)) {
      if (_hidd_itf[0].ep_in == '\0') {
        iVar1 = -0x518;
        iVar2 = 0;
      }
      else {
        if (_hidd_itf[1].ep_in != '\0') goto LAB_10014e98;
        iVar1 = -0x50c;
        iVar2 = 1;
      }
      puVar4 = &desc_itf->bLength + desc_itf->bLength;
      if (puVar4[1] == 0x21) {
        *(uint8_t **)(u8g2_m_16_8_f::buf + iVar1 + 0x100) = puVar4;
        _Var3 = usbd_open_edpt_pair(rhport,puVar4 + *puVar4,ep_count,'\x03',
                                    u8g2_m_16_8_f::buf + iVar1 + 0xfa,
                                    u8g2_m_16_8_f::buf + iVar1 + 0xf9);
        if (CONCAT31(extraout_var,_Var3) != 0) {
          if (desc_itf->bInterfaceSubClass == '\x01') {
            u8g2_m_16_8_f::buf[iVar1 + 0xfb] = desc_itf->bInterfaceProtocol;
          }
          u8g2_m_16_8_f::buf[iVar1 + 0xfe] = '\x01';
          u8g2_m_16_8_f::buf[iVar1 + 0xf8] = desc_itf->bInterfaceNumber;
          *(undefined2 *)(u8g2_m_16_8_f::buf + iVar1 + 0xfc) =
               *(undefined2 *)(*(int *)(u8g2_m_16_8_f::buf + iVar1 + 0x100) + 7);
          if ((u8g2_m_16_8_f::buf[iVar1 + 0xfa] != '\0') &&
             (_Var3 = usbd_edpt_xfer(_usbd_rhport,u8g2_m_16_8_f::buf[iVar1 + 0xfa],
                                     _hidd_epbuf[0].field_2.epout + (-iVar2 & 0xc0),0x40),
             CONCAT31(extraout_var_00,_Var3) == 0)) {
            ebreak();
          }
          goto LAB_10014e9c;
        }
      }
    }
LAB_10014e98:
    ebreak();
  }
  uVar5 = 0;
LAB_10014e9c:
  return (uint16_t)uVar5;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool hidd_control_xfer_cb(uint8_t rhport,uint8_t stage,tusb_control_request_t *request)

{
  byte bVar1;
  uint8_t uVar2;
  char cVar3;
  int iVar4;
  _Bool _Var5;
  uint8_t *buffer;
  undefined3 in_register_0000202d;
  tusb_hid_descriptor_hid_t *buffer_00;
  
  gp = &__global_pointer_;
  bVar1 = (request->field_0).bmRequestType;
  if ((bVar1 & 0x1f) == 1) {
    uVar2 = (uint8_t)request->wIndex;
    if (_hidd_itf[0].itf_num == uVar2) {
      iVar4 = 0;
    }
    else {
      iVar4 = 1;
      if (_hidd_itf[1].itf_num != uVar2) {
        return false;
      }
    }
    if ((bVar1 & 0x60) == 0) {
      if (CONCAT31(in_register_0000202d,stage) != 1) {
LAB_100150f4:
        gp = &__global_pointer_;
        return true;
      }
      if (request->bRequest == '\x06') {
        cVar3 = *(char *)((int)&request->wValue + 1);
        if (cVar3 == '!') {
          buffer_00 = _hidd_itf[iVar4].hid_descriptor;
          if (buffer_00 != (tusb_hid_descriptor_hid_t *)0x0) {
            _Var5 = tud_control_xfer(rhport,request,buffer_00,(ushort)buffer_00->bLength);
            return _Var5;
          }
        }
        else if (cVar3 == '\"') {
          buffer = tud_hid_descriptor_report_cb((uint8_t)iVar4);
          tud_control_xfer(rhport,request,buffer,_hidd_itf[iVar4].report_desc_len);
          goto LAB_100150f4;
        }
      }
    }
    else if (((bVar1 & 0x60) == 0x20) && ((byte)(request->bRequest - 1) < 0xb)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool hidd_xfer_cb(uint8_t rhport,uint8_t ep_addr,xfer_result_t result,uint32_t xferred_bytes)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_0000202d,ep_addr);
  gp = &__global_pointer_;
  if ((((_hidd_itf[0].ep_out != uVar1) && (uVar1 != _hidd_itf[0].ep_in)) &&
      (_hidd_itf[1].ep_out != uVar1)) && (uVar1 != _hidd_itf[1].ep_in)) {
    ebreak();
    return false;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void _prep_out_transaction(uint8_t idx)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  
  iVar3 = CONCAT31(in_register_00002029,idx);
  gp = &__global_pointer_;
  uVar2 = tu_fifo_remaining(&_midid_itf[iVar3].rx_ff);
  if ((0x3f < CONCAT22(extraout_var_00,uVar2)) &&
     (_Var1 = usbd_edpt_claim('\0',_midid_itf[iVar3].ep_out), CONCAT31(extraout_var,_Var1) != 0)) {
    uVar2 = tu_fifo_remaining(&_midid_itf[iVar3].rx_ff);
    if (0x3f < CONCAT22(extraout_var_01,uVar2)) {
      usbd_edpt_xfer(_usbd_rhport,_midid_itf[iVar3].ep_out,_midid_epbuf[iVar3].field_1.epout,0x40);
      return;
    }
    usbd_edpt_release('\0',_midid_itf[iVar3].ep_out);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

uint32_t write_flush(uint8_t idx)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  undefined2 extraout_var_02;
  undefined3 extraout_var_00;
  
  iVar3 = CONCAT31(in_register_00002029,idx);
  gp = &__global_pointer_;
  uVar2 = tu_fifo_count(&_midid_itf[iVar3].tx_ff);
  if ((CONCAT22(extraout_var_01,uVar2) != 0) &&
     (_Var1 = usbd_edpt_claim('\0',_midid_itf[iVar3].ep_in), CONCAT31(extraout_var,_Var1) != 0)) {
    uVar2 = tu_fifo_read_n(&_midid_itf[iVar3].tx_ff,_midid_epbuf + iVar3,0x40);
    if (CONCAT22(extraout_var_02,uVar2) == 0) {
      usbd_edpt_release((uint8_t)uVar2,_midid_itf[iVar3].ep_in);
    }
    else {
      _Var1 = usbd_edpt_xfer(_usbd_rhport,_midid_itf[iVar3].ep_in,(uint8_t *)(_midid_epbuf + iVar3),
                             uVar2);
      if (CONCAT31(extraout_var_00,_Var1) != 0) {
        gp = &__global_pointer_;
        return CONCAT22(extraout_var_02,uVar2);
      }
      ebreak();
    }
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void midid_init(void)

{
  gp = &__global_pointer_;
  memset(_midid_itf,0,200);
  tu_fifo_config(&_midid_itf[0].rx_ff,_midid_itf[0].rx_ff_buf,0x40,1,false);
  tu_fifo_config(&_midid_itf[0].tx_ff,_midid_itf[0].tx_ff_buf,0x40,1,false);
  mutex_init(&_midid_itf[0].rx_ff_mutex);
  mutex_init(&_midid_itf[0].tx_ff_mutex);
  _midid_itf[0].rx_ff.mutex_rd = &_midid_itf[0].rx_ff_mutex;
  _midid_itf[0].tx_ff.mutex_wr = &_midid_itf[0].tx_ff_mutex;
  _midid_itf[0].rx_ff.mutex_wr = (osal_mutex_t)0x0;
  _midid_itf[0].tx_ff.mutex_rd = (osal_mutex_t)0x0;
  return;
}



// WARNING: Unknown calling convention

_Bool midid_deinit(void)

{
  osal_mutex_t mutex_wr;
  
  gp = &__global_pointer_;
  if (_midid_itf[0].rx_ff.mutex_rd != (osal_mutex_t)0x0) {
    _midid_itf[0].rx_ff.mutex_wr = (osal_mutex_t)0x0;
  }
  if (_midid_itf[0].tx_ff.mutex_wr != (osal_mutex_t)0x0) {
    _midid_itf[0].tx_ff.mutex_rd = (osal_mutex_t)0x0;
    _midid_itf[0].tx_ff.mutex_wr = (osal_mutex_t)0x0;
  }
  if (_midid_itf[0].rx_ff.mutex_rd != (osal_mutex_t)0x0) {
    _midid_itf[0].rx_ff.mutex_rd = (osal_mutex_t)0x0;
  }
  return true;
}



// WARNING: Unknown calling convention

void midid_reset(uint8_t rhport)

{
  gp = &__global_pointer_;
  _midid_itf[0].itf_num = '\0';
  _midid_itf[0].ep_in = '\0';
  _midid_itf[0].ep_out = '\0';
  _midid_itf[0].stream_write.buffer[0] = '\0';
  _midid_itf[0].stream_write.buffer[1] = '\0';
  _midid_itf[0].stream_write.buffer[2] = '\0';
  _midid_itf[0].stream_write.buffer[3] = '\0';
  _midid_itf[0].stream_write.index = '\0';
  _midid_itf[0].stream_write.total = '\0';
  _midid_itf[0].stream_read.buffer[0] = '\0';
  _midid_itf[0].stream_read.buffer[1] = '\0';
  _midid_itf[0].stream_read.buffer[2] = '\0';
  _midid_itf[0].stream_read.buffer[3] = '\0';
  _midid_itf[0].stream_read.index = '\0';
  _midid_itf[0].stream_read.total = '\0';
  _midid_itf[0]._15_1_ = 0;
  tu_fifo_clear(&_midid_itf[0].rx_ff);
  tu_fifo_clear(&_midid_itf[0].tx_ff);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t midid_open(uint8_t rhport,tusb_desc_interface_t *desc_itf,uint16_t max_len)

{
  uint uVar1;
  tusb_desc_interface_t *desc_midi;
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  if (((desc_itf->bInterfaceClass == '\x01') && (desc_itf->bInterfaceSubClass == '\x01')) &&
     (desc_itf->bInterfaceProtocol == '\0')) {
    uVar1 = (uint)desc_itf->bLength;
    if ((&desc_itf->bDescriptorType)[uVar1] == '$') {
      if (uVar1 <= CONCAT22(in_register_00002032,max_len)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
    }
    else if ((((&desc_itf->bDescriptorType)[uVar1] == '\x04') &&
             ((&desc_itf->bInterfaceClass)[uVar1] == '\x01')) &&
            (((&desc_itf->bInterfaceSubClass)[uVar1] == '\x03' &&
             ((&desc_itf->bInterfaceProtocol)[uVar1] == '\0')))) {
      if ((_midid_itf[0].ep_in == '\0') && (_midid_itf[0].ep_out == '\0')) {
        _midid_itf[0].itf_num = (&desc_itf->bInterfaceNumber)[uVar1];
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
      ebreak();
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

_Bool midid_control_xfer_cb(uint8_t rhport,uint8_t stage,tusb_control_request_t *request)

{
  gp = &__global_pointer_;
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool midid_xfer_cb(uint8_t rhport,uint8_t ep_addr,xfer_result_t result,uint32_t xferred_bytes)

{
  _Bool _Var1;
  uint16_t uVar2;
  uint32_t uVar3;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  gp = &__global_pointer_;
  if ((uint)_midid_itf[0].ep_out != CONCAT31(in_register_0000202d,ep_addr)) {
    if ((uint)_midid_itf[0].ep_in == CONCAT31(in_register_0000202d,ep_addr)) {
      uVar3 = write_flush('\0');
      if ((((uVar3 == 0) &&
           (uVar2 = tu_fifo_count(&_midid_itf[0].tx_ff), CONCAT22(extraout_var_00,uVar2) == 0)) &&
          (xferred_bytes != 0)) &&
         (((xferred_bytes & 0x3f) == 0 &&
          (_Var1 = usbd_edpt_claim(rhport,_midid_itf[0].ep_in), CONCAT31(extraout_var,_Var1) != 0)))
         ) {
        usbd_edpt_xfer(_usbd_rhport,_midid_itf[0].ep_in,(uint8_t *)0x0,0);
      }
      _Var1 = true;
    }
    else {
      ebreak();
      _Var1 = false;
    }
    return _Var1;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



void fail_scsi_op(uint8_t rhport,mscd_interface_t *p_msc,uint8_t status)

{
  uint8_t ep_addr;
  
  gp = &__global_pointer_;
  _mscd_itf.csw.status = (uint8_t)p_msc;
  _mscd_itf.csw.data_residue = _mscd_itf.cbw.total_bytes - _mscd_itf.xferred_len;
  _mscd_itf.stage = '\x02';
  if (_mscd_itf.sense_key == '\0') {
    _mscd_itf.sense_key = '\x05';
    _mscd_itf.add_sense_code = ' ';
    _mscd_itf.add_sense_qualifier = '\0';
  }
  if ((_mscd_itf.cbw.total_bytes != 0) && (_mscd_itf.csw.data_residue != 0)) {
    ep_addr = _mscd_itf.ep_out;
    if ((char)_mscd_itf.cbw.dir < '\0') {
      ep_addr = _mscd_itf.ep_in;
    }
    usbd_edpt_stall(_usbd_rhport,ep_addr);
    return;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x1001566e)
// WARNING: Removing unreachable block (ram,0x1001567c)

void proc_write10_cmd(uint8_t rhport,mscd_interface_t *p_msc)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



_Bool send_csw(uint8_t rhport,mscd_interface_t *p_msc)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  _mscd_itf.csw.data_residue = _mscd_itf.cbw.total_bytes - _mscd_itf.xferred_len;
  _mscd_itf.stage = '\x03';
  memcpy(&_mscd_epbuf,&_mscd_itf.csw,0xd);
  _Var1 = usbd_edpt_xfer(_usbd_rhport,_mscd_itf.ep_in,(uint8_t *)&_mscd_epbuf,0xd);
  return _Var1;
}



void set_sense_medium_not_present(uint8_t lun)

{
  gp = &__global_pointer_;
  _mscd_itf.sense_key = '\x02';
  _mscd_itf.add_sense_code = ':';
  _mscd_itf.add_sense_qualifier = '\0';
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Variable defined which should be unmapped: event

void proc_read10_cmd(uint8_t rhport,mscd_interface_t *p_msc)

{
  dcd_event_t event;
  
  gp = &__global_pointer_;
  if (_mscd_itf.cbw.command._7_2_ != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void mscd_init(void)

{
  gp = &__global_pointer_;
  memset(&_mscd_itf,0,0x40);
  return;
}



// WARNING: Unknown calling convention

void mscd_reset(uint8_t rhport)

{
  gp = &__global_pointer_;
  memset(&_mscd_itf,0,0x40);
  return;
}



// WARNING: Unknown calling convention

uint16_t mscd_open(uint8_t rhport,tusb_desc_interface_t *itf_desc,uint16_t max_len)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  if (((itf_desc->bInterfaceClass == '\b') && (itf_desc->bInterfaceSubClass == '\x06')) &&
     (itf_desc->bInterfaceProtocol == 'P')) {
    if (0x16 < CONCAT22(in_register_00002032,max_len)) {
      _mscd_itf.itf_num = itf_desc->bInterfaceNumber;
      _Var1 = usbd_open_edpt_pair(rhport,&itf_desc->bLength + itf_desc->bLength,'\x02','\x02',
                                  &_mscd_itf.ep_out,&_mscd_itf.ep_in);
      if (CONCAT31(extraout_var,_Var1) == 0) {
        ebreak();
        uVar2 = 0;
      }
      else {
        _mscd_itf.stage = '\0';
        _Var1 = usbd_edpt_xfer(_usbd_rhport,_mscd_itf.ep_out,(uint8_t *)&_mscd_epbuf,0x1f);
        if (CONCAT31(extraout_var_00,_Var1) == 0) {
          ebreak();
        }
        uVar2 = 0x17;
      }
      return uVar2;
    }
    ebreak();
  }
  return 0;
}



// WARNING: Removing unreachable block (ram,0x100159f0)
// WARNING: Variable defined which should be unmapped: maxlun
// WARNING: Unknown calling convention

_Bool mscd_control_xfer_cb(uint8_t rhport,uint8_t stage,tusb_control_request_t *request)

{
  byte ep_addr;
  uint8_t ep_addr_00;
  _Bool _Var1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 in_register_0000202d;
  mscd_interface_t *p_msc;
  undefined1 auStack_11 [4];
  uint8_t maxlun;
  int iVar2;
  
  ep_addr_00 = _mscd_itf.ep_out;
  gp = &__global_pointer_;
  if (CONCAT31(in_register_0000202d,stage) != 1) {
    return true;
  }
  if (((((request->field_0).bmRequestType & 0x7f) == 2) && (request->bRequest == '\x01')) &&
     (request->wValue == 0)) {
    ep_addr = (byte)request->wIndex;
    p_msc = (mscd_interface_t *)(uint)ep_addr;
    if (_mscd_itf.stage == '\x04') {
      usbd_edpt_stall(_usbd_rhport,ep_addr);
    }
    else if ((mscd_interface_t *)(uint)_mscd_itf.ep_in == p_msc) {
      if (_mscd_itf.stage == '\x02') {
        _Var1 = send_csw(rhport,p_msc);
        iVar2 = CONCAT31(extraout_var,_Var1);
LAB_1001591e:
        if (iVar2 == 0) {
          ebreak();
          goto LAB_10015922;
        }
      }
    }
    else if (((((mscd_interface_t *)(uint)_mscd_itf.ep_out == p_msc) && (_mscd_itf.stage == '\0'))
             && (_Var1 = usbd_edpt_busy(rhport,_mscd_itf.ep_out),
                CONCAT31(extraout_var_00,_Var1) == 0)) &&
            (_Var1 = usbd_edpt_stalled(rhport,ep_addr_00), CONCAT31(extraout_var_01,_Var1) == 0)) {
      _mscd_itf.stage = '\0';
      _Var1 = usbd_edpt_xfer(_usbd_rhport,_mscd_itf.ep_out,(uint8_t *)&_mscd_epbuf,0x1f);
      iVar2 = CONCAT31(extraout_var_02,_Var1);
      goto LAB_1001591e;
    }
    goto LAB_1001590a;
  }
  if (((request->field_0).bmRequestType & 0x60) == 0x20) {
    if (request->bRequest == 0xfe) {
      if ((request->wValue != 0) || (request->wLength != 1)) goto LAB_10015922;
      auStack_11[0] = 0;
      tud_control_xfer(rhport,request,auStack_11,1);
    }
    else {
      if (((request->bRequest != 0xff) || (request->wValue != 0)) || (request->wLength != 0))
      goto LAB_10015922;
      _mscd_itf.stage = '\0';
      _mscd_itf.total_len = 0;
      _mscd_itf.xferred_len = 0;
      _mscd_itf.sense_key = '\0';
      _mscd_itf.add_sense_code = '\0';
      _mscd_itf.add_sense_qualifier = '\0';
      tud_control_status(rhport,request);
    }
LAB_1001590a:
    _Var1 = true;
  }
  else {
LAB_10015922:
    _Var1 = false;
  }
  return _Var1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x10015ee2)
// WARNING: Removing unreachable block (ram,0x10015f24)
// WARNING: Removing unreachable block (ram,0x10015d78)
// WARNING: Removing unreachable block (ram,0x10015efe)
// WARNING: Unknown calling convention

_Bool mscd_xfer_cb(uint8_t rhport,uint8_t ep_addr,xfer_result_t event,uint32_t xferred_bytes)

{
  uint8_t lun;
  _Bool _Var1;
  bool lun_00;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar2;
  undefined3 extraout_var_01;
  int32_t iVar3;
  undefined3 extraout_var_02;
  undefined3 in_register_0000202d;
  mscd_interface_t *pmVar4;
  uint8_t uVar5;
  uint16_t block_size;
  uint32_t block_count;
  uint32_t block_count_1;
  uint8_t auStack_3c [4];
  undefined4 uStack_38;
  uint8_t auStack_34 [16];
  uint8_t auStack_24 [4];
  
  pmVar4 = (mscd_interface_t *)CONCAT31(in_register_0000202d,ep_addr);
  gp = &__global_pointer_;
  if (_mscd_itf.stage == '\x01') {
    if (_mscd_itf.cbw.command[0] == '(') {
      _mscd_itf.xferred_len = _mscd_itf.xferred_len + xferred_bytes;
      if (_mscd_itf.xferred_len < _mscd_itf.total_len) {
        proc_read10_cmd(rhport,pmVar4);
      }
      else {
LAB_10015da0:
        _mscd_itf.stage = '\x02';
      }
    }
    else {
      if (_mscd_itf.cbw.command[0] == '*') {
        if (_mscd_itf.cbw.command._7_2_ == 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
          halt_unimplemented();
        }
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
      _mscd_itf.xferred_len = _mscd_itf.xferred_len + xferred_bytes;
      if (-1 < (char)_mscd_itf.cbw.dir) {
        uVar5 = 'H';
        iVar3 = tud_msc_scsi_cb(_mscd_itf.cbw.lun,_mscd_itf.cbw.command,&_mscd_epbuf,
                                (uint16_t)_mscd_itf.total_len);
        if (iVar3 < 0) {
          fail_scsi_op(rhport,(mscd_interface_t *)&DAT_00000001,uVar5);
        }
      }
      if (_mscd_itf.total_len <= _mscd_itf.xferred_len) goto LAB_10015da0;
      ebreak();
    }
  }
  else if (_mscd_itf.stage == '\x03') {
    if (((mscd_interface_t *)(uint)_mscd_itf.ep_in == pmVar4) && (xferred_bytes == 0xd)) {
      _mscd_itf.stage = '\0';
      _Var1 = usbd_edpt_xfer(_usbd_rhport,_mscd_itf.ep_out,(uint8_t *)&_mscd_epbuf,0x1f);
      if (CONCAT31(extraout_var_00,_Var1) == 0) goto LAB_10015b84;
    }
  }
  else if (_mscd_itf.stage == '\0') {
    if ((mscd_interface_t *)(uint)_mscd_itf.ep_out != pmVar4) {
      return true;
    }
    if ((xferred_bytes != 0x1f) || (_mscd_epbuf.field_0._0_4_ != 0x43425355)) {
      _mscd_itf.stage = '\x04';
      usbd_edpt_stall(_usbd_rhport,_mscd_itf.ep_in);
      usbd_edpt_stall(_usbd_rhport,_mscd_itf.ep_out);
      return false;
    }
    memcpy(&_mscd_itf,&_mscd_epbuf,0x1f);
    lun = _mscd_itf.cbw.lun;
    uVar5 = (uint8_t)xferred_bytes;
    _mscd_itf.csw.signature = 0x53425355;
    _mscd_itf.csw.data_residue = 0;
    _mscd_itf.csw.tag = _mscd_itf.cbw.tag;
    _mscd_itf.csw.status = '\0';
    _mscd_itf.stage = '\x01';
    _mscd_itf.total_len = _mscd_itf.cbw.total_bytes;
    _mscd_itf.xferred_len = 0;
    if ((_mscd_itf.cbw.command[0] & 0xfd) == 0x28) {
      if (_mscd_itf.cbw.total_bytes == 0) {
        if (_mscd_itf.cbw.command._7_2_ == 0) goto LAB_10015da0;
      }
      else {
        uVar5 = -((char)_mscd_itf.cbw.dir >> 7);
        if (_mscd_itf.cbw.command[0] == '(') {
          if (uVar5 != '\0') {
LAB_10015b3c:
            if (_mscd_itf.cbw.command._7_2_ != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
              halt_unimplemented();
            }
            goto LAB_10015b6e;
          }
        }
        else if (uVar5 == '\0') goto LAB_10015b3c;
      }
      pmVar4 = (mscd_interface_t *)0x2;
    }
    else {
      if ((_mscd_itf.cbw.total_bytes == 0) || ((char)_mscd_itf.cbw.dir < '\0')) {
        if (_mscd_itf.cbw.command[0] < 0x26) {
          if (0x19 < _mscd_itf.cbw.command[0]) {
            if ((byte)(_mscd_itf.cbw.command[0] - 0x1a) < 0xc) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
              halt_unimplemented();
            }
            goto LAB_10015ba8;
          }
          if (_mscd_itf.cbw.command[0] == '\x03') {
            block_count = CONCAT12(_mscd_itf.sense_key,0xf0) & 0xff0fffff;
            uVar5 = '\x12';
            block_count_1 = 0xa000000;
            auStack_3c[0] = '\0';
            auStack_3c[1] = '\0';
            auStack_3c[2] = '\0';
            auStack_3c[3] = '\0';
            auStack_34[0] = '\0';
            auStack_34[1] = '\0';
            uStack_38 = (uint)CONCAT11(_mscd_itf.add_sense_qualifier,_mscd_itf.add_sense_code);
            memcpy(&_mscd_epbuf,&block_count,0x12);
            iVar2 = 0x12;
            _mscd_itf.sense_key = '\0';
            _mscd_itf.add_sense_code = '\0';
            _mscd_itf.add_sense_qualifier = '\0';
            goto LAB_10015d96;
          }
          if (_mscd_itf.cbw.command[0] == '\x12') {
            block_count = 0x2028000;
            block_count_1 = 0x1f;
            builtin_memcpy(auStack_3c,"    ",4);
            uStack_38 = 0x20202020;
            memset(auStack_34,0x20,0x10);
            builtin_memcpy(auStack_24,"    ",4);
            tud_msc_inquiry_cb(lun,auStack_3c,auStack_34,auStack_24);
            uVar5 = '$';
            memcpy(&_mscd_epbuf,&block_count,0x24);
            goto LAB_10015c62;
          }
          if (_mscd_itf.cbw.command[0] != '\0') goto LAB_10015ba8;
          lun_00 = tud_msc_test_unit_ready_cb(_mscd_itf.cbw.lun);
          if (CONCAT31(extraout_var_01,lun_00) == 0) {
            if (_mscd_itf.sense_key == '\0') {
              set_sense_medium_not_present(lun_00);
            }
            goto LAB_10015ba8;
          }
LAB_10015d9a:
          if (_mscd_itf.cbw.total_bytes == 0) goto LAB_10015da0;
        }
        else {
LAB_10015ba8:
          if (_mscd_itf.sense_key == '\0') {
            uVar5 = 'H';
            iVar2 = tud_msc_scsi_cb(_mscd_itf.cbw.lun,_mscd_itf.cbw.command,&_mscd_epbuf,
                                    (uint16_t)_mscd_itf.total_len);
            if (-1 < iVar2) {
LAB_10015d96:
              if (iVar2 == 0) goto LAB_10015d9a;
LAB_10015c62:
              if (_mscd_itf.cbw.total_bytes != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
                halt_unimplemented();
              }
            }
          }
        }
      }
      else if (_mscd_itf.cbw.total_bytes < 0x41) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
        halt_unimplemented();
      }
LAB_10015b6e:
      pmVar4 = (mscd_interface_t *)&DAT_00000001;
    }
    fail_scsi_op(rhport,pmVar4,uVar5);
  }
  if (_mscd_itf.stage != '\x02') {
    return true;
  }
  pmVar4 = (mscd_interface_t *)(uint)_mscd_itf.ep_in;
  _Var1 = usbd_edpt_stalled(rhport,_mscd_itf.ep_in);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    return true;
  }
  if ((_mscd_itf.xferred_len < _mscd_itf.cbw.total_bytes) && ((char)_mscd_itf.cbw.dir < '\0')) {
    usbd_edpt_stall(_usbd_rhport,_mscd_itf.ep_in);
    return true;
  }
  _Var1 = send_csw(rhport,pmVar4);
  if (CONCAT31(extraout_var_02,_Var1) != 0) {
    return true;
  }
LAB_10015b84:
  ebreak();
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tusb_rhport_init(uint8_t rhport,tusb_rhport_init_t_conflict *rh_init)

{
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined1 auStack_18 [4];
  tusb_rhport_init_t_conflict dev_init;
  int iVar2;
  
  gp = &__global_pointer_;
  if (rh_init == (tusb_rhport_init_t_conflict *)0x0) {
    auStack_18 = (undefined1  [4])0x1;
    dev_init.role = TUSB_ROLE_INVALID;
    _Var1 = tud_rhport_init('\0',(tusb_rhport_init_t_conflict *)auStack_18);
    iVar2 = CONCAT31(extraout_var,_Var1);
    if (iVar2 == 0) {
      ebreak();
    }
    else {
      _tusb_rhport_role[0] = TUSB_ROLE_DEVICE;
    }
  }
  else {
    if ((CONCAT31(in_register_00002029,rhport) < 2) && (rh_init->role != TUSB_ROLE_INVALID)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    ebreak();
    iVar2 = 0;
  }
  return SUB41(iVar2,0);
}



// WARNING: Unknown calling convention

_Bool tusb_inited(void)

{
  gp = &__global_pointer_;
  return _usbd_rhport != 0xff;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tu_edpt_claim(tu_edpt_state_t *ep_state,osal_mutex_t mutex)

{
  gp = &__global_pointer_;
  if (((byte)*ep_state & 1) == 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tu_edpt_release(tu_edpt_state_t *ep_state,osal_mutex_t mutex)

{
  gp = &__global_pointer_;
  mutex_enter_timeout_ms(mutex,0xffffffff);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tu_edpt_validate(tusb_desc_endpoint_t *desc_ep,tusb_speed_t_conflict speed)

{
  byte bVar1;
  uint16_t spec_size;
  ushort uVar2;
  uint16_t max_packet_size;
  ushort uVar3;
  
  gp = &__global_pointer_;
  bVar1 = (byte)desc_ep->bmAttributes & 3;
  uVar3 = desc_ep->wMaxPacketSize & 0x7ff;
  if (bVar1 == 2) {
    uVar2 = 0x40;
    if (speed == TUSB_SPEED_HIGH) {
      if (uVar3 == 0x200) {
        return true;
      }
      goto LAB_10016086;
    }
  }
  else if (bVar1 == 3) {
    uVar2 = 0x40;
    if (speed == TUSB_SPEED_HIGH) {
      uVar2 = 0x400;
    }
  }
  else {
    if (bVar1 != 1) {
      return false;
    }
    uVar2 = (speed == TUSB_SPEED_HIGH) + 0x3ff;
  }
  if (uVar3 <= uVar2) {
    return true;
  }
LAB_10016086:
  ebreak();
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void tu_edpt_bind_driver(uint8_t (*ep2drv) [2],tusb_desc_interface_t *desc_itf,uint16_t desc_len,
                        uint8_t driver_id)

{
  uint8_t *puVar1;
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  puVar1 = &desc_itf->bLength;
  while( true ) {
    if ((tusb_desc_interface_t *)(puVar1 + CONCAT22(in_register_00002032,desc_len)) <= desc_itf) {
      return;
    }
    if (desc_itf->bDescriptorType == '\x05') break;
    desc_itf = (tusb_desc_interface_t *)(&desc_itf->bLength + desc_itf->bLength);
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t advance_index(uint16_t depth,uint16_t idx,uint16_t offset)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool _tu_fifo_peek(tu_fifo_t *f,void *p_buffer,uint16_t wr_idx,uint16_t rd_idx)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions

uint16_t _tu_fifo_peek_n(tu_fifo_t *f,void *p_buffer,uint16_t n,uint16_t wr_idx,uint16_t rd_idx,
                        tu_fifo_copy_mode_t copy_mode)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tu_fifo_config(tu_fifo_t *f,void *buffer,uint16_t depth,uint16_t item_size,_Bool overwritable)

{
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  if (CONCAT22(in_register_00002032,depth) < 0x8001) {
    if (f->mutex_wr != (mutex_t *)0x0) {
      mutex_enter_timeout_ms(f->mutex_wr,0xffffffff);
    }
    if (f->mutex_rd != (mutex_t *)0x0) {
      mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
    }
    f->rd_idx = 0;
    f->buffer = (uint8_t *)buffer;
    f->depth = depth;
    f->field_2 = (anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2)
                 ((ushort)overwritable << 0xf | (ushort)(((uint)item_size << 0x11) >> 0x11));
    f->wr_idx = 0;
    if (f->mutex_wr != (mutex_t *)0x0) {
      mutex_exit(f->mutex_wr);
    }
    if (f->mutex_rd != (mutex_t *)0x0) {
      mutex_exit(f->mutex_rd);
    }
    return true;
  }
  return false;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t tu_fifo_count(tu_fifo_t *f)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tu_fifo_empty(tu_fifo_t *f)

{
  gp = &__global_pointer_;
  return f->wr_idx == f->rd_idx;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tu_fifo_full(tu_fifo_t *f)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t tu_fifo_remaining(tu_fifo_t *f)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool tu_fifo_read(tu_fifo_t *f,void *buffer)

{
  _Bool _Var1;
  uint16_t uVar2;
  undefined3 extraout_var;
  
  gp = &__global_pointer_;
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
  }
  _Var1 = _tu_fifo_peek(f,buffer,f->wr_idx,f->rd_idx);
  uVar2 = advance_index(f->depth,f->rd_idx,(uint16_t)CONCAT31(extraout_var,_Var1));
  f->rd_idx = uVar2;
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_exit(f->mutex_rd);
  }
  return _Var1;
}



// WARNING: Unknown calling convention

uint16_t tu_fifo_read_n(tu_fifo_t *f,void *buffer,uint16_t n)

{
  uint16_t offset;
  uint16_t uVar1;
  tu_fifo_copy_mode_t in_a5;
  
  gp = &__global_pointer_;
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
  }
  offset = _tu_fifo_peek_n(f,buffer,n,f->wr_idx,f->rd_idx,in_a5);
  uVar1 = advance_index(f->depth,f->rd_idx,offset);
  f->rd_idx = uVar1;
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_exit(f->mutex_rd);
  }
  return offset;
}



// WARNING: Unknown calling convention

_Bool tu_fifo_peek(tu_fifo_t *f,void *p_buffer)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
  }
  _Var1 = _tu_fifo_peek(f,p_buffer,f->wr_idx,f->rd_idx);
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_exit(f->mutex_rd);
  }
  return _Var1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool tu_fifo_write(tu_fifo_t *f,void *data)

{
  gp = &__global_pointer_;
  if (f->mutex_wr != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_wr,0xffffffff);
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint16_t tu_fifo_write_n(tu_fifo_t *f,void *data,uint16_t n)

{
  undefined2 in_register_00002032;
  
  gp = &__global_pointer_;
  if (CONCAT22(in_register_00002032,n) != 0) {
    if (f->mutex_wr != (mutex_t *)0x0) {
      mutex_enter_timeout_ms(f->mutex_wr,0xffffffff);
    }
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return n;
}



// WARNING: Unknown calling convention

_Bool tu_fifo_clear(tu_fifo_t *f)

{
  gp = &__global_pointer_;
  if (f->mutex_wr != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_wr,0xffffffff);
  }
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
  }
  f->rd_idx = 0;
  f->wr_idx = 0;
  if (f->mutex_wr != (mutex_t *)0x0) {
    mutex_exit(f->mutex_wr);
  }
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_exit(f->mutex_rd);
  }
  return true;
}



// WARNING: Unknown calling convention

_Bool tu_fifo_set_overwritable(tu_fifo_t *f,_Bool overwritable)

{
  gp = &__global_pointer_;
  if (f->mutex_wr != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_wr,0xffffffff);
  }
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_enter_timeout_ms(f->mutex_rd,0xffffffff);
  }
  f->field_2 = (anon_struct_2_2_3a7a4ba6_for_tu_fifo_t_2)
               ((ushort)f->field_2 & 0x7fff | (ushort)overwritable << 0xf);
  if (f->mutex_wr != (mutex_t *)0x0) {
    mutex_exit(f->mutex_wr);
  }
  if (f->mutex_rd != (mutex_t *)0x0) {
    mutex_exit(f->mutex_rd);
  }
  return true;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint32_t hw_claim_lock(void)

{
  uint32_t save;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

void hw_claim_unlock(uint32_t save)

{
  gp = &__global_pointer_;
  fence();
  _sw_spin_locks[0xb] = '\0';
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool hw_is_claimed(uint8_t *bits,uint bit_index)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void hw_claim_or_assert(uint8_t *bits,uint bit_index,char *message)

{
  _Bool _Var1;
  undefined3 extraout_var;
  
  gp = &__global_pointer_;
  hw_claim_lock();
  _Var1 = hw_is_claimed(bits,bit_index);
  if (CONCAT31(extraout_var,_Var1) != 0) {
                    // WARNING: Subroutine does not return
    panic(message,bit_index);
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

int hw_claim_unused_from_range(uint8_t *bits,_Bool required,uint bit_lsb,uint bit_msb,char *message)

{
  _Bool _Var1;
  uint32_t save;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  gp = &__global_pointer_;
  save = hw_claim_lock();
  for (; bit_lsb <= bit_msb; bit_lsb = bit_lsb + 1) {
    _Var1 = hw_is_claimed(bits,bit_lsb);
    if (CONCAT31(extraout_var,_Var1) == 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
  }
  hw_claim_unlock(save);
  if (CONCAT31(in_register_0000202d,required) == 0) {
    return -1;
  }
                    // WARNING: Subroutine does not return
  panic(message);
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void hw_claim_clear(uint8_t *bits,uint bit_index)

{
  gp = &__global_pointer_;
  hw_claim_lock();
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

uint next_striped_spin_lock_num(void)

{
  uint rc;
  uint uVar1;
  uint uVar2;
  
  gp = &__global_pointer_;
  uVar1 = (uint)striped_spin_lock_num;
  uVar2 = uVar1 + 1;
  striped_spin_lock_num = (uint8_t)uVar2;
  if (0x17 < (uVar2 & 0xff)) {
    striped_spin_lock_num = '\x10';
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int spin_lock_claim_unused(_Bool required)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = hw_claim_unused_from_range
                    ((uint8_t *)&claimed,required,0x18,0x1f,"No spinlocks are available");
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void spin_locks_reset(void)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = 0;
  do {
    fence();
    _sw_spin_locks[iVar1] = '\0';
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x20);
  return;
}



// WARNING: Unknown calling convention

void lock_init(lock_core_t *core,uint lock_num)

{
  gp = &__global_pointer_;
  core->spin_lock = _sw_spin_locks + lock_num;
  return;
}



// WARNING: Unknown calling convention

void critical_section_init(critical_section_t *crit_sec)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = spin_lock_claim_unused(true);
  crit_sec->spin_lock = _sw_spin_locks + iVar1;
  fence();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

_Bool check_single_timeout_us(timeout_state_t *ts,_Bool reset)

{
  _Bool _Var1;
  uint uVar2;
  
  gp = &__global_pointer_;
  uVar2 = *(uint *)((int)&ts->next_timeout + 4);
  if (_DAT_400b0024 < uVar2) {
    _Var1 = false;
  }
  else {
    _Var1 = true;
    if (_DAT_400b0028 < (uint)ts->next_timeout) {
      return uVar2 != _DAT_400b0024;
    }
  }
  return _Var1;
}



check_timeout_fn init_single_timeout_until(timeout_state_t *ts,absolute_time_t target)

{
  undefined4 in_a1;
  undefined4 in_a2;
  
  gp = &__global_pointer_;
  *(undefined4 *)&ts->next_timeout = in_a1;
  *(undefined4 *)((int)&ts->next_timeout + 4) = in_a2;
  return check_single_timeout_us;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void xosc_init(void)

{
  gp = &__global_pointer_;
  _DAT_40048000 = 0xaa0;
  _DAT_4004800c = 0xbc0;
  _DAT_4004a000 = 0xfab000;
  do {
  } while (-1 < _DAT_40048004);
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void hw_endpoint_init(uint8_t ep_addr,uint16_t wMaxPacketSize,uint8_t transfer_type)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



void hw_endpoint_alloc(hw_endpoint *ep,size_t size)

{
  uint uVar1;
  uint8_t *puVar2;
  
  gp = &__global_pointer_;
  uVar1 = ep->wMaxPacketSize + 0x3f & 0xffffffc0;
  if (ep->transfer_type == '\x02') {
    uVar1 = uVar1 << 1;
  }
  puVar2 = next_buffer_ptr + uVar1;
  ep->hw_data_buf = next_buffer_ptr;
  next_buffer_ptr = puVar2;
  if ((uint8_t *)0x50100fff < puVar2) {
    hard_assertion_failure();
    return;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

_Bool dcd_init(uint8_t rhport,tusb_rhport_init_t_conflict *rh_init)

{
  gp = &__global_pointer_;
  rp2040_usb_init();
  _DAT_50110078 = 0xc;
  irq_add_shared_handler(0xe,dcd_rp2040_irq,0xff);
  memset(hw_endpoints,0,0x40);
  hw_endpoint_init('\0',0x40,'\0');
  hw_endpoint_init(0x80,0x40,'\0');
  reset_non_control_endpoints();
  _DAT_50110040 = 1;
  _DAT_5011004c = 0x20000000;
  _DAT_50110090 = 0x1d010;
  _DAT_5011204c = 0x10000;
  return true;
}



// WARNING: Unknown calling convention

void dcd_int_enable(uint8_t rhport)

{
  gp = &__global_pointer_;
  irq_set_enabled(0xe,true);
  return;
}



// WARNING: Unknown calling convention

void dcd_set_address(uint8_t rhport,uint8_t dev_addr)

{
  gp = &__global_pointer_;
  hw_endpoint_xfer_start(hw_endpoints[0] + 1,(uint8_t *)0x0,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dcd_disconnect(uint8_t rhport)

{
  gp = &__global_pointer_;
  _DAT_5011304c = 0x10000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dcd_connect(uint8_t rhport)

{
  gp = &__global_pointer_;
  _DAT_5011204c = 0x10000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dcd_sof_enable(uint8_t rhport,_Bool en)

{
  undefined3 in_register_0000202d;
  
  gp = &__global_pointer_;
  _sof_enable = en;
  if (CONCAT31(in_register_0000202d,en) != 0) {
    _DAT_50112090 = 0x20000;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dcd_edpt0_status_complete(uint8_t rhport,tusb_control_request_t *request)

{
  gp = &__global_pointer_;
  if ((((request->field_0).bmRequestType & 0x7f) == 0) && (request->bRequest == '\x05')) {
    _DAT_50110000 = (uint)(byte)request->wValue;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool dcd_edpt_open(uint8_t rhport,tusb_desc_endpoint_t *desc_edpt)

{
  byte ep_addr;
  byte transfer_type;
  
  gp = &__global_pointer_;
  transfer_type = (byte)desc_edpt->bmAttributes & 3;
  if (transfer_type == 1) {
    return false;
  }
  ep_addr = desc_edpt->bEndpointAddress;
  hw_endpoint_init(ep_addr,desc_edpt->wMaxPacketSize & 0x7ff,transfer_type);
  if ((ep_addr & 0x7f) != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return true;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void dcd_edpt_close_all(void)

{
  gp = &__global_pointer_;
  reset_non_control_endpoints();
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool dcd_edpt_xfer(uint8_t rhport,uint8_t ep_addr,uint8_t *buffer,uint16_t total_bytes)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void dcd_edpt_stall(uint8_t rhport,uint8_t ep_addr)

{
  undefined3 in_register_0000202d;
  
  gp = &__global_pointer_;
  if ((ep_addr & 0x7f) == 0) {
    _DAT_50112068 = (CONCAT31(in_register_0000202d,ep_addr) == 0) + 1;
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void dcd_edpt_clear_stall(uint8_t rhport,uint8_t ep_addr)

{
  gp = &__global_pointer_;
  if ((ep_addr & 0x7f) != 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void rp2040_usb_init(void)

{
  gp = &__global_pointer_;
  _DAT_40022000 = 0x10000000;
  _DAT_40023000 = 0x10000000;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void hw_endpoint_xfer_start(hw_endpoint *ep,uint8_t *buffer,uint16_t total_len)

{
  _Bool _Var1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  gp = &__global_pointer_;
  ep->remaining_len = total_len;
  ep->xferred_len = 0;
  ep->active = true;
  ep->user_buf = buffer;
  _Var1 = e15_is_bulkin_ep(ep);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    _DAT_50112090 = 0x20000;
  }
  _Var1 = e15_is_critical_frame_period(ep);
  if (CONCAT31(extraout_var_00,_Var1) != 0) {
    ep->pending = '\x01';
    return;
  }
  hw_endpoint_start_next_buffer(ep);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void rp2040_usb_device_enumeration_fix(void)

{
  gp = &__global_pointer_;
  return;
}



// WARNING: Unknown calling convention
// DWARF original name: operator delete

void operator_delete(void *ptr,size_t param_2)

{
  gp = &__global_pointer_;
  noInterrupts();
  free(ptr);
  interrupts();
  return;
}



// WARNING: Unknown calling convention
// DWARF original name: operator delete []

void operator_delete___(void *ptr)

{
  gp = &__global_pointer_;
  noInterrupts();
  free(ptr);
  interrupts();
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention
// DWARF original name: operator new

void * operator_new(size_t sz)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention
// DWARF original name: operator new []

void * operator_new___(size_t sz)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Rb_tree_node_base * std::_Rb_tree_increment(_Rb_tree_node_base *__x)

{
  _Rb_tree_node_base *p_Var1;
  _Base_ptr p_Var2;
  _Base_ptr p_Var3;
  
  gp = &__global_pointer_;
  p_Var3 = __x->_M_right;
  if (p_Var3 != (_Base_ptr)0x0) {
    do {
      p_Var1 = p_Var3;
      p_Var3 = p_Var3->_M_left;
    } while (p_Var3 != (_Base_ptr)0x0);
    return p_Var1;
  }
  p_Var3 = __x->_M_parent;
  if (__x == p_Var3->_M_right) {
    do {
      p_Var2 = p_Var3;
      p_Var3 = p_Var2->_M_parent;
    } while (p_Var2 == p_Var3->_M_right);
    if (p_Var3 == p_Var2->_M_right) {
      return p_Var2;
    }
  }
  return p_Var3;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::_Rb_tree_increment(std::_Rb_tree_node_base const*)

_Base_ptr std::_Rb_tree_increment(_Rb_tree_node_base *param_1)

{
  _Base_ptr p_Var1;
  _Base_ptr p_Var2;
  
  gp = &__global_pointer_;
  p_Var2 = param_1->_M_right;
  if (p_Var2 != (_Base_ptr)0x0) {
    do {
      p_Var1 = p_Var2;
      p_Var2 = p_Var2->_M_left;
    } while (p_Var2 != (_Base_ptr)0x0);
    return p_Var1;
  }
  p_Var2 = param_1->_M_parent;
  if (param_1 == p_Var2->_M_right) {
    do {
      p_Var1 = p_Var2;
      p_Var2 = p_Var1->_M_parent;
    } while (p_Var2->_M_right == p_Var1);
    if (p_Var2 == p_Var1->_M_right) {
      return p_Var1;
    }
  }
  return p_Var2;
}



// WARNING: Unknown calling convention

_Rb_tree_node_base * std::_Rb_tree_decrement(_Rb_tree_node_base *__x)

{
  bool bVar1;
  _Rb_tree_node_base *p_Var2;
  _Base_ptr p_Var3;
  
  gp = &__global_pointer_;
  if ((__x->_M_color == _S_red) && (__x == __x->_M_parent->_M_parent)) {
    return __x->_M_right;
  }
  p_Var3 = __x->_M_left;
  if (p_Var3 != (_Base_ptr)0x0) {
    do {
      p_Var2 = p_Var3;
      p_Var3 = p_Var3->_M_right;
    } while (p_Var3 != (_Base_ptr)0x0);
    return p_Var2;
  }
  p_Var2 = __x->_M_parent;
  p_Var3 = p_Var2;
  if (__x == p_Var2->_M_left) {
    do {
      p_Var2 = p_Var3->_M_parent;
      bVar1 = p_Var2->_M_left == p_Var3;
      p_Var3 = p_Var2;
    } while (bVar1);
  }
  return p_Var2;
}



// WARNING: Unknown calling convention

void std::_Rb_tree_insert_and_rebalance
               (bool __insert_left,_Rb_tree_node_base *__x,_Rb_tree_node_base *__p,
               _Rb_tree_node_base *__header)

{
  undefined3 in_register_00002029;
  _Rb_tree_node_base *p_Var1;
  _Rb_tree_node_base *p_Var2;
  _Rb_tree_node_base *p_Var3;
  _Rb_tree_node_base *p_Var4;
  _Base_ptr p_Var5;
  _Base_ptr p_Var6;
  _Base_ptr p_Var7;
  
  gp = &__global_pointer_;
  __x->_M_left = (_Base_ptr)0x0;
  __x->_M_right = (_Base_ptr)0x0;
  __x->_M_color = _S_red;
  __x->_M_parent = __p;
  if (CONCAT31(in_register_00002029,__insert_left) == 0) {
    __p->_M_right = __x;
    p_Var1 = __header->_M_parent;
    if (__header->_M_right == __p) {
      __header->_M_right = __x;
    }
  }
  else {
    __p->_M_left = __x;
    if (__header == __p) {
      __header->_M_parent = __x;
      __header->_M_right = __x;
      __x->_M_color = _S_black;
      return;
    }
    p_Var1 = __header->_M_parent;
    if (__header->_M_left == __p) {
      __header->_M_left = __x;
    }
  }
  if (__x != p_Var1) {
    do {
      while( true ) {
        p_Var4 = __x->_M_parent;
        if (p_Var4->_M_color != _S_red) goto LAB_10016da0;
        p_Var6 = p_Var4->_M_parent;
        p_Var3 = p_Var6->_M_left;
        if (p_Var3 != p_Var4) break;
        p_Var7 = p_Var6->_M_right;
        if ((p_Var7 == (_Base_ptr)0x0) || (p_Var7->_M_color != _S_red)) {
          p_Var2 = __x;
          if (p_Var4->_M_right == __x) {
            p_Var7 = __x->_M_left;
            p_Var4->_M_right = p_Var7;
            if (p_Var7 == (_Base_ptr)0x0) {
              __x->_M_parent = p_Var6;
              p_Var7 = p_Var6;
              if (p_Var4 == __header->_M_parent) goto LAB_10016e60;
LAB_10016e58:
              p_Var7->_M_left = __x;
            }
            else {
              p_Var7->_M_parent = p_Var4;
              p_Var7 = p_Var4->_M_parent;
              __x->_M_parent = p_Var7;
              if (p_Var4 == __header->_M_parent) {
LAB_10016e60:
                __header->_M_parent = __x;
              }
              else {
                if (p_Var4 == p_Var7->_M_left) goto LAB_10016e58;
                p_Var7->_M_right = __x;
              }
            }
            __x->_M_left = p_Var4;
            p_Var3 = p_Var6->_M_left;
            p_Var4->_M_parent = __x;
            p_Var2 = p_Var4;
            p_Var4 = __x;
          }
          p_Var7 = p_Var3->_M_right;
          p_Var4->_M_color = _S_black;
          p_Var6->_M_color = _S_red;
          p_Var6->_M_left = p_Var7;
          if (p_Var7 != (_Base_ptr)0x0) {
            p_Var7->_M_parent = p_Var6;
          }
          p_Var7 = p_Var6->_M_parent;
          p_Var3->_M_parent = p_Var7;
          if (p_Var6 == __header->_M_parent) {
            __header->_M_parent = p_Var3;
          }
          else if (p_Var6 == p_Var7->_M_right) {
            p_Var7->_M_right = p_Var3;
          }
          else {
            p_Var7->_M_left = p_Var3;
          }
          p_Var3->_M_right = p_Var6;
          p_Var6->_M_parent = p_Var3;
          p_Var1 = __header->_M_parent;
        }
        else {
          p_Var3->_M_color = _S_black;
          p_Var7->_M_color = _S_black;
LAB_10016d36:
          p_Var6->_M_color = _S_red;
          p_Var2 = p_Var6;
        }
        __x = p_Var2;
        if (p_Var1 == p_Var2) goto LAB_10016da0;
      }
      if ((p_Var3 != (_Rb_tree_node_base *)0x0) && (p_Var3->_M_color == _S_red)) {
        p_Var4->_M_color = _S_black;
        p_Var3->_M_color = _S_black;
        goto LAB_10016d36;
      }
      p_Var3 = __x;
      if (p_Var4->_M_left == __x) {
        p_Var5 = __x->_M_right;
        p_Var4->_M_left = p_Var5;
        p_Var7 = p_Var6;
        if (p_Var5 != (_Base_ptr)0x0) {
          p_Var5->_M_parent = p_Var4;
          p_Var7 = p_Var4->_M_parent;
        }
        __x->_M_parent = p_Var7;
        if (p_Var4 == __header->_M_parent) {
          __header->_M_parent = __x;
        }
        else if (p_Var4 == p_Var7->_M_right) {
          p_Var7->_M_right = __x;
        }
        else {
          p_Var7->_M_left = __x;
        }
        __x->_M_right = p_Var4;
        p_Var4->_M_parent = __x;
        p_Var3 = p_Var4;
        p_Var4 = __x;
      }
      p_Var7 = p_Var6->_M_right;
      p_Var4->_M_color = _S_black;
      p_Var6->_M_color = _S_red;
      p_Var5 = p_Var7->_M_left;
      p_Var6->_M_right = p_Var5;
      if (p_Var5 != (_Base_ptr)0x0) {
        p_Var5->_M_parent = p_Var6;
      }
      p_Var5 = p_Var6->_M_parent;
      p_Var7->_M_parent = p_Var5;
      if (p_Var6 == __header->_M_parent) {
        __header->_M_parent = p_Var7;
      }
      else if (p_Var6 == p_Var5->_M_left) {
        p_Var5->_M_left = p_Var7;
      }
      else {
        p_Var5->_M_right = p_Var7;
      }
      p_Var7->_M_left = p_Var6;
      p_Var6->_M_parent = p_Var7;
      p_Var1 = __header->_M_parent;
      __x = p_Var3;
    } while (p_Var1 != p_Var3);
  }
LAB_10016da0:
  p_Var1->_M_color = _S_black;
  return;
}



// WARNING: Unknown calling convention

_Rb_tree_node_base *
std::_Rb_tree_rebalance_for_erase(_Rb_tree_node_base *__z,_Rb_tree_node_base *__header)

{
  bool bVar1;
  _Rb_tree_node_base *p_Var2;
  _Rb_tree_color _Var3;
  _Rb_tree_node_base *p_Var4;
  _Rb_tree_node_base *p_Var5;
  _Rb_tree_node_base *p_Var6;
  _Rb_tree_node_base *p_Var7;
  _Base_ptr p_Var8;
  _Base_ptr p_Var9;
  _Rb_tree_color _Var10;
  _Base_ptr p_Var11;
  
  gp = &__global_pointer_;
  p_Var7 = __z->_M_left;
  p_Var2 = __z->_M_right;
  p_Var4 = p_Var2;
  if (p_Var7 == (_Rb_tree_node_base *)0x0) {
LAB_10017032:
    p_Var6 = __z->_M_parent;
    bVar1 = p_Var4 != (_Rb_tree_node_base *)0x0;
    p_Var7 = p_Var4;
    p_Var4 = (_Rb_tree_node_base *)0x0;
    if (bVar1) goto LAB_10016f8a;
  }
  else {
    if (p_Var2 != (_Rb_tree_node_base *)0x0) {
      do {
        p_Var5 = p_Var4;
        p_Var4 = p_Var5->_M_left;
      } while (p_Var5->_M_left != (_Base_ptr)0x0);
      p_Var4 = p_Var5->_M_right;
      if (p_Var5 != __z) {
        p_Var7->_M_parent = p_Var5;
        p_Var5->_M_left = p_Var7;
        p_Var6 = p_Var2;
        if (p_Var5 != p_Var2) {
          p_Var6 = p_Var5->_M_parent;
          if (p_Var4 != (_Base_ptr)0x0) {
            p_Var4->_M_parent = p_Var6;
          }
          p_Var6->_M_left = p_Var4;
          p_Var5->_M_right = p_Var2;
          __z->_M_right->_M_parent = p_Var5;
        }
        if (__header->_M_parent == __z) {
          __header->_M_parent = p_Var5;
          p_Var8 = __z->_M_parent;
        }
        else {
          p_Var8 = __z->_M_parent;
          if (p_Var8->_M_left == __z) {
            p_Var8->_M_left = p_Var5;
          }
          else {
            p_Var8->_M_right = p_Var5;
          }
        }
        _Var10 = __z->_M_color;
        _Var3 = p_Var5->_M_color;
        p_Var5->_M_parent = p_Var8;
        p_Var5->_M_color = _Var10;
        __z->_M_color = _Var3;
        goto LAB_10016ec2;
      }
      goto LAB_10017032;
    }
    p_Var6 = __z->_M_parent;
LAB_10016f8a:
    p_Var7->_M_parent = p_Var6;
    p_Var4 = p_Var7;
  }
  if (__header->_M_parent == __z) {
    __header->_M_parent = p_Var4;
  }
  else {
    p_Var8 = __z->_M_parent;
    if (p_Var8->_M_left == __z) {
      p_Var8->_M_left = p_Var4;
    }
    else {
      p_Var8->_M_right = p_Var4;
    }
  }
  if (__header->_M_left == __z) {
    p_Var7 = p_Var4;
    if (__z->_M_right == (_Base_ptr)0x0) {
      __header->_M_left = __z->_M_parent;
    }
    else {
      do {
        p_Var2 = p_Var7;
        p_Var7 = p_Var2->_M_left;
      } while (p_Var7 != (_Base_ptr)0x0);
      __header->_M_left = p_Var2;
    }
  }
  if (__header->_M_right == __z) {
    p_Var7 = p_Var4;
    if (__z->_M_left == (_Base_ptr)0x0) {
      _Var3 = __z->_M_color;
      __header->_M_right = __z->_M_parent;
    }
    else {
      do {
        p_Var2 = p_Var7;
        p_Var7 = p_Var2->_M_right;
      } while (p_Var7 != (_Base_ptr)0x0);
      _Var3 = __z->_M_color;
      __header->_M_right = p_Var2;
    }
  }
  else {
    _Var3 = __z->_M_color;
  }
LAB_10016ec2:
  if (_Var3 != _S_red) {
    if (p_Var4 != __header->_M_parent) {
      if (p_Var4 != (_Rb_tree_node_base *)0x0) goto LAB_10016f04;
      p_Var7 = p_Var6->_M_left;
      if (p_Var7 == (_Base_ptr)0x0) goto LAB_10016f16;
LAB_10016ed4:
      p_Var2 = p_Var7;
      if (p_Var7->_M_color == _S_red) {
        p_Var2 = p_Var7->_M_right;
        p_Var7->_M_color = _S_black;
        p_Var6->_M_left = p_Var2;
        p_Var6->_M_color = _S_red;
        if (p_Var2 != (_Base_ptr)0x0) {
          p_Var2->_M_parent = p_Var6;
        }
        p_Var8 = p_Var6->_M_parent;
        p_Var7->_M_parent = p_Var8;
        if (__header->_M_parent == p_Var6) {
          __header->_M_parent = p_Var7;
          p_Var2 = p_Var6->_M_left;
        }
        else if (p_Var8->_M_right == p_Var6) {
          p_Var8->_M_right = p_Var7;
        }
        else {
          p_Var8->_M_left = p_Var7;
          p_Var2 = p_Var6->_M_left;
        }
        p_Var7->_M_right = p_Var6;
        p_Var6->_M_parent = p_Var7;
      }
      p_Var8 = p_Var2->_M_right;
      if ((p_Var8 == (_Base_ptr)0x0) || (p_Var8->_M_color == _S_black)) goto LAB_10016ee6;
      p_Var9 = p_Var2->_M_left;
      if (p_Var9 != (_Base_ptr)0x0) goto LAB_10017066;
      goto LAB_100170da;
    }
LAB_10016f80:
    if (p_Var4 != (_Rb_tree_node_base *)0x0) {
LAB_1001702a:
      p_Var4->_M_color = _S_black;
      return __z;
    }
  }
  return __z;
LAB_10016ee6:
  p_Var9 = p_Var2->_M_left;
  if ((p_Var9 == (_Base_ptr)0x0) || (p_Var9->_M_color == _S_black)) {
LAB_10016ef8:
    p_Var4 = p_Var6;
    p_Var2->_M_color = _S_red;
    p_Var6 = p_Var4->_M_parent;
    if (__header->_M_parent == p_Var4) goto LAB_1001702a;
LAB_10016f04:
    if (p_Var4->_M_color != _S_black) goto LAB_1001702a;
    p_Var7 = p_Var6->_M_left;
    if (p_Var7 == p_Var4) {
LAB_10016f16:
      p_Var7 = p_Var6->_M_right;
      p_Var2 = p_Var7;
      if (p_Var7->_M_color == _S_red) {
        p_Var2 = p_Var7->_M_left;
        p_Var7->_M_color = _S_black;
        p_Var6->_M_right = p_Var2;
        p_Var6->_M_color = _S_red;
        if (p_Var2 != (_Base_ptr)0x0) {
          p_Var2->_M_parent = p_Var6;
        }
        p_Var8 = p_Var6->_M_parent;
        p_Var7->_M_parent = p_Var8;
        if (__header->_M_parent == p_Var6) {
          __header->_M_parent = p_Var7;
          p_Var2 = p_Var6->_M_right;
        }
        else if (p_Var8->_M_left == p_Var6) {
          p_Var8->_M_left = p_Var7;
        }
        else {
          p_Var8->_M_right = p_Var7;
          p_Var2 = p_Var6->_M_right;
        }
        p_Var7->_M_left = p_Var6;
        p_Var6->_M_parent = p_Var7;
      }
      p_Var8 = p_Var2->_M_left;
      if ((p_Var8 == (_Base_ptr)0x0) || (p_Var8->_M_color == _S_black)) goto LAB_10016f2a;
      p_Var9 = p_Var2->_M_right;
      if (p_Var9 != (_Base_ptr)0x0) goto LAB_10016f3c;
      goto LAB_1001713a;
    }
    goto LAB_10016ed4;
  }
LAB_10017066:
  if (p_Var9->_M_color == _S_black) {
LAB_100170da:
    p_Var9 = p_Var8->_M_left;
    p_Var8->_M_color = _S_black;
    p_Var2->_M_color = _S_red;
    p_Var2->_M_right = p_Var9;
    if (p_Var9 != (_Base_ptr)0x0) {
      p_Var9->_M_parent = p_Var2;
    }
    p_Var9 = p_Var2->_M_parent;
    p_Var8->_M_parent = p_Var9;
    if (p_Var2 == __header->_M_parent) {
      __header->_M_parent = p_Var8;
    }
    else if (p_Var2 == p_Var9->_M_left) {
      p_Var9->_M_left = p_Var8;
    }
    else {
      p_Var9->_M_right = p_Var8;
    }
    p_Var8->_M_left = p_Var2;
    p_Var11 = p_Var6->_M_left;
    _Var3 = p_Var6->_M_color;
    p_Var2->_M_parent = p_Var8;
    p_Var9 = p_Var11->_M_left;
    p_Var11->_M_color = _Var3;
    p_Var6->_M_color = _S_black;
    if (p_Var9 == (_Base_ptr)0x0) goto LAB_10017082;
  }
  else {
    p_Var11 = p_Var6->_M_left;
    p_Var2->_M_color = p_Var6->_M_color;
    p_Var6->_M_color = _S_black;
  }
  p_Var9->_M_color = _S_black;
LAB_10017082:
  p_Var8 = p_Var11->_M_right;
  p_Var6->_M_left = p_Var8;
  if (p_Var8 != (_Base_ptr)0x0) {
    p_Var8->_M_parent = p_Var6;
  }
  p_Var8 = p_Var6->_M_parent;
  p_Var11->_M_parent = p_Var8;
  if (__header->_M_parent == p_Var6) {
    __header->_M_parent = p_Var11;
  }
  else if (p_Var8->_M_right == p_Var6) {
    p_Var8->_M_right = p_Var11;
  }
  else {
    p_Var8->_M_left = p_Var11;
  }
  p_Var11->_M_right = p_Var6;
  p_Var6->_M_parent = p_Var11;
  if (p_Var4 == (_Rb_tree_node_base *)0x0) {
    return __z;
  }
  goto LAB_1001702a;
LAB_10016f2a:
  p_Var9 = p_Var2->_M_right;
  if ((p_Var9 == (_Base_ptr)0x0) || (p_Var9->_M_color == _S_black)) goto LAB_10016ef8;
LAB_10016f3c:
  if (p_Var9->_M_color == _S_black) {
LAB_1001713a:
    p_Var9 = p_Var8->_M_right;
    p_Var8->_M_color = _S_black;
    p_Var2->_M_color = _S_red;
    p_Var2->_M_left = p_Var9;
    if (p_Var9 != (_Base_ptr)0x0) {
      p_Var9->_M_parent = p_Var2;
    }
    p_Var9 = p_Var2->_M_parent;
    p_Var8->_M_parent = p_Var9;
    if (p_Var2 == __header->_M_parent) {
      __header->_M_parent = p_Var8;
    }
    else if (p_Var2 == p_Var9->_M_right) {
      p_Var9->_M_right = p_Var8;
    }
    else {
      p_Var9->_M_left = p_Var8;
    }
    p_Var8->_M_right = p_Var2;
    p_Var11 = p_Var6->_M_right;
    _Var3 = p_Var6->_M_color;
    p_Var2->_M_parent = p_Var8;
    p_Var9 = p_Var11->_M_right;
    p_Var11->_M_color = _Var3;
    p_Var6->_M_color = _S_black;
    if (p_Var9 == (_Base_ptr)0x0) goto LAB_10016f58;
  }
  else {
    p_Var11 = p_Var6->_M_right;
    p_Var2->_M_color = p_Var6->_M_color;
    p_Var6->_M_color = _S_black;
  }
  p_Var9->_M_color = _S_black;
LAB_10016f58:
  p_Var8 = p_Var11->_M_left;
  p_Var6->_M_right = p_Var8;
  if (p_Var8 != (_Base_ptr)0x0) {
    p_Var8->_M_parent = p_Var6;
  }
  p_Var8 = p_Var6->_M_parent;
  p_Var11->_M_parent = p_Var8;
  if (__header->_M_parent == p_Var6) {
    __header->_M_parent = p_Var11;
  }
  else if (p_Var8->_M_left == p_Var6) {
    p_Var8->_M_left = p_Var11;
  }
  else {
    p_Var8->_M_right = p_Var11;
  }
  p_Var11->_M_left = p_Var6;
  p_Var6->_M_parent = p_Var11;
  goto LAB_10016f80;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::__throw_bad_alloc()

void std::__throw_bad_alloc(void)

{
  gp = &__global_pointer_;
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// std::__throw_bad_array_new_length()

void std::__throw_bad_array_new_length(void)

{
  gp = &__global_pointer_;
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention
// DWARF original name: operator delete

void operator_delete(void *ptr)

{
  gp = &__global_pointer_;
  noInterrupts();
  free(ptr);
  interrupts();
  return;
}



// WARNING: Unknown calling convention

new_handler std::get_new_handler(void)

{
  new_handler handler;
  
  gp = &__global_pointer_;
  fence();
  return anon_unknown.dwarf_d4e00::__new_handler;
}



char * strncpy(char *__dest,char *__src,size_t __n)

{
  size_t sVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  uint *puVar5;
  
  gp = &__global_pointer_;
  puVar4 = (uint *)__dest;
  if (((((uint)__src | (uint)__dest) & 3) == 0) && (3 < __n)) {
    do {
      uVar2 = *(uint *)__src;
      if ((uVar2 + 0xfefefeff & ~uVar2 & 0x80808080) != 0) break;
      __n = __n - 4;
      *puVar4 = uVar2;
      puVar4 = puVar4 + 1;
      __src = (char *)((int)__src + 4);
    } while (3 < __n);
  }
  do {
    puVar3 = puVar4;
    sVar1 = __n;
    if (sVar1 == 0) {
      return __dest;
    }
    uVar2 = *(uint *)__src;
    *(char *)puVar3 = (char)uVar2;
    __src = (char *)((int)__src + 1);
    __n = sVar1 - 1;
    puVar4 = (uint *)((int)puVar3 + 1);
  } while ((char)uVar2 != '\0');
  if (sVar1 - 1 == 0) {
    return __dest;
  }
  do {
    puVar5 = (uint *)((int)puVar4 + 1);
    *(char *)puVar4 = '\0';
    puVar4 = puVar5;
  } while (puVar5 != (uint *)((int)puVar3 + sVar1));
  return __dest;
}



// WARNING: Unknown calling convention

void __assert_func(char *file,int line,char *func,char *failedexpr)

{
  _reent *p_Var1;
  char *pcVar2;
  
  gp = &__global_pointer_;
  p_Var1 = __wrap___getreent();
  if (func == (char *)0x0) {
    pcVar2 = "";
    func = "";
  }
  else {
    pcVar2 = ", function: ";
  }
  fiprintf(p_Var1->_stderr,"assertion \"%s\" failed: file \"%s\", line %d%s%s\n",failedexpr,file,
           line,pcVar2,func);
                    // WARNING: Subroutine does not return
  abort();
}



void __assert(char *__assertion,char *__file,int __line)

{
  gp = &__global_pointer_;
                    // WARNING: Subroutine does not return
  __assert_func(__assertion,(int)__file,(char *)0x0,(char *)__line);
}



// WARNING: Unknown calling convention

int _puts_r(_reent *ptr,char *s)

{
  FILE *fp;
  size_t sVar1;
  int iVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  undefined1 auStack_2c [4];
  __suio uio;
  __siov iov [2];
  
  gp = &__global_pointer_;
  sVar1 = strlen(s);
  uio.uio_iovcnt = sVar1 + 1;
  auStack_2c = (undefined1  [4])&uio.uio_resid;
  uio.uio_iov = (__siov *)0x2;
  fp = ptr->_stdout;
  uio.uio_resid = (size_t)s;
  if (ptr->__cleanup == (_func_void__reent_ptr *)0x0) {
    __sinit(ptr);
  }
  uVar5 = fp->_flags2;
  uVar3 = fp->_flags;
  uVar4 = (uint)(short)uVar3;
  if ((uVar5 & 1) == 0) {
    if ((uVar4 & 0x200) != 0) {
      if ((int)(uVar4 << 0x12) < 0) {
        if ((int)(uVar5 << 0x12) < 0) {
          uVar4 = 0xffffffff;
          goto LAB_10017326;
        }
        goto LAB_1001730a;
      }
LAB_100172fa:
      fp->_flags2 = uVar5 & 0xffffdfff;
      fp->_flags = uVar3 | 0x2000;
      goto LAB_1001730a;
    }
    __retarget_lock_acquire_recursive(&fp->_lock);
    uVar3 = fp->_flags;
    uVar5 = fp->_flags2;
    if (-1 < (int)(short)uVar3 << 0x12) goto LAB_100172fa;
    if (-1 < (int)(uVar5 << 0x12)) goto LAB_1001730a;
    uVar4 = 0xffffffff;
  }
  else {
    if (-1 < (int)(uVar4 << 0x12)) goto LAB_100172fa;
    if ((int)(uVar5 << 0x12) < 0) {
      gp = &__global_pointer_;
      return -1;
    }
LAB_1001730a:
    iVar2 = __sfvwrite_r(ptr,fp,(__suio *)auStack_2c);
    uVar5 = fp->_flags2;
    uVar4 = -(uint)(iVar2 != 0) | 10;
  }
  if ((uVar5 & 1) != 0) {
    gp = &__global_pointer_;
    return uVar4;
  }
LAB_10017326:
  if ((fp->_flags & 0x200U) != 0) {
    return uVar4;
  }
  __retarget_lock_release_recursive(&fp->_lock);
  return uVar4;
}



int puts(char *__s)

{
  _reent *ptr;
  int iVar1;
  
  gp = &__global_pointer_;
  ptr = __wrap___getreent();
  iVar1 = _puts_r(ptr,__s);
  return iVar1;
}



int strcmp(char *__s1,char *__s2)

{
  uint uVar1;
  uint uVar2;
  
  gp = &__global_pointer_;
  if ((((uint)__s1 | (uint)__s2) & 3) == 0) {
    do {
      uVar1 = *(uint *)__s1;
      uVar2 = *(uint *)__s2;
      if (((uVar1 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar1 | 0x7f7f7f7f) != 0xffffffff) {
LAB_100174a8:
        if (uVar1 == uVar2) {
          return 0;
        }
        goto LAB_1001748c;
      }
      if (uVar1 != uVar2) break;
      uVar1 = *(uint *)((int)__s1 + 4);
      uVar2 = *(uint *)((int)__s2 + 4);
      if (((uVar1 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar1 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 4);
        __s2 = (char *)((int)__s2 + 4);
        goto LAB_100174a8;
      }
      if (uVar1 != uVar2) break;
      uVar1 = *(uint *)((int)__s1 + 8);
      uVar2 = *(uint *)((int)__s2 + 8);
      if (((uVar1 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar1 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 8);
        __s2 = (char *)((int)__s2 + 8);
        if (uVar1 == uVar2) {
          return 0;
        }
        goto LAB_1001748c;
      }
      if (uVar1 != uVar2) break;
      uVar1 = *(uint *)((int)__s1 + 0xc);
      uVar2 = *(uint *)((int)__s2 + 0xc);
      if (((uVar1 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar1 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 0xc);
        __s2 = (char *)((int)__s2 + 0xc);
        if (uVar1 == uVar2) {
          return 0;
        }
        goto LAB_1001748c;
      }
      if (uVar1 != uVar2) break;
      uVar1 = *(uint *)((int)__s1 + 0x10);
      uVar2 = *(uint *)((int)__s2 + 0x10);
      if (((uVar1 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar1 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 0x10);
        __s2 = (char *)((int)__s2 + 0x10);
        if (uVar1 == uVar2) {
          return 0;
        }
        goto LAB_1001748c;
      }
      __s1 = (char *)((int)__s1 + 0x14);
      __s2 = (char *)((int)__s2 + 0x14);
    } while (uVar1 == uVar2);
    if (uVar1 << 0x10 == uVar2 << 0x10) {
      uVar1 = uVar1 >> 0x10;
      uVar2 = uVar2 >> 0x10;
      if ((uVar1 - uVar2 & 0xff) == 0) {
        return uVar1 - uVar2;
      }
    }
    else {
      uVar1 = uVar1 & 0xffff;
      uVar2 = uVar2 & 0xffff;
      if ((uVar1 - uVar2 & 0xff) == 0) {
        return uVar1 - uVar2;
      }
    }
    return (uVar1 & 0xff) - (uVar2 & 0xff);
  }
LAB_1001748c:
  do {
    uVar2 = (uint)(byte)*(uint *)__s1;
    uVar1 = *(uint *)__s2;
    __s1 = (char *)((int)__s1 + 1);
    __s2 = (char *)((int)__s2 + 1);
    if (uVar2 != (byte)uVar1) break;
  } while (uVar2 != 0);
  return uVar2 - (byte)uVar1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int _svfprintf_r(_reent *data,FILE *fp,char *fmt0,va_list ap)

{
  bool bVar1;
  undefined1 a [16];
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  undefined1 uVar9;
  uint uVar10;
  size_t *psVar11;
  size_t *psVar12;
  lconv *plVar13;
  size_t sVar14;
  void *pvVar15;
  __gcc_CMPtype _Var16;
  int *extraout_a0;
  char *pcVar17;
  uchar *puVar18;
  int iVar19;
  byte bVar20;
  uint extraout_a1;
  undefined1 *puVar21;
  byte bVar22;
  size_t *psVar23;
  uint uVar24;
  __siov *p_Var25;
  undefined1 *puVar26;
  byte bVar27;
  char cVar28;
  undefined1 *puVar29;
  char *__s;
  uint uVar30;
  int *piVar31;
  uint uVar32;
  uint *puVar33;
  undefined1 *puVar34;
  int iVar35;
  byte *pbVar36;
  byte *pbVar37;
  uint uVar38;
  size_t *psVar39;
  byte *pbVar40;
  byte *pbVar41;
  undefined4 *puVar42;
  size_t *psVar43;
  byte *pbVar44;
  uint uVar45;
  byte *pbVar46;
  int iStack_214;
  size_t *psStack_210;
  uint *puStack_20c;
  int iStack_208;
  byte *pbStack_200;
  int iStack_1fc;
  uint uStack_1f8;
  int *piStack_1f4;
  byte *pbStack_1e4;
  char *pcStack_1dc;
  char *pcStack_1d0;
  int iStack_1cc;
  size_t sStack_1c8;
  char cStack_10d;
  undefined2 uStack_10c;
  char sign;
  char ox [2];
  int expt;
  int dsgn;
  char expstr [7];
  char *rve;
  undefined1 auStack_f0 [4];
  __suio uio;
  __siov iov [8];
  char buf [100];
  
  gp = &__global_pointer_;
  plVar13 = _localeconv_r(data);
  __s = plVar13->decimal_point;
  sVar14 = strlen(__s);
  if (((fp->_flags & 0x80U) != 0) && ((fp->_bf)._base == (uchar *)0x0)) {
    puVar18 = (uchar *)_malloc_r(data,0x40);
    fp->_p = puVar18;
    (fp->_bf)._base = puVar18;
    if (puVar18 == (uchar *)0x0) {
      data->_errno = 0xc;
      return -1;
    }
    (fp->_bf)._size = 0x40;
  }
  psVar11 = &uio.uio_resid;
  uio.uio_iovcnt = 0;
  uio.uio_iov = (__siov *)0x0;
  bVar27 = *fmt0;
  pbStack_200 = (byte *)0x0;
  pcStack_1dc = (char *)0x0;
  pbStack_1e4 = (byte *)0x0;
  sStack_1c8 = 0;
  pcStack_1d0 = (char *)0x0;
  iStack_214 = 0;
  auStack_f0 = (undefined1  [4])psVar11;
  puStack_20c = (uint *)ap;
joined_r0x10017566:
  psVar12 = (size_t *)fmt0;
  if (bVar27 != 0) {
    do {
      if (bVar27 == 0x25) {
        iVar35 = (int)psVar12 - (int)fmt0;
        if (psVar12 != (size_t *)fmt0) goto LAB_10017580;
        bVar27 = (byte)*psVar12;
        goto LAB_100175ae;
      }
      bVar27 = *(byte *)((int)psVar12 + 1);
      psVar12 = (size_t *)((int)psVar12 + 1);
    } while (bVar27 != 0);
    iVar35 = (int)psVar12 - (int)fmt0;
    if (psVar12 != (size_t *)fmt0) {
LAB_10017580:
      *psVar11 = (size_t)fmt0;
      *(int *)((int)psVar11 + 4) = iVar35;
      uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
      uio.uio_iov = (__siov *)((int)uio.uio_iov + 1);
      psVar11 = (size_t *)((int)psVar11 + 8);
      if (7 < (int)uio.uio_iov) {
        iVar19 = __ssprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar19 != 0) goto LAB_1001770a;
        psVar11 = &uio.uio_resid;
      }
      bVar27 = (byte)*psVar12;
      iStack_214 = iStack_214 + iVar35;
LAB_100175ae:
      if (bVar27 != 0) {
        uVar10 = (uint)*(byte *)((int)psVar12 + 1);
        cStack_10d = '\0';
        pbVar36 = (byte *)0xffffffff;
        bVar27 = 0;
        bVar8 = false;
        bVar7 = false;
        bVar6 = false;
        bVar5 = false;
        bVar4 = false;
        bVar3 = false;
        bVar2 = false;
        bVar1 = false;
        pbVar40 = (byte *)0x0;
        psVar12 = (size_t *)((int)psVar12 + 1);
LAB_100175ca:
        psVar12 = (size_t *)((int)psVar12 + 1);
code_r0x100175d0:
        uVar9 = (undefined1)uVar10;
        pbVar44 = pbVar36;
        bVar22 = bVar27;
        pbVar37 = pbVar36;
        switch(uVar10) {
        case 0x20:
          goto switchD_100175e2_caseD_20;
        default:
          if (uVar10 == 0) goto LAB_10017700;
LAB_1001761e:
          iov[7].iov_len._0_1_ = uVar9;
          cStack_10d = '\0';
          psStack_210 = (size_t *)0x0;
          iStack_1fc = 0;
          iStack_208 = 0;
          pbVar41 = (byte *)0x0;
          fmt0 = (char *)&iov[7].iov_len;
          pbVar37 = (byte *)0x0;
          pbVar44 = &DAT_00000001;
          pbVar46 = &DAT_00000001;
          goto joined_r0x10017a3c;
        case 0x23:
          uVar10 = (uint)(byte)*psVar12;
          bVar8 = true;
          goto LAB_100175ca;
        case 0x27:
          plVar13 = _localeconv_r(data);
          pcStack_1d0 = plVar13->thousands_sep;
          sStack_1c8 = strlen(pcStack_1d0);
          plVar13 = _localeconv_r(data);
          pbStack_1e4 = (byte *)plVar13->grouping;
          uVar10 = (uint)(byte)*psVar12;
          if (((sStack_1c8 != 0) && (pbStack_1e4 != (byte *)0x0)) && (*pbStack_1e4 != 0)) {
            bVar6 = true;
          }
          goto LAB_100175ca;
        case 0x2a:
          pbVar40 = (byte *)*puStack_20c;
          puStack_20c = puStack_20c + 1;
          if ((int)pbVar40 < 0) {
            pbVar40 = (byte *)-(int)pbVar40;
            goto switchD_100175e2_caseD_2d;
          }
          uVar10 = (uint)(byte)*psVar12;
          goto LAB_100175ca;
        case 0x2b:
          cStack_10d = '+';
          uVar10 = (uint)(byte)*psVar12;
          goto LAB_100175ca;
        case 0x2d:
switchD_100175e2_caseD_2d:
          uVar10 = (uint)(byte)*psVar12;
          bVar27 = bVar27 | 4;
          goto LAB_100175ca;
        case 0x2e:
          uVar10 = (uint)(byte)*psVar12;
          psVar43 = (size_t *)((int)psVar12 + 1);
          if (uVar10 == 0x2a) {
            pbVar36 = (byte *)*puStack_20c;
            puStack_20c = puStack_20c + 1;
            if ((int)pbVar36 < 0) {
              pbVar36 = (byte *)0xffffffff;
            }
            uVar10 = (uint)*(byte *)((int)psVar12 + 1);
            psVar12 = psVar43;
            goto LAB_100175ca;
          }
          uVar38 = uVar10 - 0x30;
          pbVar36 = (byte *)0x0;
          psVar12 = psVar43;
          if (uVar38 < 10) {
            do {
              uVar10 = (uint)(byte)*psVar43;
              pbVar36 = (byte *)((int)pbVar36 * 10 + uVar38);
              uVar38 = uVar10 - 0x30;
              psVar43 = (size_t *)((int)psVar43 + 1);
            } while (uVar38 < 10);
            psVar12 = psVar43;
            if ((int)pbVar36 < 0) {
              pbVar36 = (byte *)0xffffffff;
            }
          }
          goto code_r0x100175d0;
        case 0x30:
          uVar10 = (uint)(byte)*psVar12;
          bVar27 = bVar27 | 0x80;
          goto LAB_100175ca;
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
          goto switchD_100175e2_caseD_31;
        case 0x41:
        case 0x45:
        case 0x46:
        case 0x47:
        case 0x61:
        case 0x65:
        case 0x66:
        case 0x67:
          if (bVar2) {
            puStack_20c = puStack_20c + 1;
            a._8_8_ = DRam00000018;
            a._0_8_ = dRam00000010;
            __trunctfdf2((TFtype)a);
            uStack_1f8 = extraout_a1;
            piStack_1f4 = extraout_a0;
          }
          else {
            puVar42 = (undefined4 *)((int)puStack_20c + 7U & 0xfffffff8);
            piStack_1f4 = (int *)*puVar42;
            uStack_1f8 = puVar42[1];
            puStack_20c = puVar42 + 2;
          }
          _Var16 = __unorddf2(dRam00000010,DRam00000018);
          if ((_Var16 == 0) && (_Var16 = __ledf2(dRam00000010,DRam00000018), 0 < _Var16)) {
            _Var16 = __ledf2(dRam00000010,DRam00000018);
            if (_Var16 < 0) {
              cStack_10d = '-';
              if (uVar10 < 0x48) {
                fmt0 = &UNK_10022528;
              }
              else {
                fmt0 = &UNK_1002252c;
              }
            }
            else {
              if (uVar10 < 0x48) {
                fmt0 = &UNK_10022528;
              }
              else {
                fmt0 = &UNK_1002252c;
              }
              if (cStack_10d == '\0') {
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x3;
                bVar27 = bVar27 & 0x7f;
                goto LAB_10017a28;
              }
            }
          }
          else {
            _Var16 = __unorddf2(dRam00000010,DRam00000018);
            if (_Var16 == 0) {
              if (uVar10 == 0x61) {
                uStack_10c = 0x7830;
                bVar22 = bVar27 | 2;
                if (99 < (int)pbVar36) {
LAB_10019548:
                  bVar27 = bVar27 | 2;
                  fmt0 = (char *)_malloc_r(data,(size_t)(pbVar36 + 1));
                  psStack_210 = (size_t *)fmt0;
                  if ((size_t *)fmt0 != (size_t *)0x0) goto LAB_10018a88;
                  fp->_flags = fp->_flags | 0x40;
                  goto LAB_1001770a;
                }
                if ((int)uStack_1f8 < 0) goto LAB_10019586;
                frexp(dRam00000010,piStack_1f4);
                __muldf3(dRam00000010,DRam00000018);
                _Var16 = __eqdf2(dRam00000010,DRam00000018);
                if (_Var16 != 0) {
                  pcVar17 = "0123456789abcdef";
                  iStack_1cc = 0;
                  psStack_210 = (size_t *)0x0;
                  fmt0 = (char *)&iov[7].iov_len;
                  psVar43 = (size_t *)fmt0;
                  bVar27 = bVar22;
                  goto LAB_1001921c;
                }
                _ox = &DAT_00000001;
                iStack_1cc = 0;
                psStack_210 = (size_t *)0x0;
                fmt0 = (char *)&iov[7].iov_len;
              }
              else {
                if (uVar10 != 0x41) {
                  if (pbVar36 == (byte *)0xffffffff) {
                    psStack_210 = (size_t *)0x0;
                    pbVar36 = (byte *)0x6;
LAB_10018a88:
                    iStack_1cc = 0;
                    if ((int)uStack_1f8 < 0) {
                      uStack_1f8 = uStack_1f8 ^ 0x80000000;
                      iStack_1cc = 0x2d;
                    }
                    switch(uVar10) {
                    case 0x41:
                    case 0x61:
                      goto switchD_10018ab8_caseD_41;
                    default:
                      fmt0 = _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,(int *)0x2,
                                     (int *)pbVar36,(char **)ox);
                      goto LAB_10018eb6;
                    case 0x45:
                    case 0x65:
                      pbStack_200 = pbVar36 + 1;
                      piVar31 = (int *)0x2;
                      break;
                    case 0x46:
                    case 0x66:
                      piVar31 = (int *)0x3;
                      pbStack_200 = pbVar36;
                    }
                    fmt0 = _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,piVar31,
                                   (int *)pbStack_200,(char **)ox);
                    pbVar44 = (byte *)((int)fmt0 + (int)pbStack_200);
                    if ((uVar10 & 0xffffffdf) != 0x46) {
                      _Var16 = __eqdf2(dRam00000010,DRam00000018);
                      if (_Var16 == 0) goto LAB_10018fee;
                      iVar35 = 0x45;
                      if (stack0xffffff08 < pbVar44) goto LAB_10018fc0;
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)fmt0);
                      goto LAB_10018fee;
                    }
                    iVar35 = 0x46;
                    if ((byte)*(size_t *)fmt0 != 0x30) {
LAB_100190f4:
                      pbVar44 = pbVar44 + (int)_ox;
                      goto LAB_100190f6;
                    }
                    _Var16 = __eqdf2(dRam00000010,DRam00000018);
                    if (_Var16 != 0) {
                      _ox = (byte *)(1 - (int)pbStack_200);
                      goto LAB_100190f4;
                    }
                    pbVar44 = pbVar44 + (int)_ox;
                  }
                  else {
                    if (uVar10 == 0x67) {
                      if (pbVar36 == (byte *)0x0) {
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                          pbVar36 = &DAT_00000001;
                        }
                        else {
                          iStack_1cc = 0;
                          pbVar36 = &DAT_00000001;
                        }
                      }
                      else {
                        iStack_1cc = 0;
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                        }
                      }
                    }
                    else {
                      psStack_210 = (size_t *)0x0;
                      if (uVar10 != 0x47) goto LAB_10018a88;
                      if (pbVar36 == (byte *)0x0) {
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                          pbVar36 = &DAT_00000001;
                        }
                        else {
                          iStack_1cc = 0;
                          pbVar36 = &DAT_00000001;
                        }
                      }
                      else {
                        iStack_1cc = 0;
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                        }
                      }
                    }
                    fmt0 = _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,(int *)0x2,
                                   (int *)pbVar36,(char **)ox);
                    psStack_210 = (size_t *)0x0;
LAB_10018eb6:
                    if (!bVar8) {
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)fmt0);
                      if ((int)_ox < -3) goto LAB_1001942c;
                      if ((int)pbVar36 < (int)_ox) goto LAB_100190aa;
                      pbVar46 = _ox;
                      if ((int)pbStack_200 <= (int)_ox) goto LAB_10018edc;
                      goto LAB_10019520;
                    }
                    pbVar44 = (byte *)((int)fmt0 + (int)pbVar36);
                    iVar35 = 0x47;
LAB_100190f6:
                    _Var16 = __eqdf2(dRam00000010,DRam00000018);
                    if (_Var16 != 0) {
                      if (stack0xffffff08 < pbVar44) goto LAB_10018fc0;
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)fmt0);
                      if (iVar35 == 0x47) goto LAB_100190a0;
                      goto LAB_10019138;
                    }
                  }
                  pbStack_200 = pbVar44 + -(int)fmt0;
                  if (iVar35 != 0x47) goto LAB_10019138;
                  goto LAB_100190a0;
                }
                uStack_10c = 0x5830;
                if (99 < (int)pbVar36) goto LAB_10019548;
                if (-1 < (int)uStack_1f8) {
                  frexp(dRam00000010,piStack_1f4);
                  __muldf3(dRam00000010,DRam00000018);
                  _Var16 = __eqdf2(dRam00000010,DRam00000018);
                  if (_Var16 == 0) {
                    _ox = &DAT_00000001;
                  }
                  pcVar17 = "0123456789ABCDEF";
                  iStack_1cc = 0;
                  psStack_210 = (size_t *)0x0;
                  fmt0 = (char *)&iov[7].iov_len;
                  psVar43 = (size_t *)fmt0;
                  bVar27 = bVar27 | 2;
                  goto LAB_1001921c;
                }
LAB_10019586:
                bVar27 = bVar27 | 2;
                psStack_210 = (size_t *)0x0;
                fmt0 = (char *)&iov[7].iov_len;
                iStack_1cc = 0x2d;
switchD_10018ab8_caseD_41:
                frexp(dRam00000010,piStack_1f4);
                __muldf3(dRam00000010,DRam00000018);
                _Var16 = __eqdf2(dRam00000010,DRam00000018);
                if (_Var16 == 0) {
                  _ox = &DAT_00000001;
                }
                bVar22 = bVar27;
                if (uVar10 != 0x61) {
                  pcVar17 = "0123456789ABCDEF";
                  psVar43 = (size_t *)fmt0;
                  goto LAB_1001921c;
                }
              }
              pcVar17 = "0123456789abcdef";
              psVar43 = (size_t *)fmt0;
              bVar27 = bVar22;
              goto LAB_1001921c;
            }
            bVar1 = false;
            if ((uStack_1f8 & 0x80000000) == 0) {
              if (uVar10 < 0x48) {
                fmt0 = &UNK_10022530;
              }
              else {
                fmt0 = &UNK_10022534;
              }
              pbVar41 = (byte *)0x0;
              if (cStack_10d == '\0') {
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x3;
                iStack_1fc = 0;
                iStack_208 = 0;
                psStack_210 = (size_t *)0x0;
                pbVar37 = (byte *)0x0;
                bVar27 = bVar27 & 0x7f;
              }
              else {
                iStack_1fc = 0;
                iStack_208 = 0;
                psStack_210 = (size_t *)0x0;
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x4;
                pbVar37 = (byte *)0x0;
                bVar27 = bVar27 & 0x7f;
              }
              goto joined_r0x10017a3c;
            }
            cStack_10d = '-';
            if (uVar10 < 0x48) {
              fmt0 = &UNK_10022530;
            }
            else {
              fmt0 = &UNK_10022534;
            }
          }
          bVar1 = false;
          psStack_210 = (size_t *)0x0;
          pbVar46 = (byte *)0x3;
          iStack_1fc = 0;
          iStack_208 = 0;
          pbVar41 = (byte *)0x0;
          pbVar44 = (byte *)0x4;
          pbVar37 = (byte *)0x0;
          bVar27 = bVar27 & 0x7f;
          goto joined_r0x10017a3c;
        case 0x43:
        case 99:
          uVar38 = *puStack_20c;
          puStack_20c = puStack_20c + 1;
          uVar9 = (char)uVar38;
          goto LAB_1001761e;
        case 0x44:
          if (!bVar3) {
LAB_100184f8:
            uVar38 = *puStack_20c;
            uVar24 = (int)uVar38 >> 0x1f;
            goto LAB_10017c30;
          }
LAB_10017cb4:
          puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
          uVar24 = puVar33[1];
          puStack_20c = puVar33 + 2;
          uVar38 = *puVar33;
          if (-1 < (int)uVar24) goto LAB_10017c34;
LAB_10017cca:
          cStack_10d = '-';
          uVar24 = -(uint)(uVar38 != 0) - uVar24;
          uVar38 = -uVar38;
          if (-1 < (int)pbVar36) {
            bVar22 = bVar27 & 0x7f;
          }
joined_r0x10017c44:
          bVar27 = bVar22;
          puVar33 = puStack_20c;
          if (uVar24 == 0) {
LAB_10017c48:
            puStack_20c = puVar33;
            if (uVar38 < 10) goto LAB_10017c4e;
          }
          pbStack_200 = (byte *)0x0;
          fmt0 = buf + 0x60;
          goto LAB_10017d68;
        case 0x4c:
          uVar10 = (uint)(byte)*psVar12;
          bVar2 = true;
          goto LAB_100175ca;
        case 0x4f:
          if (bVar3) {
LAB_10017f3e:
            puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
            puStack_20c = puVar33 + 2;
            uVar24 = puVar33[1];
            uVar38 = *puVar33;
          }
          else {
LAB_100184b0:
            uVar24 = 0;
            uVar38 = *puStack_20c;
            puStack_20c = puStack_20c + 1;
          }
          goto LAB_10017f4e;
        case 0x53:
        case 0x73:
          cStack_10d = '\0';
          fmt0 = (char *)*puStack_20c;
          puStack_20c = puStack_20c + 1;
          if ((size_t *)fmt0 == (size_t *)0x0) {
            if ((byte *)0x6 < pbVar36) {
              pbVar36 = (byte *)0x6;
            }
            fmt0 = &UNK_10022560;
            psStack_210 = (size_t *)0x0;
            iStack_1fc = 0;
            iStack_208 = 0;
            pbVar41 = (byte *)0x0;
            pbVar37 = (byte *)0x0;
            pbVar44 = pbVar36;
            pbVar46 = pbVar36;
            goto joined_r0x10017a3c;
          }
          if ((int)pbVar36 < 0) {
            pbVar46 = (byte *)strlen(fmt0);
            pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          }
          else {
            pvVar15 = memchr(fmt0,0,(size_t)pbVar36);
            if (pvVar15 == (void *)0x0) {
              psStack_210 = (size_t *)0x0;
              pbVar46 = pbVar36;
              if (cStack_10d == '\0') {
                iStack_1fc = 0;
                iStack_208 = 0;
                pbVar41 = (byte *)0x0;
                pbVar37 = (byte *)0x0;
              }
              else {
                iStack_1fc = 0;
                iStack_208 = 0;
                pbVar41 = (byte *)0x0;
                pbVar37 = (byte *)0x0;
                pbVar44 = pbVar36 + 1;
              }
              goto joined_r0x10017a3c;
            }
            pbVar46 = (byte *)((int)pvVar15 - (int)fmt0);
            pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          }
          if (cStack_10d != '\0') {
            pbVar44 = pbVar44 + 1;
          }
LAB_10017a28:
          bVar1 = false;
          psStack_210 = (size_t *)0x0;
          iStack_1fc = 0;
          iStack_208 = 0;
          pbVar41 = (byte *)0x0;
          pbVar37 = (byte *)0x0;
          goto joined_r0x10017a3c;
        case 0x55:
          if (!bVar3) {
LAB_10017fea:
            cStack_10d = '\0';
            uVar24 = 0;
            uVar38 = *puStack_20c;
            puVar33 = puStack_20c + 1;
            if (-1 < (int)pbVar36) {
joined_r0x100184e8:
              bVar22 = bVar27 & 0x7f;
              if (uVar38 != 0) goto LAB_10018000;
              puStack_20c = puStack_20c + 1;
              goto joined_r0x100184ee;
            }
            goto LAB_10017c48;
          }
LAB_10018010:
          cStack_10d = '\0';
          puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
          puStack_20c = puVar33 + 2;
          uVar38 = *puVar33;
          uVar24 = puVar33[1];
          if (((int)pbVar36 < 0) || (bVar22 = bVar27 & 0x7f, uVar38 != 0 || uVar24 != 0))
          goto joined_r0x10017c44;
joined_r0x100184ee:
          if (pbVar36 == (byte *)0x0) {
            bVar1 = false;
            cStack_10d = '\0';
            iStack_1fc = 0;
            iStack_208 = 0;
            pbVar41 = (byte *)0x0;
            psStack_210 = (size_t *)0x0;
            fmt0 = buf + 0x60;
            pbVar44 = (byte *)0x0;
            pbVar46 = (byte *)0x0;
            bVar27 = bVar27 & 0x7f;
            goto joined_r0x10017a3c;
          }
LAB_1001803c:
          bVar27 = bVar27 & 0x7f;
          cStack_10d = '\0';
          uVar38 = 0;
LAB_10017c4e:
          buf[0x5f] = (char)uVar38 + '0';
          bVar22 = bVar27;
LAB_10017c56:
          pbVar44 = pbVar36;
          if ((int)pbVar36 < 1) {
            pbVar44 = &DAT_00000001;
          }
          bVar20 = 0;
          pbVar46 = &DAT_00000001;
          fmt0 = buf + 0x5f;
          goto LAB_10017c6e;
        case 0x58:
          pcVar17 = "0123456789ABCDEF";
          goto LAB_100185ce;
        case 100:
        case 0x69:
          if (bVar3) goto LAB_10017cb4;
          uVar38 = *puStack_20c;
          if (bVar4) goto LAB_100184f8;
          if (bVar5) {
            uVar38 = (uint)(short)uVar38;
            uVar24 = (int)uVar38 >> 0x1f;
          }
          else if (bVar7) {
            uVar38 = (uint)(char)uVar38;
            uVar24 = (int)uVar38 >> 0x1f;
          }
          else {
            uVar24 = (int)uVar38 >> 0x1f;
          }
LAB_10017c30:
          puStack_20c = puStack_20c + 1;
          if ((int)uVar24 < 0) goto LAB_10017cca;
LAB_10017c34:
          if (((int)pbVar36 < 0) || (bVar22 = bVar27 & 0x7f, uVar38 != 0 || uVar24 != 0))
          goto joined_r0x10017c44;
          if (pbVar36 != (byte *)0x0) {
            buf[0x5f] = '0';
            goto LAB_10017c56;
          }
          goto LAB_100188b4;
        case 0x68:
          uVar10 = (uint)(byte)*psVar12;
          if (uVar10 == 0x68) {
            uVar10 = (uint)*(byte *)((int)psVar12 + 1);
            bVar7 = true;
            psVar12 = (size_t *)((int)psVar12 + 1);
          }
          else {
            bVar5 = true;
          }
          goto LAB_100175ca;
        case 0x6a:
        case 0x71:
          uVar10 = (uint)(byte)*psVar12;
          bVar3 = true;
          goto LAB_100175ca;
        case 0x6c:
          goto switchD_100175e2_caseD_6c;
        case 0x6e:
          puVar33 = puStack_20c + 1;
          if (bVar3) {
            piVar31 = (int *)*puStack_20c;
            *piVar31 = iStack_214;
            piVar31[1] = iStack_214 >> 0x1f;
            puStack_20c = puVar33;
            goto LAB_100176f8;
          }
          if (!bVar4) {
            if (bVar5) {
              *(short *)*puStack_20c = (short)iStack_214;
              puStack_20c = puVar33;
              goto LAB_100176f8;
            }
            if (bVar7) {
              *(char *)*puStack_20c = (char)iStack_214;
              puStack_20c = puVar33;
              goto LAB_100176f8;
            }
          }
          *(int *)*puStack_20c = iStack_214;
          puStack_20c = puVar33;
          goto LAB_100176f8;
        case 0x6f:
          if (bVar3) goto LAB_10017f3e;
          puVar33 = puStack_20c + 1;
          uVar38 = *puStack_20c;
          if (bVar4) goto LAB_100184b0;
          puStack_20c = puVar33;
          if (bVar5) {
            uVar38 = uVar38 & 0xffff;
            uVar24 = 0;
          }
          else if (bVar7) {
            uVar38 = uVar38 & 0xff;
            uVar24 = 0;
          }
          else {
            uVar24 = 0;
          }
LAB_10017f4e:
          cStack_10d = '\0';
          if (-1 < (int)pbVar36) {
            bVar22 = bVar27 & 0x7f;
            bVar6 = false;
            bVar1 = false;
            if ((uVar38 == 0 && uVar24 == 0) && (pbVar36 == (byte *)0x0)) {
              pbVar44 = (byte *)(uint)bVar8;
              if (pbVar44 == (byte *)0x0) {
LAB_10018940:
                bVar1 = false;
                cStack_10d = '\0';
                iStack_1fc = 0;
                iStack_208 = 0;
                pbVar41 = (byte *)0x0;
                psStack_210 = (size_t *)0x0;
                fmt0 = buf + 0x60;
                pbVar46 = (byte *)0x0;
                bVar27 = bVar27 & 0x7f;
              }
              else {
                buf[0x5f] = '0';
                iStack_1fc = 0;
                iStack_208 = 0;
                pbVar41 = (byte *)0x0;
                psStack_210 = (size_t *)0x0;
                fmt0 = buf + 0x5f;
                pbVar46 = pbVar44;
                bVar27 = bVar22;
              }
              goto joined_r0x10017a3c;
            }
          }
          bVar6 = false;
          fmt0 = buf + 0x60;
          do {
            psVar43 = (size_t *)fmt0;
            iVar35 = (uVar38 & 7) + 0x30;
            uVar38 = uVar38 >> 3 | uVar24 << 0x1d;
            uVar24 = uVar24 >> 3;
            *(byte *)((int)psVar43 + -1) = (byte)iVar35;
            fmt0 = (char *)((int)psVar43 + -1);
          } while (uVar38 != 0 || uVar24 != 0);
          bVar20 = bVar8;
          if (bVar8 != false) {
            if (iVar35 == 0x30) goto LAB_10018416;
            fmt0 = (char *)((int)psVar43 + -2);
            *(byte *)((int)psVar43 + -2) = 0x30;
            pbVar46 = (byte *)(buf + (0x60 - (int)fmt0));
            if ((int)pbVar36 < (int)pbVar46) {
              pbVar44 = pbVar46;
            }
            goto LAB_10017fd2;
          }
LAB_100180ee:
          cStack_10d = '\0';
          pbVar46 = (byte *)(buf + (0x60 - (int)fmt0));
          if ((int)pbVar36 < (int)pbVar46) {
            pbVar44 = pbVar46;
          }
          goto LAB_10017c6e;
        case 0x70:
          uStack_10c = 0x7830;
          cStack_10d = '\0';
          uVar24 = *puStack_20c;
          puStack_20c = puStack_20c + 1;
          uVar38 = 0;
          if ((int)pbVar36 < 0) {
            buf[0x5f] = "0123456789abcdef"[uVar24 & 0xf];
            pcVar17 = "0123456789abcdef";
            bVar20 = 2;
            uVar10 = 0x78;
            break;
          }
          bVar27 = bVar27 & 0x7f;
          bVar1 = false;
          if (uVar24 == 0) {
            if (pbVar36 == (byte *)0x0) {
              iStack_1fc = 0;
              iStack_208 = 0;
              pbVar41 = (byte *)0x0;
              pbVar46 = (byte *)0x0;
              pbVar44 = (byte *)0x0;
              uVar10 = 0x78;
              fmt0 = buf + 0x60;
              psStack_210 = (size_t *)0x0;
              goto LAB_10017c7e;
            }
            buf[0x5f] = '0';
            uVar10 = 0x78;
            fmt0 = buf + 0x5f;
            bVar20 = 2;
            bVar22 = bVar27;
            goto LAB_100180ee;
          }
          buf[0x5f] = "0123456789abcdef"[uVar24 & 0xf];
          pcVar17 = "0123456789abcdef";
          bVar20 = 2;
          uVar10 = 0x78;
          break;
        case 0x74:
        case 0x7a:
          goto switchD_100175e2_caseD_74;
        case 0x75:
          if (bVar3) goto LAB_10018010;
          puVar33 = puStack_20c + 1;
          uVar38 = *puStack_20c;
          if (bVar4) goto LAB_10017fea;
          if (bVar5) {
            uVar38 = uVar38 & 0xffff;
joined_r0x100184e0:
            if (-1 < (int)pbVar36) goto joined_r0x100184e8;
LAB_10018000:
            cStack_10d = '\0';
            uVar24 = 0;
            puVar33 = puStack_20c + 1;
            bVar27 = bVar22;
            goto LAB_10017c48;
          }
          if (bVar7) {
            uVar38 = uVar38 & 0xff;
            goto joined_r0x100184e0;
          }
          pbVar44 = (byte *)0x0;
          if (((int)pbVar36 < 0) || (bVar22 = bVar27 & 0x7f, uVar38 != 0)) goto LAB_10018000;
          puStack_20c = puVar33;
          if (pbVar36 != (byte *)0x0) goto LAB_1001803c;
          goto LAB_10018940;
        case 0x78:
          pcVar17 = "0123456789abcdef";
LAB_100185ce:
          if (bVar3) {
            puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
            uVar24 = *puVar33;
            uVar38 = puVar33[1];
            puVar33 = puVar33 + 2;
          }
          else {
            puVar33 = puStack_20c + 1;
            uVar24 = *puStack_20c;
            if (bVar4) {
LAB_10018900:
              uVar38 = 0;
            }
            else if (bVar5) {
              uVar24 = uVar24 & 0xffff;
              uVar38 = 0;
            }
            else {
              if (!bVar7) goto LAB_10018900;
              uVar24 = uVar24 & 0xff;
              uVar38 = 0;
            }
          }
          puStack_20c = puVar33;
          if (bVar8) {
            if (uVar24 == 0 && uVar38 == 0) {
              if ((int)pbVar36 < 0) {
                buf[0x5f] = *pcVar17;
                bVar6 = false;
                fmt0 = buf + 0x5f;
                bVar20 = 0;
                goto LAB_100180ee;
              }
LAB_100188ae:
              cStack_10d = '\0';
              bVar6 = false;
              if (pbVar36 == (byte *)0x0) {
LAB_100188b4:
                bVar22 = bVar27 & 0x7f;
                bVar20 = 0;
                pbVar46 = (byte *)0x0;
                fmt0 = buf + 0x60;
                pbVar44 = (byte *)0x0;
                goto LAB_10017c6e;
              }
              buf[0x5f] = *pcVar17;
              fmt0 = buf + 0x5f;
              bVar20 = 0;
              bVar22 = bVar27 & 0x7f;
              goto LAB_100180ee;
            }
            uStack_10c = CONCAT11(uVar9,0x30);
            if ((int)pbVar36 < 0) {
              bVar27 = bVar27 | 2;
              goto LAB_10018908;
            }
            bVar22 = bVar27 & 0x7f | 2;
LAB_10018610:
            bVar27 = bVar22;
            bVar6 = false;
            buf[0x5f] = pcVar17[uVar24 & 0xf];
            bVar20 = bVar27 & 2;
          }
          else {
            if (-1 < (int)pbVar36) {
              bVar22 = bVar27 & 0x7f;
              if (uVar24 != 0 || uVar38 != 0) goto LAB_10018610;
              goto LAB_100188ae;
            }
LAB_10018908:
            bVar20 = bVar27 & 2;
            buf[0x5f] = pcVar17[uVar24 & 0xf];
            bVar6 = false;
          }
        }
        uVar24 = uVar24 >> 4 | uVar38 << 0x1c;
        uVar38 = uVar38 >> 4;
        fmt0 = buf + 0x5f;
        bVar22 = bVar27;
        if (uVar24 != 0 || uVar38 != 0) {
          do {
            uVar32 = uVar24 & 0xf;
            uVar24 = uVar24 >> 4 | uVar38 << 0x1c;
            uVar38 = uVar38 >> 4;
            *(char *)((int)fmt0 + -1) = pcVar17[uVar32];
            fmt0 = (char *)((int)fmt0 + -1);
          } while (uVar24 != 0 || uVar38 != 0);
        }
        goto LAB_100180ee;
      }
    }
  }
LAB_10017700:
  if (uio.uio_iovcnt != 0) {
    __ssprint_r(data,fp,(__suio *)auStack_f0);
  }
LAB_1001770a:
  if ((fp->_flags & 0x40U) == 0) {
    return iStack_214;
  }
  return -1;
switchD_100175e2_caseD_6c:
  uVar10 = (uint)(byte)*psVar12;
  if (uVar10 == 0x6c) {
    uVar10 = (uint)*(byte *)((int)psVar12 + 1);
    bVar3 = true;
    psVar12 = (size_t *)((int)psVar12 + 1);
  }
  else {
    bVar4 = true;
  }
  goto LAB_100175ca;
  while( true ) {
    uVar30 = uVar30 + (uVar30 < uVar32);
    uVar30 = uVar32 - (uVar30 - (((uint)((ulonglong)uVar30 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                uVar30 / 5));
    uVar38 = (uVar24 - (uVar32 < uVar30)) * -0x33333333 + uVar30 * -0x33333334 +
             (int)((ulonglong)uVar30 * 0xcccccccd >> 0x20);
    uVar45 = uVar38 >> 1;
    uVar38 = uVar38 * -0x80000000 | uVar30 * -0x33333333 >> 1;
    bVar1 = uVar24 == 0;
    uVar24 = uVar45;
    if ((bVar1) && (uVar32 < 10)) break;
LAB_10017d68:
    uVar32 = uVar38;
    uVar30 = uVar32 + uVar24;
    uVar38 = (uVar30 < uVar32) + uVar30;
    pbStack_200 = pbStack_200 + 1;
    psVar43 = (size_t *)((int)fmt0 + -1);
    *(byte *)((int)fmt0 + -1) =
         (char)uVar32 +
         (char)((uVar32 - (uVar38 - (((uint)((ulonglong)uVar38 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar38 / 5))) * -0x33333333 >> 1) * -10 + 0x30;
    fmt0 = (char *)psVar43;
    bVar22 = bVar27;
    if (bVar6) {
      while ((fmt0 = (char *)psVar43, (byte *)(uint)*pbStack_1e4 == pbStack_200 &&
             (pbStack_200 != (byte *)0xff))) {
        if ((uVar24 == 0) && (uVar32 < 10)) goto LAB_10018416;
        pcVar17 = (char *)((int)psVar43 - sStack_1c8);
        strncpy(pcVar17,pcStack_1d0,sStack_1c8);
        uVar38 = uVar32 + uVar24 + (uint)(uVar32 + uVar24 < uVar32);
        pbStack_1e4 = pbStack_1e4 + (pbStack_1e4[1] != 0);
        uVar30 = uVar32 - (uVar38 - (((uint)((ulonglong)uVar38 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar38 / 5));
        psVar43 = (size_t *)(pcVar17 + -1);
        uVar38 = (uVar24 - (uVar32 < uVar30)) * -0x33333333 + uVar30 * -0x33333334 +
                 (int)((ulonglong)uVar30 * 0xcccccccd >> 0x20);
        uVar24 = uVar38 >> 1;
        uVar30 = uVar30 * -0x33333333 >> 1;
        uVar32 = uVar38 * -0x80000000 | uVar30;
        uVar38 = uVar32 + uVar24 + (uint)(uVar32 + uVar24 < uVar32);
        pcVar17[-1] = (char)uVar30 +
                      (char)((uVar32 - (uVar38 - (((uint)((ulonglong)uVar38 * 0xcccccccd >> 0x20) &
                                                  0xfffffffc) + uVar38 / 5))) * -0x33333333 >> 1) *
                      -10 + '0';
        pbStack_200 = &DAT_00000001;
      }
      uVar30 = uVar32 + uVar24;
    }
  }
LAB_10018416:
  pbVar46 = (byte *)(buf + (0x60 - (int)fmt0));
  pbVar44 = pbVar36;
  if ((int)pbVar36 < (int)pbVar46) {
    pbVar44 = pbVar46;
  }
LAB_10017fd2:
  bVar20 = 0;
LAB_10017c6e:
  bVar1 = false;
  psStack_210 = (size_t *)0x0;
  iStack_1fc = 0;
  iStack_208 = 0;
  pbVar41 = (byte *)0x0;
  bVar27 = bVar22;
  goto joined_r0x10017c76;
LAB_10018fc0:
  do {
    psVar43 = (size_t *)((int)register0x0000203c + 1);
    *(byte *)register0x0000203c = 0x30;
    unique0x100014cb = psVar43;
  } while (psVar43 < pbVar44);
  pbStack_200 = (byte *)((int)psVar43 - (int)fmt0);
  if (iVar35 == 0x47) {
LAB_100190a0:
    if ((int)_ox < -3) {
LAB_1001942c:
      uVar10 = uVar10 - 2;
      pbVar36 = _ox;
      _ox = _ox + -1;
      dsgn._0_1_ = (char)uVar10;
LAB_1001943a:
      dsgn._1_1_ = 0x2d;
      pbVar36 = (byte *)(1 - (int)pbVar36);
joined_r0x1001944a:
      if (9 < (int)pbVar36) goto LAB_1001937a;
    }
    else {
      if ((int)_ox <= (int)pbVar36) {
        if ((int)_ox < (int)pbStack_200) {
LAB_10019520:
          uVar10 = 0x67;
          pbVar46 = pbStack_200 + sVar14;
          if (0 < (int)_ox) goto LAB_1001914e;
          pbVar46 = pbStack_200 + sVar14 + (1 - (int)_ox);
          pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
        }
        else {
          pbVar46 = _ox;
          if (bVar8) {
            pbVar46 = _ox + sVar14;
          }
LAB_10018edc:
          if ((bVar6) && (0 < (int)_ox)) {
            uVar10 = 0x67;
            goto LAB_10019692;
          }
          pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          uVar10 = 0x67;
        }
        goto LAB_10018efa;
      }
LAB_100190aa:
      uVar10 = uVar10 - 2;
      pbVar44 = _ox + -1;
      dsgn._0_1_ = (undefined1)uVar10;
      if (-1 < (int)pbVar44) goto LAB_10018ffe;
      pbVar36 = (byte *)(1 - (int)_ox);
      dsgn._1_1_ = 0x2d;
      _ox = pbVar44;
    }
    cVar28 = (char)pbVar36;
    dsgn._2_1_ = 0x30;
    pcVar17 = (char *)((int)&dsgn + 3);
    goto LAB_10019018;
  }
  if (iVar35 != 0x46) {
LAB_10018fee:
    pbVar44 = _ox + -1;
    pbVar36 = _ox;
    _ox = pbVar44;
    dsgn._0_1_ = uVar9;
    if ((int)pbVar44 < 0) goto LAB_1001943a;
LAB_10018ffe:
    dsgn._1_1_ = 0x2b;
    pbVar36 = pbVar44;
    _ox = pbVar44;
    goto joined_r0x1001944a;
  }
LAB_10019138:
  if ((int)_ox < 1) {
    if (bVar8 || pbVar36 != (byte *)0x0) {
      uVar10 = 0x66;
      pbVar46 = pbVar36 + sVar14 + 1;
      pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
    }
    else {
      pbVar44 = &DAT_00000001;
      pbVar46 = &DAT_00000001;
      uVar10 = 0x66;
    }
  }
  else {
    if (bVar8 || pbVar36 != (byte *)0x0) {
      uVar10 = 0x66;
      pbVar46 = pbVar36 + (int)_ox + sVar14;
    }
    else {
      uVar10 = 0x66;
      pbVar46 = _ox;
    }
LAB_1001914e:
    if (bVar6) {
LAB_10019692:
      uVar38 = (uint)*pbStack_1e4;
      pbVar41 = _ox;
      if (uVar38 == 0xff) {
        iStack_1fc = 0;
        iStack_208 = 0;
      }
      else {
        iStack_1fc = 0;
        iStack_208 = 0;
        do {
          if ((int)pbVar41 <= (int)uVar38) break;
          pbVar41 = pbVar41 + -uVar38;
          uVar38 = (uint)pbStack_1e4[1];
          if (uVar38 == 0) {
            uVar38 = (uint)*pbStack_1e4;
            iStack_1fc = iStack_1fc + 1;
          }
          else {
            iStack_208 = iStack_208 + 1;
            pbStack_1e4 = pbStack_1e4 + 1;
          }
        } while (uVar38 != 0xff);
      }
      pbVar46 = pbVar46 + (iStack_1fc + iStack_208) * sStack_1c8;
      pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
      goto LAB_10018efe;
    }
    pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
  }
LAB_10018efa:
  iStack_1fc = 0;
  iStack_208 = 0;
  pbVar41 = _ox;
  goto LAB_10018efe;
  while (_Var16 = __eqdf2(dRam00000010,DRam00000018), psVar43 = psVar39, _Var16 != 0) {
LAB_1001921c:
    pbVar44 = pbVar36;
    pbVar36 = pbVar44 + -1;
    __muldf3(dRam00000010,DRam00000018);
    uVar38 = __fixdfsi(dRam00000010);
    __floatsidf(uVar38);
    __subdf3(dRam00000010,DRam00000018);
    psVar39 = (size_t *)((int)psVar43 + 1);
    *(char *)psVar43 = pcVar17[uVar38];
    if (pbVar36 == (byte *)0xffffffff) {
      _Var16 = __gedf2(dRam00000010,DRam00000018);
      if ((0 < _Var16) ||
         ((_Var16 = __eqdf2(dRam00000010,DRam00000018), _Var16 == 0 && ((uVar38 & 1) != 0)))) {
        bVar22 = (byte)*psVar43;
        psVar23 = psVar39;
        unique0x100016a3 = psVar43;
        if (pcVar17[0xf] == bVar22) {
          do {
            *(byte *)((int)psVar23 + -1) = 0x30;
            psVar43 = (size_t *)((int)stack0xffffff08 + -1);
            bVar22 = *(byte *)((int)stack0xffffff08 + -1);
            psVar23 = stack0xffffff08;
            unique0x1000169f = psVar43;
          } while (pcVar17[0xf] == bVar22);
        }
        bVar20 = bVar22 + 1;
        if (bVar22 == 0x39) {
          bVar20 = pcVar17[10];
        }
        *(byte *)((int)psVar23 + -1) = bVar20;
      }
      goto LAB_1001933e;
    }
  }
  if (-1 < (int)pbVar36) {
    do {
      psVar23 = (size_t *)((int)psVar43 + 1);
      *(byte *)psVar43 = 0x30;
      psVar43 = psVar23;
    } while ((size_t *)(pbVar44 + (int)psVar39) != psVar23);
    psVar39 = (size_t *)((byte *)((int)psVar39 + (int)pbVar36) + 1);
  }
LAB_1001933e:
  pbStack_200 = (byte *)((int)psVar39 - (int)fmt0);
  pbVar44 = _ox + -1;
  dsgn._0_1_ = 0x70;
  if (uVar10 != 0x61) {
    dsgn._0_1_ = 0x50;
    uVar10 = 0x41;
  }
  if ((int)pbVar44 < 0) {
    dsgn._1_1_ = 0x2d;
    pbVar36 = (byte *)(1 - (int)_ox);
  }
  else {
    dsgn._1_1_ = 0x2b;
    pbVar36 = pbVar44;
  }
  _ox = pbVar44;
  if ((int)pbVar36 < 10) {
    cVar28 = (char)pbVar36;
    pcVar17 = (char *)((int)&dsgn + 2);
LAB_10019018:
    pcStack_1dc = pcVar17 + (0xc1 - (int)(buf + 0x60));
    *pcVar17 = cVar28 + '0';
  }
  else {
LAB_1001937a:
    puVar34 = (undefined1 *)((int)&rve + 3);
    puVar29 = puVar34;
    do {
      puVar21 = puVar29;
      cVar28 = (char)(byte *)((uint)pbVar36 / 10);
      puVar21[-1] = (char)pbVar36 + cVar28 * -10 + '0';
      bVar1 = 99 < (int)pbVar36;
      puVar29 = puVar21 + -1;
      pbVar36 = (byte *)((uint)pbVar36 / 10);
    } while (bVar1);
    puVar21[-2] = cVar28 + '0';
    puVar29 = puVar21 + -2;
    if (puVar29 < puVar34) {
      puVar26 = (undefined1 *)((int)&dsgn + 2);
      do {
        uVar9 = *puVar29;
        puVar29 = puVar29 + 1;
        *puVar26 = uVar9;
        puVar26 = puVar26 + 1;
      } while (puVar29 != puVar34);
      pcStack_1dc = puVar29 + (4 - (int)puVar21);
    }
    else {
      pcStack_1dc = (char *)0x2;
    }
  }
  pbVar46 = pbStack_200 + (int)pcStack_1dc;
  if ((1 < (int)pbStack_200) || (bVar8)) {
    pbVar46 = pbVar46 + sVar14;
  }
  bVar6 = false;
  pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
  iStack_1fc = 0;
  iStack_208 = 0;
  pbVar41 = (byte *)0x0;
LAB_10018efe:
  bVar1 = true;
  bVar20 = bVar27 & 2;
  if (iStack_1cc == 0) {
    pbVar36 = (byte *)0x0;
joined_r0x10017c76:
    if (cStack_10d != '\0') {
      pbVar44 = pbVar44 + 1;
    }
  }
  else {
    cStack_10d = '-';
    pbVar36 = (byte *)0x0;
    pbVar44 = pbVar44 + 1;
  }
  pbVar37 = pbVar36;
  if (bVar20 == 0) {
joined_r0x10017a3c:
    pbVar36 = pbVar37;
    bVar22 = bVar27 & 0x84;
    if (bVar22 != 0) {
      if (cStack_10d != '\0') {
LAB_10017642:
        bVar2 = false;
        goto LAB_10017648;
      }
LAB_1001768a:
      if ((bVar22 == 0x80) && (iVar35 = (int)pbVar40 - (int)pbVar44, 0 < iVar35)) {
        if (0x10 < iVar35) {
          do {
            while( true ) {
              iVar19 = iVar35;
              *psVar11 = (size_t)"0000000000000000";
              psVar11[1] = 0x10;
              uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              psVar11 = psVar11 + 2;
              if ((int)uio.uio_iov < 8) break;
              iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_100181f8;
              psVar11 = &uio.uio_resid;
              iVar35 = iVar19 + -0x10;
              if (iVar19 + -0x10 < 0x11) goto LAB_100181a2;
            }
            iVar35 = iVar19 + -0x10;
          } while (0x10 < iVar19 + -0x10);
LAB_100181a2:
          iVar35 = iVar19 + -0x10;
        }
        *psVar11 = (size_t)"0000000000000000";
        psVar11[1] = iVar35;
        uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar11 = psVar11 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
        }
      }
      goto LAB_10017692;
    }
    iVar35 = (int)pbVar40 - (int)pbVar44;
    if (0 < iVar35) {
      bVar2 = false;
      goto LAB_10017dc8;
    }
    if (cStack_10d != '\0') goto LAB_10017642;
    iVar35 = (int)pbVar36 - (int)pbVar46;
    if (0 < iVar35) goto LAB_10017a58;
LAB_1001769a:
    if (bVar1) goto LAB_10017b06;
LAB_100176a2:
    uio.uio_iovcnt = (int)(pbVar46 + uio.uio_iovcnt);
    *psVar11 = (size_t)fmt0;
    psVar11[1] = (size_t)pbVar46;
joined_r0x100176be:
    uio.uio_iov = (__siov *)((int)uio.uio_iov + 1);
    if ((int)uio.uio_iov < 8) {
      psVar11 = (size_t *)((int)psVar11 + 8);
      pbVar36 = (byte *)uio.uio_iovcnt;
      goto LAB_100176c4;
    }
LAB_10017926:
    iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
    if (iVar35 != 0) goto LAB_100181f8;
    psVar11 = &uio.uio_resid;
    pbVar36 = (byte *)uio.uio_iovcnt;
  }
  else {
LAB_10017c7e:
    bVar22 = bVar27 & 0x84;
    pbVar44 = pbVar44 + 2;
    if ((bVar22 != 0) || (iVar35 = (int)pbVar40 - (int)pbVar44, iVar35 < 1)) {
      if (cStack_10d != '\0') {
        bVar2 = true;
        goto LAB_10017648;
      }
LAB_1001766e:
      psVar11[1] = 2;
      *psVar11 = (size_t)&uStack_10c;
      uio.uio_iovcnt = uio.uio_iovcnt + 2;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar11 = psVar11 + 2;
      if (7 < (int)uio.uio_iov) {
        iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_100181f8;
        psVar11 = &uio.uio_resid;
      }
      goto LAB_1001768a;
    }
    bVar2 = true;
LAB_10017dc8:
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar19 = iVar35;
          *psVar11 = (size_t)"                ";
          psVar11[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
          iVar35 = iVar19 + -0x10;
          if (iVar19 + -0x10 < 0x11) goto LAB_10017e2a;
        }
        iVar35 = iVar19 + -0x10;
      } while (0x10 < iVar19 + -0x10);
LAB_10017e2a:
      iVar35 = iVar19 + -0x10;
    }
    psVar11[1] = iVar35;
    *psVar11 = (size_t)"                ";
    uio.uio_iovcnt = iVar35 + uio.uio_iovcnt;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    if (7 < (int)uio.uio_iov) {
      iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
      if (iVar35 != 0) goto LAB_100181f8;
      if (cStack_10d != '\0') {
        bVar22 = 0;
        psVar11 = &uio.uio_resid;
        goto LAB_10017648;
      }
      if (!bVar2) {
        psVar11 = &uio.uio_resid;
        goto LAB_10017692;
      }
      bVar22 = 0;
      psVar11 = &uio.uio_resid;
      goto LAB_1001766e;
    }
    psVar11 = psVar11 + 2;
    if (cStack_10d != '\0') {
      bVar22 = 0;
LAB_10017648:
      psVar11[1] = 1;
      *psVar11 = (size_t)&cStack_10d;
      uio.uio_iovcnt = uio.uio_iovcnt + 1;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar11 = psVar11 + 2;
      if (7 < (int)uio.uio_iov) {
        iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_100181f8;
        psVar11 = &uio.uio_resid;
      }
      if (!bVar2) goto LAB_1001768a;
      goto LAB_1001766e;
    }
    if (bVar2) {
      bVar22 = 0;
      goto LAB_1001766e;
    }
LAB_10017692:
    iVar35 = (int)pbVar36 - (int)pbVar46;
    if (iVar35 < 1) goto LAB_1001769a;
LAB_10017a58:
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar19 = iVar35;
          *psVar11 = (size_t)"0000000000000000";
          psVar11[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
          iVar35 = iVar19 + -0x10;
          if (iVar19 + -0x10 < 0x11) goto LAB_10017ab8;
        }
        iVar35 = iVar19 + -0x10;
      } while (0x10 < iVar19 + -0x10);
LAB_10017ab8:
      iVar35 = iVar19 + -0x10;
    }
    *psVar11 = (size_t)"0000000000000000";
    psVar11[1] = iVar35;
    uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    psVar11 = psVar11 + 2;
    if ((int)uio.uio_iov < 8) goto LAB_1001769a;
    iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
    if (iVar35 != 0) goto LAB_100181f8;
    psVar11 = &uio.uio_resid;
    if (!bVar1) goto LAB_100176a2;
LAB_10017b06:
    pbVar36 = (byte *)uio.uio_iovcnt;
    if ((int)uVar10 < 0x66) {
      pbVar36 = (byte *)(uio.uio_iovcnt + 1);
      p_Var25 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar43 = psVar11 + 2;
      uio.uio_iovcnt = (int)pbVar36;
      uio.uio_iov = p_Var25;
      if ((1 < (int)pbStack_200) || (bVar8)) {
        psVar11[1] = 1;
        *psVar11 = (size_t)fmt0;
        psVar11 = psVar43;
        if (7 < (int)p_Var25) {
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
        }
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        *psVar11 = (size_t)__s;
        psVar43 = psVar11 + 2;
        psVar11[1] = sVar14;
        uio.uio_iovcnt = uio.uio_iovcnt + sVar14;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar43 = &uio.uio_resid;
        }
        pbVar36 = (byte *)uio.uio_iovcnt;
        p_Var25 = uio.uio_iov;
        pbVar37 = pbStack_200 + -1;
        _Var16 = __eqdf2(dRam00000010,DRam00000018);
        if (_Var16 == 0) {
          if (1 < (int)pbStack_200) {
            if (0x11 < (int)pbStack_200) {
              do {
                *psVar43 = (size_t)"0000000000000000";
                psVar43[1] = 0x10;
                uio.uio_iovcnt = (int)pbVar36 + 0x10;
                uio.uio_iov = (__siov *)((int)&p_Var25->iov_base + 1);
                psVar43 = psVar43 + 2;
                if (7 < (int)uio.uio_iov) {
                  iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                  if (iVar35 != 0) goto LAB_100181f8;
                  psVar43 = &uio.uio_resid;
                }
                pbVar37 = pbVar37 + -0x10;
                pbVar36 = (byte *)uio.uio_iovcnt;
                p_Var25 = uio.uio_iov;
              } while (0x10 < (int)pbVar37);
            }
            *psVar43 = (size_t)"0000000000000000";
            psVar43[1] = (size_t)pbVar37;
            uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
            uio.uio_iov = (__siov *)((int)&p_Var25->iov_base + 1);
            if ((int)uio.uio_iov < 8) goto LAB_10017902;
            goto LAB_10018380;
          }
        }
        else {
          *psVar43 = (size_t)((int)fmt0 + 1);
          psVar43[1] = (size_t)pbVar37;
          uio.uio_iov = (__siov *)((int)&p_Var25->iov_base + 1);
          uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
          if ((int)uio.uio_iov < 8) {
LAB_10017902:
            psVar43 = psVar43 + 2;
            pbVar36 = (byte *)uio.uio_iovcnt;
            p_Var25 = uio.uio_iov;
          }
          else {
LAB_10018380:
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar43 = &uio.uio_resid;
            pbVar36 = (byte *)uio.uio_iovcnt;
            p_Var25 = uio.uio_iov;
          }
        }
      }
      else {
        *psVar11 = (size_t)fmt0;
        psVar11[1] = 1;
        if (7 < (int)p_Var25) goto LAB_10018380;
      }
      *psVar43 = (size_t)&dsgn;
      psVar43[1] = (size_t)pcStack_1dc;
      uio.uio_iovcnt = (int)(pbVar36 + (int)pcStack_1dc);
joined_r0x10017922:
      uio.uio_iov = (__siov *)((int)&p_Var25->iov_base + 1);
      psVar11 = psVar43 + 2;
      pbVar36 = (byte *)uio.uio_iovcnt;
      if (7 < (int)uio.uio_iov) goto LAB_10017926;
    }
    else {
      _Var16 = __eqdf2(dRam00000010,DRam00000018);
      if (_Var16 == 0) {
        *psVar11 = (size_t)&DAT_10022568;
        psVar11[1] = 1;
        uio.uio_iovcnt = (int)pbVar36 + 1;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar11 = psVar11 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
        }
        if (((int)_ox < (int)pbStack_200) || (pbVar36 = (byte *)uio.uio_iovcnt, bVar8)) {
          *psVar11 = (size_t)__s;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11[1] = sVar14;
          uio.uio_iovcnt = uio.uio_iovcnt + sVar14;
          psVar11 = psVar11 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar11 = &uio.uio_resid;
          }
          pbVar37 = pbStack_200 + -1;
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (0 < (int)pbVar37) {
            for (; 0x10 < (int)pbVar37; pbVar37 = pbVar37 + -0x10) {
              *psVar11 = (size_t)"0000000000000000";
              psVar11[1] = 0x10;
              uio.uio_iovcnt = (int)(pbVar36 + 0x10);
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              psVar11 = psVar11 + 2;
              if (7 < (int)uio.uio_iov) {
                iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_100181f8;
                psVar11 = &uio.uio_resid;
              }
              pbVar36 = (byte *)uio.uio_iovcnt;
            }
            goto LAB_10018ade;
          }
        }
      }
      else {
        if ((int)_ox < 1) {
          *psVar11 = (size_t)&DAT_10022568;
          psVar11[1] = 1;
          uio.uio_iovcnt = (int)pbVar36 + 1;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar11 = &uio.uio_resid;
          }
          if (_ox == (byte *)0x0) {
            pbVar36 = (byte *)uio.uio_iovcnt;
            if (!bVar8 && pbStack_200 == (byte *)0x0) goto LAB_100176c4;
            *psVar11 = (size_t)__s;
            p_Var25 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar43 = psVar11 + 2;
            psVar11[1] = sVar14;
            iVar35 = uio.uio_iovcnt + sVar14;
            if (7 < (int)p_Var25) goto LAB_10018f18;
          }
          else {
            *psVar11 = (size_t)__s;
            p_Var25 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar11[1] = sVar14;
            if ((int)p_Var25 < 8) {
              psVar43 = psVar11 + 2;
              uio.uio_iov = p_Var25;
              uio.uio_iovcnt = uio.uio_iovcnt + sVar14;
            }
            else {
LAB_10018f18:
              uio.uio_iovcnt = uio.uio_iovcnt + sVar14;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_100181f8;
              psVar43 = &uio.uio_resid;
            }
            iVar35 = uio.uio_iovcnt;
            p_Var25 = uio.uio_iov;
            if ((int)_ox < 0) {
              iVar35 = -(int)_ox;
              if ((int)_ox < -0x10) {
                do {
                  *psVar43 = (size_t)"0000000000000000";
                  psVar43[1] = 0x10;
                  uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
                  uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
                  psVar43 = psVar43 + 2;
                  if (7 < (int)uio.uio_iov) {
                    iVar19 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                    if (iVar19 != 0) goto LAB_100181f8;
                    psVar43 = &uio.uio_resid;
                  }
                  iVar35 = iVar35 + -0x10;
                } while (0x10 < iVar35);
              }
              *psVar43 = (size_t)"0000000000000000";
              psVar43[1] = iVar35;
              uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              psVar43 = psVar43 + 2;
              iVar35 = uio.uio_iovcnt;
              p_Var25 = uio.uio_iov;
              if (7 < (int)uio.uio_iov) {
                iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_100181f8;
                psVar43 = &uio.uio_resid;
                iVar35 = uio.uio_iovcnt;
                p_Var25 = uio.uio_iov;
              }
            }
          }
          *psVar43 = (size_t)fmt0;
          psVar43[1] = (size_t)pbStack_200;
          uio.uio_iovcnt = (int)(pbStack_200 + iVar35);
          goto joined_r0x10017922;
        }
        pbVar37 = pbStack_200;
        if ((int)pbVar41 <= (int)pbStack_200) {
          pbVar37 = pbVar41;
        }
        if (0 < (int)pbVar37) {
          uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
          *psVar11 = (size_t)fmt0;
          psVar11[1] = (size_t)pbVar37;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar11 = &uio.uio_resid;
            pbVar36 = (byte *)uio.uio_iovcnt;
          }
        }
        iVar35 = (int)pbVar41 - ((uint)pbVar37 & (int)~(uint)pbVar37 >> 0x1f);
        if (0 < iVar35) {
          for (; 0x10 < iVar35; iVar35 = iVar35 + -0x10) {
            *psVar11 = (size_t)"0000000000000000";
            psVar11[1] = 0x10;
            uio.uio_iovcnt = (int)(pbVar36 + 0x10);
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar11 = psVar11 + 2;
            if (7 < (int)uio.uio_iov) {
              iVar19 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar19 != 0) goto LAB_100181f8;
              psVar11 = &uio.uio_resid;
            }
            pbVar36 = (byte *)uio.uio_iovcnt;
          }
          *psVar11 = (size_t)"0000000000000000";
          psVar11[1] = iVar35;
          uio.uio_iovcnt = (int)(pbVar36 + iVar35);
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar11 = &uio.uio_resid;
            pbVar36 = (byte *)uio.uio_iovcnt;
          }
        }
        pbVar41 = (byte *)((int)fmt0 + (int)pbVar41);
        if (bVar6) {
          if (iStack_208 < 1) goto LAB_100187ea;
LAB_1001877a:
          if (iStack_1fc < 1) {
            pbStack_1e4 = pbStack_1e4 + -1;
            iStack_208 = iStack_208 + -1;
            goto LAB_10018780;
          }
          do {
            iStack_1fc = iStack_1fc + -1;
LAB_10018780:
            psVar11[1] = sStack_1c8;
            uio.uio_iovcnt = (int)(pbVar36 + sStack_1c8);
            *psVar11 = (size_t)pcStack_1d0;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar11 = psVar11 + 2;
            if (7 < (int)uio.uio_iov) {
              iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_100181f8;
              psVar11 = &uio.uio_resid;
            }
            uVar38 = (uint)*pbStack_1e4;
            uVar10 = (int)(pbStack_200 + (int)fmt0) - (int)pbVar41;
            if ((int)uVar38 < (int)(pbStack_200 + (int)fmt0) - (int)pbVar41) {
              uVar10 = uVar38;
            }
            if (0 < (int)uVar10) {
              uio.uio_iovcnt = uio.uio_iovcnt + uVar10;
              *psVar11 = (size_t)pbVar41;
              psVar11[1] = uVar10;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              if ((int)uio.uio_iov < 8) {
                uVar38 = (uint)*pbStack_1e4;
                psVar11 = psVar11 + 2;
              }
              else {
                iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_100181f8;
                uVar38 = (uint)*pbStack_1e4;
                psVar11 = &uio.uio_resid;
              }
            }
            iVar35 = uVar38 - (uVar10 & (int)~uVar10 >> 0x1f);
            if (iVar35 < 1) {
              pbVar41 = pbVar41 + uVar38;
            }
            else {
              if (0x10 < iVar35) {
                do {
                  while( true ) {
                    iVar19 = iVar35;
                    *psVar11 = (size_t)"0000000000000000";
                    psVar11[1] = 0x10;
                    uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
                    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
                    psVar11 = psVar11 + 2;
                    if ((int)uio.uio_iov < 8) break;
                    iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                    if (iVar35 != 0) goto LAB_100181f8;
                    psVar11 = &uio.uio_resid;
                    iVar35 = iVar19 + -0x10;
                    if (iVar19 + -0x10 < 0x11) goto LAB_1001886c;
                  }
                  iVar35 = iVar19 + -0x10;
                } while (0x10 < iVar19 + -0x10);
LAB_1001886c:
                iVar35 = iVar19 + -0x10;
              }
              *psVar11 = (size_t)"0000000000000000";
              psVar11[1] = iVar35;
              uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              if ((int)uio.uio_iov < 8) {
                psVar11 = psVar11 + 2;
                pbVar41 = pbVar41 + *pbStack_1e4;
              }
              else {
                iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_100181f8;
                psVar11 = &uio.uio_resid;
                pbVar41 = pbVar41 + *pbStack_1e4;
              }
            }
            pbVar36 = (byte *)uio.uio_iovcnt;
            if (0 < iStack_208) goto LAB_1001877a;
LAB_100187ea:
            if (iStack_1fc < 1) {
              if ((byte *)((int)fmt0 + (int)pbStack_200) < pbVar41) {
                pbVar41 = (byte *)((int)fmt0 + (int)pbStack_200);
              }
              break;
            }
          } while( true );
        }
        if (((int)_ox < (int)pbStack_200) || (bVar8)) {
          *psVar11 = (size_t)__s;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11[1] = sVar14;
          uio.uio_iovcnt = (int)(pbVar36 + sVar14);
          psVar11 = psVar11 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_100181f8;
            psVar11 = &uio.uio_resid;
          }
          uVar10 = (int)((int)fmt0 + (int)pbStack_200) - (int)pbVar41;
          uVar38 = (int)pbStack_200 - (int)_ox;
          if ((int)uVar38 < (int)uVar10) {
            uVar10 = uVar38;
          }
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (0 < (int)uVar10) {
            uio.uio_iovcnt = uio.uio_iovcnt + uVar10;
            *psVar11 = (size_t)pbVar41;
            psVar11[1] = uVar10;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar11 = psVar11 + 2;
            pbVar36 = (byte *)uio.uio_iovcnt;
            if (7 < (int)uio.uio_iov) {
              iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_100181f8;
              psVar11 = &uio.uio_resid;
              uVar38 = (int)pbStack_200 - (int)_ox;
              pbVar36 = (byte *)uio.uio_iovcnt;
            }
          }
        }
        else {
          uVar38 = (int)pbStack_200 - (int)_ox;
          uVar10 = (int)(pbStack_200 + (int)fmt0) - (int)pbVar41;
          if ((int)uVar38 < (int)(pbStack_200 + (int)fmt0) - (int)pbVar41) {
            uVar10 = uVar38;
          }
        }
        pbVar37 = (byte *)(uVar38 - (uVar10 & (int)~uVar10 >> 0x1f));
        if (0 < (int)pbVar37) {
          for (; 0x10 < (int)pbVar37; pbVar37 = pbVar37 + -0x10) {
            *psVar11 = (size_t)"0000000000000000";
            psVar11[1] = 0x10;
            uio.uio_iovcnt = (int)(pbVar36 + 0x10);
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar11 = psVar11 + 2;
            if (7 < (int)uio.uio_iov) {
              iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_100181f8;
              psVar11 = &uio.uio_resid;
            }
            pbVar36 = (byte *)uio.uio_iovcnt;
          }
LAB_10018ade:
          *psVar11 = (size_t)"0000000000000000";
          psVar11[1] = (size_t)pbVar37;
          uio.uio_iovcnt = (int)(pbVar36 + (int)pbVar37);
          goto joined_r0x100176be;
        }
      }
    }
  }
LAB_100176c4:
  if (((bVar27 & 4) != 0) && (iVar35 = (int)pbVar40 - (int)pbVar44, 0 < iVar35)) {
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar19 = iVar35;
          *psVar11 = (size_t)"                ";
          psVar11[1] = 0x10;
          pbVar36 = pbVar36 + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar11 = psVar11 + 2;
          if ((int)uio.uio_iov < 8) break;
          uio.uio_iovcnt = (int)pbVar36;
          iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_100181f8;
          psVar11 = &uio.uio_resid;
          pbVar36 = (byte *)uio.uio_iovcnt;
          iVar35 = iVar19 + -0x10;
          if (iVar19 + -0x10 < 0x11) goto LAB_1001799e;
        }
        iVar35 = iVar19 + -0x10;
      } while (0x10 < iVar19 + -0x10);
LAB_1001799e:
      iVar35 = iVar19 + -0x10;
    }
    *psVar11 = (size_t)"                ";
    psVar11[1] = iVar35;
    uio.uio_iovcnt = (int)(pbVar36 + iVar35);
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    pbVar36 = (byte *)uio.uio_iovcnt;
    if ((7 < (int)uio.uio_iov) &&
       (iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0), pbVar36 = (byte *)uio.uio_iovcnt,
       iVar35 != 0)) goto LAB_100181f8;
  }
  if ((int)pbVar40 < (int)pbVar44) {
    pbVar40 = pbVar44;
  }
  iStack_214 = iStack_214 + (int)pbVar40;
  if ((pbVar36 == (byte *)0x0) || (iVar35 = __ssprint_r(data,fp,(__suio *)auStack_f0), iVar35 == 0))
  {
    uio.uio_iov = (__siov *)0x0;
    if (psStack_210 != (size_t *)0x0) {
      _free_r(data,psStack_210);
    }
    psVar11 = &uio.uio_resid;
LAB_100176f8:
    bVar27 = (byte)*psVar12;
    fmt0 = (char *)psVar12;
    goto joined_r0x10017566;
  }
LAB_100181f8:
  if (psStack_210 != (size_t *)0x0) {
    _free_r(data,psStack_210);
  }
  goto LAB_1001770a;
switchD_100175e2_caseD_31:
  uVar38 = uVar10 - 0x30;
  pbVar40 = (byte *)0x0;
  do {
    uVar10 = (uint)(byte)*psVar12;
    pbVar40 = (byte *)(uVar38 + (int)pbVar40 * 10);
    uVar38 = uVar10 - 0x30;
    psVar12 = (size_t *)((int)psVar12 + 1);
  } while (uVar38 < 10);
  goto code_r0x100175d0;
switchD_100175e2_caseD_20:
  if (cStack_10d == '\0') {
    cStack_10d = ' ';
    uVar10 = (uint)(byte)*psVar12;
  }
  else {
switchD_100175e2_caseD_74:
    uVar10 = (uint)(byte)*psVar12;
  }
  goto LAB_100175ca;
}



void * memset(void *__s,int __c,size_t __n)

{
  uint uVar1;
  void *pvVar2;
  uint extraout_a1;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  
  gp = &__global_pointer_;
  uVar1 = 0xf;
  if (0xf < __n) {
    uVar5 = (uint)__s & 0xf;
    puVar4 = (uint *)__s;
    if (uVar5 != 0) {
      pvVar2 = __s;
      __s = (void *)(*(code *)(uVar5 * 4 + 0x1001991a))();
      puVar4 = (uint *)((int)pvVar2 - (uVar5 - 0x10));
      __n = __n + (uVar5 - 0x10);
      __c = extraout_a1;
      if (__n <= uVar1) goto LAB_1001990e;
    }
    if (__c != 0) {
      uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
      __c = uVar5 | uVar5 << 0x10;
    }
    uVar5 = __n & 0xfffffff0;
    __n = __n & 0xf;
    puVar3 = (uint *)(uVar5 + (int)puVar4);
    do {
      *puVar4 = __c;
      puVar4[1] = __c;
      puVar4[2] = __c;
      puVar4[3] = __c;
      puVar4 = puVar4 + 4;
    } while (puVar4 < puVar3);
    if (__n == 0) {
      return __s;
    }
  }
LAB_1001990e:
                    // WARNING: Could not recover jumptable at 0x1001991a. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar2 = (void *)(*(code *)(&UNK_1001991e + (uVar1 - __n) * 4))();
  return pvVar2;
}



int vprintf(char *__format,__gnuc_va_list __arg)

{
  _reent *data;
  int iVar1;
  
  gp = &__global_pointer_;
  data = __wrap___getreent();
  iVar1 = _vfprintf_r(data,data->_stdout,__format,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention

int _vprintf_r(_reent *ptr,char *fmt,va_list ap)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = _vfprintf_r(ptr,ptr->_stdout,fmt,ap);
  return iVar1;
}



// WARNING: Unknown calling convention

int _mbtowc_r(_reent *r,wchar_t *pwc,char *s,size_t n,mbstate_t *state)

{
  int iVar1;
  
  gp = &__global_pointer_;
                    // WARNING: Could not recover jumptable at 0x100199c2. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*__global_locale.mbtowc)(r,pwc,s,n,state);
  return iVar1;
}



// WARNING: Unknown calling convention

int __ascii_mbtowc(_reent *r,wchar_t *pwc,char *s,size_t n,mbstate_t *state)

{
  uint uVar1;
  wchar_t dummy;
  
  gp = &__global_pointer_;
  if (pwc == (wchar_t *)0x0) {
    if (s == (char *)0x0) {
      uVar1 = 0;
    }
    else if (n == 0) {
      uVar1 = 0xfffffffe;
    }
    else {
      uVar1 = (uint)(*s != '\0');
    }
    return uVar1;
  }
  if (s != (char *)0x0) {
    if (n != 0) {
      *pwc = (uint)(byte)*s;
      return (uint)(*s != '\0');
    }
    return -2;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void stdio_exit_handler(void)

{
  gp = &__global_pointer_;
  _fwalk_sglue(&_impure_data,_fclose_r,&__sglue);
  return;
}



// WARNING: Unknown calling convention

void cleanup_stdio(_reent *ptr)

{
  gp = &__global_pointer_;
  if (ptr->_stdin != __sf) {
    _fclose_r(ptr,ptr->_stdin);
  }
  if (ptr->_stdout != __sf + 1) {
    _fclose_r(ptr,ptr->_stdout);
  }
  if (ptr->_stderr != __sf + 2) {
    _fclose_r(ptr,ptr->_stderr);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int __fp_lock(_reent *ptr,FILE *fp)

{
  gp = &__global_pointer_;
  if (((fp->_flags2 & 1U) == 0) && ((fp->_flags & 0x200U) == 0)) {
    __retarget_lock_acquire_recursive(&fp->_lock);
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

int __fp_unlock(_reent *ptr,FILE *fp)

{
  gp = &__global_pointer_;
  if (((fp->_flags2 & 1U) == 0) && ((fp->_flags & 0x200U) == 0)) {
    __retarget_lock_release_recursive(&fp->_lock);
    return 0;
  }
  return 0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void global_stdio_init(void)

{
  gp = &__global_pointer_;
  __sf[0]._flags = 4;
  __sf[0]._file = 0;
  __stdio_exit_handler = stdio_exit_handler;
  __sf[0]._p = (uchar *)0x0;
  __sf[0]._r = 0;
  __sf[0]._w = 0;
  __sf[0]._flags2 = 0;
  __sf[0]._bf._base = (uchar *)0x0;
  __sf[0]._bf._size = 0;
  __sf[0]._lbfsize = 0;
  memset(&__sf[0]._mbstate,0,8);
  __sf[0]._read = __sread;
  __sf[0]._write = __swrite;
  __sf[0]._seek = __sseek;
  __sf[0]._close = __sclose;
  __sf[0]._cookie = __sf;
  __retarget_lock_init_recursive(&__sf[0]._lock);
  __sf[1]._flags = 9;
  __sf[1]._file = 1;
  __sf[1]._p = (uchar *)0x0;
  __sf[1]._r = 0;
  __sf[1]._w = 0;
  __sf[1]._flags2 = 0;
  __sf[1]._bf._base = (uchar *)0x0;
  __sf[1]._bf._size = 0;
  __sf[1]._lbfsize = 0;
  memset(&__sf[1]._mbstate,0,8);
  __sf[1]._read = __sread;
  __sf[1]._write = __swrite;
  __sf[1]._seek = __sseek;
  __sf[1]._close = __sclose;
  __sf[1]._cookie = __sf + 1;
  __retarget_lock_init_recursive(&__sf[1]._lock);
  __sf[2]._flags = 0x12;
  __sf[2]._file = 2;
  __sf[2]._p = (uchar *)0x0;
  __sf[2]._r = 0;
  __sf[2]._w = 0;
  __sf[2]._flags2 = 0;
  __sf[2]._bf._base = (uchar *)0x0;
  __sf[2]._bf._size = 0;
  __sf[2]._lbfsize = 0;
  memset(&__sf[2]._mbstate,0,8);
  __sf[2]._read = __sread;
  __sf[2]._write = __swrite;
  __sf[2]._seek = __sseek;
  __sf[2]._close = __sclose;
  __sf[2]._cookie = __sf + 2;
  __retarget_lock_init_recursive(&__sf[2]._lock);
  return;
}



// WARNING: Unknown calling convention

FILE * __sfp(_reent *d)

{
  FILE *pFVar1;
  _glue *p_Var2;
  int iVar3;
  _glue *p_Var4;
  
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  if (__stdio_exit_handler == (_func_void *)0x0) {
    global_stdio_init();
  }
  p_Var2 = &__sglue;
  while( true ) {
    do {
      p_Var4 = p_Var2;
      pFVar1 = p_Var4->_iobs;
      iVar3 = p_Var4->_niobs + -1;
      if (-1 < iVar3) {
        do {
          iVar3 = iVar3 + -1;
          if (pFVar1->_flags == 0) {
            pFVar1->_flags = 1;
            pFVar1->_file = -1;
            pFVar1->_flags2 = 0;
            __retarget_lock_init_recursive(&pFVar1->_lock);
            __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
            pFVar1->_p = (uchar *)0x0;
            pFVar1->_w = 0;
            pFVar1->_r = 0;
            (pFVar1->_bf)._base = (uchar *)0x0;
            (pFVar1->_bf)._size = 0;
            pFVar1->_lbfsize = 0;
            memset(&pFVar1->_mbstate,0,8);
            (pFVar1->_ub)._base = (uchar *)0x0;
            (pFVar1->_ub)._size = 0;
            (pFVar1->_lb)._base = (uchar *)0x0;
            (pFVar1->_lb)._size = 0;
            return pFVar1;
          }
          pFVar1 = pFVar1 + 1;
        } while (iVar3 != -1);
      }
      p_Var2 = p_Var4->_next;
    } while (p_Var4->_next != (_glue *)0x0);
    p_Var2 = (_glue *)_malloc_r(d,0x1d0);
    if (p_Var2 == (_glue *)0x0) break;
    p_Var2->_next = (_glue *)0x0;
    p_Var2->_niobs = 4;
    p_Var2->_iobs = (__FILE *)&p_Var2[1]._niobs;
    memset(&p_Var2[1]._niobs,0,0x1c0);
    p_Var4->_next = p_Var2;
  }
  p_Var4->_next = (_glue *)0x0;
  __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  d->_errno = 0xc;
  return (FILE *)0x0;
}



// WARNING: Unknown calling convention

void __sinit(_reent *s)

{
  _func_void *p_Var1;
  
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  p_Var1 = __stdio_exit_handler;
  if ((s->__cleanup == (_func_void__reent_ptr *)0x0) &&
     (s->__cleanup = cleanup_stdio, p_Var1 == (_func_void *)0x0)) {
    global_stdio_init();
    __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
    return;
  }
  __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __sfp_lock_acquire(void)

{
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __sfp_lock_release(void)

{
  gp = &__global_pointer_;
  __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __fp_lock_all(void)

{
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  _fwalk_sglue((_reent *)0x0,__fp_lock,&__sglue);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __fp_unlock_all(void)

{
  gp = &__global_pointer_;
  _fwalk_sglue((_reent *)0x0,__fp_unlock,&__sglue);
  __retarget_lock_release_recursive((_LOCK_T)&__lock___sfp_recursive_mutex);
  return;
}



void * calloc(size_t __nmemb,size_t __size)

{
  _reent *reent_ptr;
  void *pvVar1;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  pvVar1 = _calloc_r(reent_ptr,__nmemb,__size);
  return pvVar1;
}



void * memmove(void *__dest,void *__src,size_t __n)

{
  undefined1 uVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  uint uVar6;
  void *pvVar7;
  undefined1 *puVar8;
  undefined1 *puVar9;
  undefined1 *puVar10;
  uint uVar11;
  undefined4 *puVar12;
  
  gp = &__global_pointer_;
  if ((__src < __dest) && (pvVar7 = (void *)((int)__src + __n), __dest < pvVar7)) {
    puVar8 = (undefined1 *)((int)__dest + __n);
    if (__n == 0) {
      return __dest;
    }
    do {
      puVar9 = (undefined1 *)((int)pvVar7 + -1);
      puVar8 = puVar8 + -1;
      pvVar7 = (void *)((int)pvVar7 + -1);
      *puVar8 = *puVar9;
    } while ((undefined1 *)__dest != puVar8);
    return __dest;
  }
  puVar3 = (undefined4 *)__src;
  uVar6 = __n;
  puVar8 = (undefined1 *)__dest;
  if (0xf < __n) {
    if ((((uint)__dest | (uint)__src) & 3) != 0) {
      iVar5 = __n - 1;
      goto LAB_10019dec;
    }
    puVar4 = (undefined4 *)__dest;
    do {
      puVar12 = puVar4 + 4;
      *puVar4 = *puVar3;
      puVar4[1] = puVar3[1];
      puVar4[2] = puVar3[2];
      puVar4[3] = puVar3[3];
      puVar3 = puVar3 + 4;
      puVar4 = puVar12;
    } while (puVar12 != (undefined4 *)((__n - 0x10 & 0xfffffff0) + 0x10 + (int)__dest));
    uVar11 = __n - 0x10 & 0xfffffff0;
    puVar3 = (undefined4 *)((int)__src + uVar11 + 0x10);
    puVar8 = (undefined1 *)((int)__dest + uVar11 + 0x10);
    uVar6 = __n & 0xf;
    if ((__n & 0xc) != 0) {
      uVar6 = (__n & 0xf) - 4 & 0xfffffffc;
      puVar4 = puVar3;
      do {
        uVar2 = *puVar4;
        puVar12 = (undefined4 *)((int)puVar4 + ((int)__dest - (int)__src));
        puVar4 = puVar4 + 1;
        *puVar12 = uVar2;
      } while (puVar4 != (undefined4 *)((int)__src + uVar6 + uVar11 + 0x14));
      iVar5 = uVar6 + 4;
      puVar3 = (undefined4 *)(iVar5 + (int)puVar3);
      uVar6 = __n & 3;
      puVar8 = puVar8 + iVar5;
    }
  }
  iVar5 = uVar6 - 1;
  __src = puVar3;
  if (uVar6 == 0) {
    return __dest;
  }
LAB_10019dec:
  puVar9 = puVar8;
  do {
                    // WARNING: Load size is inaccurate
    uVar1 = *__src;
    puVar10 = puVar9 + 1;
    __src = (void *)((int)__src + 1);
    *puVar9 = uVar1;
    puVar9 = puVar10;
  } while (puVar10 != puVar8 + iVar5 + 1);
  return __dest;
}



// WARNING: Unknown calling convention

int _fclose_r(_reent *rptr,FILE *fp)

{
  ushort uVar1;
  int iVar2;
  int iVar3;
  uchar *puVar4;
  
  gp = &__global_pointer_;
  if (fp != (FILE *)0x0) {
    if ((rptr != (_reent *)0x0) && (rptr->__cleanup == (_func_void__reent_ptr *)0x0)) {
      __sinit(rptr);
    }
    if ((fp->_flags2 & 1U) == 0) {
      if (((fp->_flags & 0x200U) != 0) ||
         (__retarget_lock_acquire_recursive(&fp->_lock), fp->_flags != 0)) {
LAB_10019ec2:
        iVar2 = __sflush_r(rptr,fp);
        if ((fp->_close == (_func_int__reent_ptr_void_ptr *)0x0) ||
           (iVar3 = (*fp->_close)(rptr,fp->_cookie), -1 < iVar3)) {
          uVar1 = fp->_flags;
        }
        else {
          uVar1 = fp->_flags;
          iVar2 = -1;
        }
        if ((uVar1 & 0x80) != 0) {
          _free_r(rptr,(fp->_bf)._base);
        }
        puVar4 = (fp->_ub)._base;
        if (puVar4 != (uchar *)0x0) {
          if (puVar4 != fp->_ubuf) {
            _free_r(rptr,puVar4);
          }
          (fp->_ub)._base = (uchar *)0x0;
        }
        puVar4 = (fp->_lb)._base;
        if (puVar4 != (uchar *)0x0) {
          _free_r(rptr,puVar4);
          (fp->_lb)._base = (uchar *)0x0;
        }
        __sfp_lock_acquire();
        fp->_flags = 0;
        if ((fp->_flags2 & 1U) == 0) {
          __retarget_lock_release_recursive(&fp->_lock);
        }
        __retarget_lock_close_recursive(&fp->_lock);
        __sfp_lock_release();
        return iVar2;
      }
      if ((fp->_flags2 & 1U) == 0) {
        __retarget_lock_release_recursive(&fp->_lock);
      }
    }
    else if (fp->_flags != 0) goto LAB_10019ec2;
  }
  return 0;
}



int fclose(FILE *__stream)

{
  _reent *rptr;
  int iVar1;
  
  gp = &__global_pointer_;
  rptr = __wrap___getreent();
  iVar1 = _fclose_r(rptr,(FILE *)__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)

{
  gp = &__global_pointer_;
  raise(6);
                    // WARNING: Subroutine does not return
  _exit(1);
}



// WARNING: Unknown calling convention

void * _calloc_r(_reent *reent_ptr,size_t n,size_t elem_size)

{
  undefined4 *__s;
  int *piVar1;
  uint __n;
  undefined4 *puVar2;
  
  gp = &__global_pointer_;
  if ((int)((ulonglong)n * (ulonglong)elem_size >> 0x20) != 0) {
    piVar1 = __errno();
    *piVar1 = 0xc;
    return (void *)0x0;
  }
  __s = (undefined4 *)_malloc_r(reent_ptr,n * elem_size);
  if (__s != (undefined4 *)0x0) {
    __n = (__s[-1] & 0xfffffffc) - 4;
    if (0x24 < __n) {
      memset(__s,0,__n);
      return __s;
    }
    puVar2 = __s;
    if (0x13 < __n) {
      *__s = 0;
      __s[1] = 0;
      if (__n < 0x1c) {
        __s[2] = 0;
        __s[3] = 0;
        __s[4] = 0;
        gp = &__global_pointer_;
        return __s;
      }
      __s[2] = 0;
      __s[3] = 0;
      puVar2 = __s + 4;
      if (__n == 0x24) {
        __s[4] = 0;
        __s[5] = 0;
        puVar2 = __s + 6;
      }
    }
    *puVar2 = 0;
    puVar2[1] = 0;
    puVar2[2] = 0;
    return __s;
  }
  gp = &__global_pointer_;
  return (void *)0x0;
}



void * realloc(void *__ptr,size_t __size)

{
  _reent *reent_ptr;
  void *pvVar1;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  pvVar1 = _realloc_r(reent_ptr,__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention

int _fiprintf_r(_reent *ptr,FILE *fp,char *fmt,...)

{
  int iVar1;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  gp = &__global_pointer_;
  uStack_14 = in_a3;
  uStack_10 = in_a4;
  uStack_c = in_a5;
  uStack_8 = in_a6;
  uStack_4 = in_a7;
  iVar1 = _vfiprintf_r(ptr,fp,fmt,&uStack_14);
  return iVar1;
}



// WARNING: Unknown calling convention

int fiprintf(FILE *fp,char *fmt,...)

{
  _reent *data;
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  gp = &__global_pointer_;
  uStack_18 = in_a2;
  uStack_14 = in_a3;
  uStack_10 = in_a4;
  uStack_c = in_a5;
  uStack_8 = in_a6;
  uStack_4 = in_a7;
  data = __wrap___getreent();
  iVar1 = _vfiprintf_r(data,fp,fmt,&uStack_18);
  return iVar1;
}



// WARNING: Unknown calling convention

void * _malloc_r(_reent *reent_ptr,size_t bytes)

{
  size_t *psVar1;
  mbinptr pmVar2;
  int iVar3;
  uint uVar4;
  mbinptr pmVar5;
  void *pvVar6;
  mbinptr pmVar7;
  int iVar8;
  malloc_chunk *pmVar9;
  uint uVar10;
  undefined4 *puVar11;
  size_t sVar12;
  malloc_chunk *pmVar13;
  uint uVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  mbinptr pmVar19;
  mbinptr pmVar20;
  
  gp = &__global_pointer_;
  uVar14 = bytes + 0xb;
  if (uVar14 < 0x17) {
    uVar4 = 0x10;
    if (0x10 < bytes) {
LAB_1001a260:
      reent_ptr->_errno = 0xc;
      return (void *)0x0;
    }
    __malloc_lock(reent_ptr);
    iVar15 = 0x18;
    uVar14 = 2;
LAB_1001a0f4:
    iVar3 = *(int *)((int)__malloc_av_ + iVar15 + 4);
    if (iVar3 != iVar15 + 0x20003ac0) {
LAB_1001a108:
      iVar8 = *(int *)(iVar3 + 0xc);
      iVar15 = *(int *)(iVar3 + 8);
      iVar16 = (*(uint *)(iVar3 + 4) & 0xfffffffc) + iVar3;
      uVar14 = *(uint *)(iVar16 + 4);
      *(int *)(iVar15 + 0xc) = iVar8;
      *(int *)(iVar8 + 8) = iVar15;
      *(uint *)(iVar16 + 4) = uVar14 | 1;
      __malloc_unlock(reent_ptr);
      return (void *)(iVar3 + 8);
    }
    iVar3 = *(int *)((int)__malloc_av_ + iVar15 + 0xc);
    uVar14 = uVar14 + 2;
    if ((int)__malloc_av_ + iVar15 != iVar3) goto LAB_1001a108;
  }
  else {
    uVar4 = uVar14 & 0xfffffff8;
    if (((int)uVar14 < 0) || (uVar4 < bytes)) goto LAB_1001a260;
    __malloc_lock(reent_ptr);
    if (uVar4 < 0x1f8) {
      uVar14 = uVar14 >> 3;
      iVar15 = uVar4 + 8;
      goto LAB_1001a0f4;
    }
    uVar10 = uVar14 >> 9;
    if (uVar10 == 0) {
      iVar15 = 0x200;
      uVar17 = 0x40;
      uVar10 = 0x3f;
    }
    else if (uVar10 < 5) {
      uVar17 = (uVar14 >> 6) + 0x39;
      uVar10 = (uVar14 >> 6) + 0x38;
      iVar15 = uVar17 * 8;
    }
    else if (uVar10 < 0x15) {
      uVar17 = uVar10 + 0x5c;
      uVar10 = uVar10 + 0x5b;
      iVar15 = uVar17 * 8;
    }
    else if (uVar10 < 0x55) {
      uVar17 = (uVar14 >> 0xc) + 0x6f;
      uVar10 = (uVar14 >> 0xc) + 0x6e;
      iVar15 = uVar17 * 8;
    }
    else if (uVar10 < 0x155) {
      uVar17 = (uVar14 >> 0xf) + 0x78;
      uVar10 = (uVar14 >> 0xf) + 0x77;
      iVar15 = uVar17 * 8;
    }
    else if (uVar10 < 0x555) {
      uVar17 = (uVar14 >> 0x12) + 0x7d;
      uVar10 = (uVar14 >> 0x12) + 0x7c;
      iVar15 = uVar17 * 8;
    }
    else {
      iVar15 = 0x3f8;
      uVar17 = 0x7f;
      uVar10 = 0x7e;
    }
    iVar3 = *(int *)((int)__malloc_av_ + iVar15 + 4);
    while (iVar8 = iVar3, uVar14 = uVar17, iVar15 + 0x20003ac0 != iVar8) {
      uVar18 = *(uint *)(iVar8 + 4) & 0xfffffffc;
      iVar16 = uVar18 - uVar4;
      uVar14 = uVar10;
      if (0xf < iVar16) break;
      iVar3 = *(int *)(iVar8 + 0xc);
      if (-1 < iVar16) {
        iVar15 = *(int *)(iVar8 + 8);
        iVar16 = uVar18 + iVar8;
        uVar14 = *(uint *)(iVar16 + 4);
        *(int *)(iVar15 + 0xc) = iVar3;
        *(int *)(iVar3 + 8) = iVar15;
        *(uint *)(iVar16 + 4) = uVar14 | 1;
        __malloc_unlock(reent_ptr);
        return (void *)(iVar8 + 8);
      }
    }
  }
  pmVar7 = __malloc_av_[4];
  pmVar5 = __malloc_av_[1];
  if (__malloc_av_[4] != (mbinptr)(__malloc_av_ + 2)) {
    uVar17 = __malloc_av_[4]->size;
    uVar18 = uVar17 & 0xfffffffc;
    uVar10 = uVar18 - uVar4;
    if (0xf < (int)uVar10) {
      __malloc_av_[4]->size = uVar4 | 1;
      pmVar5 = (mbinptr)((int)&__malloc_av_[4]->prev_size + uVar4);
      psVar1 = &__malloc_av_[4]->prev_size;
      __malloc_av_[4] = pmVar5;
      __malloc_av_[5] = pmVar5;
      pmVar5->bk = (malloc_chunk *)(__malloc_av_ + 2);
      pmVar5->fd = (malloc_chunk *)(__malloc_av_ + 2);
      pmVar5->size = uVar10 | 1;
      *(uint *)((int)psVar1 + uVar18) = uVar10;
      __malloc_unlock(reent_ptr);
      return &pmVar7->fd;
    }
    __malloc_av_[5] = (mbinptr)(__malloc_av_ + 2);
    __malloc_av_[4] = (mbinptr)(__malloc_av_ + 2);
    if (-1 < (int)uVar10) {
      *(uint *)((int)&pmVar7->size + uVar18) = *(uint *)((int)&pmVar7->size + uVar18) | 1;
      __malloc_unlock(reent_ptr);
      return &pmVar7->fd;
    }
    if (uVar18 < 0x200) {
      puVar11 = (undefined4 *)((int)__malloc_av_ + (uVar17 & 0xfffffff8) + 8);
      pmVar9 = (malloc_chunk *)*puVar11;
      pmVar5 = (mbinptr)((uint)__malloc_av_[1] | 1 << (uVar17 >> 5 & 0x1f));
      pmVar7->fd = pmVar9;
      pmVar7->bk = (malloc_chunk *)((int)__malloc_av_ + (uVar17 & 0xfffffff8));
      __malloc_av_[1] = pmVar5;
      *puVar11 = pmVar7;
      pmVar9->bk = pmVar7;
    }
    else {
      uVar10 = uVar17 >> 9;
      if (uVar10 < 5) {
        iVar15 = ((uVar17 >> 6) + 0x39) * 8;
        iVar3 = (uVar17 >> 6) + 0x38;
      }
      else if (uVar10 < 0x15) {
        iVar15 = (uVar10 + 0x5c) * 8;
        iVar3 = uVar10 + 0x5b;
      }
      else if (uVar10 < 0x55) {
        iVar15 = ((uVar17 >> 0xc) + 0x6f) * 8;
        iVar3 = (uVar17 >> 0xc) + 0x6e;
      }
      else if (uVar10 < 0x155) {
        iVar15 = ((uVar17 >> 0xf) + 0x78) * 8;
        iVar3 = (uVar17 >> 0xf) + 0x77;
      }
      else if (uVar10 < 0x555) {
        iVar15 = ((uVar17 >> 0x12) + 0x7d) * 8;
        iVar3 = (uVar17 >> 0x12) + 0x7c;
      }
      else {
        iVar15 = 0x3f8;
        iVar3 = 0x7e;
      }
      pmVar13 = *(malloc_chunk **)((int)__malloc_av_ + iVar15);
      pmVar9 = (malloc_chunk *)((int)&__sglue._niobs + iVar15);
      if (pmVar9 == pmVar13) {
        __malloc_av_[1] = (mbinptr)((uint)__malloc_av_[1] | 1 << (iVar3 >> 2 & 0x1fU));
      }
      else {
        do {
          if ((pmVar13->size & 0xfffffffc) <= uVar18) break;
          pmVar13 = pmVar13->fd;
        } while (pmVar9 != pmVar13);
        pmVar9 = pmVar13->bk;
      }
      pmVar5 = __malloc_av_[1];
      pmVar7->bk = pmVar9;
      pmVar7->fd = pmVar13;
      pmVar9->fd = pmVar7;
      pmVar13->bk = pmVar7;
    }
  }
  pmVar2 = __malloc_av_[2];
  pmVar7 = (mbinptr)(1 << ((int)uVar14 >> 2 & 0x1fU));
  if (pmVar7 <= pmVar5) {
    if (((uint)pmVar7 & (uint)pmVar5) == 0) {
      uVar14 = uVar14 & 0xfffffffc;
      do {
        pmVar7 = (mbinptr)((int)pmVar7 << 1);
        uVar14 = uVar14 + 4;
      } while (((uint)pmVar7 & (uint)pmVar5) == 0);
    }
    do {
      pmVar5 = (mbinptr)(__malloc_av_ + uVar14 * 2);
      pmVar20 = __malloc_av_[uVar14 * 2 + 3];
      uVar10 = uVar14;
      while( true ) {
        while (pmVar19 = pmVar20, pmVar5 != pmVar19) {
          pmVar20 = pmVar19->bk;
          uVar18 = pmVar19->size & 0xfffffffc;
          uVar17 = uVar18 - uVar4;
          if (0xf < (int)uVar17) {
            pmVar9 = pmVar19->fd;
            pmVar19->size = uVar4 | 1;
            pmVar9->bk = pmVar20;
            pmVar20->fd = pmVar9;
            pmVar5 = (mbinptr)((int)&pmVar19->prev_size + uVar4);
            __malloc_av_[4] = pmVar5;
            __malloc_av_[5] = pmVar5;
            pmVar5->bk = (malloc_chunk *)(__malloc_av_ + 2);
            pmVar5->fd = (malloc_chunk *)(__malloc_av_ + 2);
            pmVar5->size = uVar17 | 1;
            *(uint *)((int)&pmVar19->prev_size + uVar18) = uVar17;
            __malloc_unlock(reent_ptr);
            return &pmVar19->fd;
          }
          if (-1 < (int)uVar17) {
            pmVar9 = pmVar19->fd;
            *(uint *)((int)&pmVar19->size + uVar18) = *(uint *)((int)&pmVar19->size + uVar18) | 1;
            pmVar9->bk = pmVar20;
            pmVar20->fd = pmVar9;
            __malloc_unlock(reent_ptr);
            return &pmVar19->fd;
          }
        }
        uVar10 = uVar10 + 1;
        pmVar20 = (mbinptr)(__malloc_av_ + uVar14 * 2);
        if ((uVar10 & 3) == 0) break;
        pmVar20 = pmVar5 + 1;
        pmVar5 = (mbinptr)&pmVar5->fd;
        pmVar20 = (mbinptr)pmVar20->size;
      }
      do {
        pmVar5 = pmVar20 + -1;
        if ((uVar14 & 3) == 0) {
          __malloc_av_[1] = (mbinptr)(~(uint)pmVar7 & (uint)__malloc_av_[1]);
          break;
        }
        psVar1 = &pmVar20->prev_size;
        uVar14 = uVar14 - 1;
        pmVar20 = (mbinptr)&pmVar5->fd;
      } while ((mbinptr)*psVar1 == (mbinptr)&pmVar5->fd);
      pmVar7 = (mbinptr)((int)pmVar7 << 1);
      if ((__malloc_av_[1] < pmVar7) || (uVar14 = uVar10, pmVar7 == (mbinptr)0x0)) break;
      for (; ((uint)pmVar7 & (uint)__malloc_av_[1]) == 0; pmVar7 = (mbinptr)((int)pmVar7 << 1)) {
        uVar14 = uVar14 + 4;
      }
    } while( true );
  }
  uVar14 = __malloc_av_[2]->size & 0xfffffffc;
  if ((uVar4 <= uVar14) && (uVar10 = uVar14 - uVar4, pmVar5 = __malloc_av_[2], 0xf < (int)uVar10))
  goto LAB_1001a3ca;
  pmVar7 = (mbinptr)((int)&__malloc_av_[2]->prev_size + uVar14);
  if (__malloc_sbrk_base == (char *)0xffffffff) {
    uVar17 = __malloc_top_pad + uVar4 + 0x10;
  }
  else {
    uVar17 = __malloc_top_pad + uVar4 + 0x100f & 0xfffff000;
  }
  pmVar20 = (mbinptr)_sbrk_r(reent_ptr,uVar17);
  pmVar5 = __malloc_av_[2];
  if (pmVar20 == (mbinptr)0xffffffff) {
    uVar17 = __malloc_av_[2]->size;
  }
  else if (pmVar20 < pmVar7) {
    if (pmVar2 == (mbinptr)__malloc_av_) goto LAB_1001a2f6;
    uVar17 = __malloc_av_[2]->size;
  }
  else {
    sVar12 = __malloc_current_mallinfo.arena + uVar17;
    if ((pmVar7 == pmVar20) && (((uint)pmVar20 & 0xfff) == 0)) {
      uVar17 = uVar14 + uVar17 | 1;
      __malloc_current_mallinfo.arena = sVar12;
      __malloc_av_[2]->size = uVar17;
    }
    else {
LAB_1001a2f6:
      __malloc_current_mallinfo.arena = __malloc_current_mallinfo.arena + uVar17;
      pmVar5 = pmVar20;
      if (__malloc_sbrk_base != (char *)0xffffffff) {
        __malloc_current_mallinfo.arena =
             (int)pmVar20 + (__malloc_current_mallinfo.arena - (int)pmVar7);
        pmVar5 = (mbinptr)__malloc_sbrk_base;
      }
      __malloc_sbrk_base = (char *)pmVar5;
      uVar10 = (uint)pmVar20 & 7;
      if (uVar10 == 0) {
        uVar18 = ((int)&pmVar20->prev_size + uVar17) * -0x100000 >> 0x14;
        pvVar6 = _sbrk_r(reent_ptr,uVar18);
        if (pvVar6 != (void *)0xffffffff) goto LAB_1001a33a;
        uVar18 = 0;
        pmVar5 = pmVar20;
      }
      else {
        pmVar20 = (mbinptr)((int)pmVar20 + (8 - uVar10));
        iVar15 = (int)&pmVar20->prev_size + uVar17;
        uVar18 = (0x1008 - uVar10) - iVar15 & 0xfff;
        pvVar6 = _sbrk_r(reent_ptr,uVar18);
        if (pvVar6 == (void *)0xffffffff) {
          uVar17 = (iVar15 + (uVar10 - 8)) - (int)pmVar20;
          uVar18 = 0;
          pmVar5 = pmVar20;
        }
        else {
LAB_1001a33a:
          uVar17 = (int)pvVar6 + (uVar18 - (int)pmVar20);
          pmVar5 = pmVar20;
        }
      }
      uVar17 = uVar17 | 1;
      sVar12 = __malloc_current_mallinfo.arena + uVar18;
      __malloc_av_[2] = pmVar5;
      pmVar5->size = uVar17;
      __malloc_current_mallinfo.arena = sVar12;
      if (pmVar2 != (mbinptr)__malloc_av_) {
        if (uVar14 < 0x10) {
          pmVar5->size = 1;
          goto LAB_1001a5c4;
        }
        uVar14 = uVar14 - 0xc & 0xfffffff8;
        pmVar2->size = pmVar2->size & 1 | uVar14;
        *(undefined4 *)((int)&pmVar2->size + uVar14) = 5;
        *(undefined4 *)((int)&pmVar2->fd + uVar14) = 5;
        if (0xf < uVar14) {
          _free_r(reent_ptr,&pmVar2->fd);
          sVar12 = __malloc_current_mallinfo.arena;
          pmVar5 = __malloc_av_[2];
        }
        uVar17 = pmVar5->size;
      }
    }
    if (__malloc_max_sbrked_mem < sVar12) {
      __malloc_max_sbrked_mem = sVar12;
    }
    if (__malloc_max_total_mem < sVar12) {
      __malloc_max_total_mem = sVar12;
    }
  }
  uVar10 = (uVar17 & 0xfffffffc) - uVar4;
  if ((uVar4 <= (uVar17 & 0xfffffffc)) && (0xf < (int)uVar10)) {
LAB_1001a3ca:
    pmVar5->size = uVar4 | 1;
    __malloc_av_[2] = (mbinptr)((int)&pmVar5->prev_size + uVar4);
    __malloc_av_[2]->size = uVar10 | 1;
    __malloc_unlock(reent_ptr);
    return &pmVar5->fd;
  }
LAB_1001a5c4:
  __malloc_unlock(reent_ptr);
  return (void *)0x0;
}



// WARNING: Unknown calling convention

int quorem(_Bigint *b,_Bigint *S)

{
  __ULong *p_Var1;
  int iVar2;
  __ULong *p_Var3;
  __ULong *p_Var4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  __ULong *p_Var8;
  uint uVar9;
  __ULong *p_Var10;
  __ULong *p_Var11;
  uint uVar12;
  
  gp = &__global_pointer_;
  if (b->_wds < S->_wds) {
    return 0;
  }
  iVar2 = S->_wds + -1;
  p_Var1 = S->_x;
  p_Var10 = p_Var1 + iVar2;
  p_Var11 = b->_x;
  p_Var4 = p_Var11 + iVar2;
  uVar9 = *p_Var4 / (*p_Var10 + 1);
  if (*p_Var10 + 1 <= *p_Var4) {
    uVar12 = 0;
    iVar6 = 0;
    p_Var3 = p_Var11;
    p_Var8 = p_Var1;
    do {
      uVar7 = *p_Var8;
      p_Var8 = p_Var8 + 1;
      uVar12 = (uVar7 & 0xffff) * uVar9 + uVar12;
      uVar5 = ((*p_Var3 & 0xffff) - (uVar12 & 0xffff)) + iVar6;
      uVar7 = (uVar7 >> 0x10) * uVar9 + (uVar12 >> 0x10);
      uVar12 = uVar7 >> 0x10;
      iVar6 = (((int)uVar5 >> 0x10) - (uVar7 & 0xffff)) + (*p_Var3 >> 0x10);
      *p_Var3 = iVar6 * 0x10000 | uVar5 & 0xffff;
      iVar6 = iVar6 >> 0x10;
      p_Var3 = p_Var3 + 1;
    } while (p_Var8 <= p_Var10);
    if (*p_Var4 == 0) {
      while ((p_Var4 = p_Var4 + -1, p_Var11 < p_Var4 && (*p_Var4 == 0))) {
        iVar2 = iVar2 + -1;
      }
      b->_wds = iVar2;
    }
  }
  iVar6 = __mcmp(b,S);
  if (-1 < iVar6) {
    iVar6 = 0;
    p_Var4 = p_Var11;
    do {
      uVar12 = ((*p_Var4 & 0xffff) - (*p_Var1 & 0xffff)) + iVar6;
      iVar6 = (((int)uVar12 >> 0x10) - (*p_Var1 >> 0x10)) + (*p_Var4 >> 0x10);
      p_Var1 = p_Var1 + 1;
      *p_Var4 = uVar12 & 0xffff | iVar6 * 0x10000;
      iVar6 = iVar6 >> 0x10;
      p_Var4 = p_Var4 + 1;
    } while (p_Var1 <= p_Var10);
    p_Var4 = p_Var11 + iVar2;
    if (*p_Var4 == 0) {
      while ((p_Var4 = p_Var4 + -1, p_Var11 < p_Var4 && (*p_Var4 == 0))) {
        iVar2 = iVar2 + -1;
      }
      b->_wds = iVar2;
    }
    uVar9 = uVar9 + 1;
  }
  return uVar9;
}



char * _dtoa_r(_reent *ptr,double _d,int mode,int ndigits,int *decpt,int *sign,char **rve)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  _mprec *p_Var4;
  __gcc_CMPtype _Var5;
  USItype i;
  char *pcVar6;
  _Bigint *p_Var7;
  int iVar8;
  _Bigint *p_Var9;
  _Bigint *p_Var10;
  char cVar11;
  uint uVar12;
  int iVar13;
  int *piVar14;
  uint uVar15;
  char *pcVar16;
  uint *in_a6;
  undefined4 *in_a7;
  int iVar17;
  SItype SVar18;
  char *pcVar19;
  _Bigint *p_Var20;
  int *piVar21;
  undefined1 *puVar22;
  _Bigint *b;
  char *pcVar23;
  int *piVar24;
  _Bigint *p_Var25;
  _Bigint *p_Stack_1f4;
  int *piStack_1e8;
  undefined1 *puStack_1d8;
  char *pcStack_1d0;
  _Bigint *p_Stack_19c;
  int *piStack_198;
  int *piStack_190;
  char *pcStack_160;
  int iStack_48;
  int bbits;
  int be;
  
  gp = &__global_pointer_;
  p_Var4 = ptr->_mp;
  if (p_Var4 == (_mprec *)0x0) {
    p_Var4 = (_mprec *)__wrap_malloc(0x10);
    ptr->_mp = p_Var4;
    if (p_Var4 == (_mprec *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/dtoa.c",0xef,(char *)0x0,
                    "REENT malloc succeeded");
    }
    p_Var4->_result_k = 0;
    p_Var4->_p5s = (_Bigint *)0x0;
    p_Var4->_result = (_Bigint *)0x0;
    p_Var4->_freelist = (_Bigint **)0x0;
  }
  else {
    p_Var10 = p_Var4->_result;
    if (p_Var10 != (_Bigint *)0x0) {
      uVar12 = p_Var4->_result_k;
      p_Var10->_maxwds = 1 << (uVar12 & 0x1f);
      p_Var10->_k = uVar12;
      _Bfree(ptr,p_Var10);
      ptr->_mp->_result = (_Bigint *)0x0;
    }
  }
  bVar1 = ndigits < 0;
  if (bVar1) {
    ndigits = ndigits & 0x7fffffff;
  }
  *in_a6 = (uint)bVar1;
  if ((ndigits & 0x7ff00000U) == 0x7ff00000) {
    *rve = (char *)0x270f;
    if ((ndigits & 0xfffffU) == 0 && mode == 0) {
      if (in_a7 == (undefined4 *)0x0) {
        return "Infinity";
      }
      pcVar19 = "Infinity";
      pcVar6 = "";
    }
    else {
      if (in_a7 == (undefined4 *)0x0) {
        return "NaN";
      }
      pcVar19 = "NaN";
      pcVar6 = "";
    }
    *in_a7 = pcVar6;
    return pcVar19;
  }
  _Var5 = __eqdf2(_d,DRam00000018);
  if (_Var5 == 0) {
    *rve = &DAT_00000001;
    if (in_a7 != (undefined4 *)0x0) {
      *in_a7 = &DAT_10022569;
    }
    return "0";
  }
  p_Stack_1f4 = __d2b(ptr,_d,(int *)mode,(int *)ndigits);
  if ((uint)ndigits >> 0x14 == 0) {
    iVar17 = bbits + iStack_48;
    iVar13 = iVar17 + 0x432;
    if (iVar13 < 0x21) {
      i = mode << (0x20U - iVar13 & 0x1f);
    }
    else {
      i = (uint)mode >> (iVar17 + 0x412U & 0x1f) | ndigits << (0x40U - iVar13 & 0x1f);
    }
    __floatunsidf(i);
    SVar18 = iVar17 + -1;
    p_Stack_19c = (_Bigint *)&DAT_00000001;
  }
  else {
    SVar18 = ((uint)ndigits >> 0x14) - 0x3ff;
    p_Stack_19c = (_Bigint *)0x0;
  }
  __subdf3(_d,DRam00000018);
  __muldf3(_d,DRam00000018);
  __adddf3(_d,DRam00000018);
  __floatsidf(SVar18);
  __muldf3(_d,DRam00000018);
  __adddf3(_d,DRam00000018);
  pcVar6 = (char *)__fixdfsi(_d);
  _Var5 = __ledf2(_d,DRam00000018);
  if (_Var5 < 0) {
    __floatsidf((SItype)pcVar6);
    _Var5 = __eqdf2(_d,DRam00000018);
    pcVar6 = pcVar6 + -(uint)(_Var5 != 0);
  }
  iVar13 = iStack_48 - SVar18;
  pcVar19 = (char *)(iVar13 + -1);
  if (pcVar6 < (char *)0x17) {
    _Var5 = __ledf2(_d,DRam00000018);
    if (_Var5 < 0) {
      pcVar6 = pcVar6 + -1;
      bVar1 = false;
      goto LAB_1001aae4;
    }
    pcStack_1d0 = pcVar6;
    if (iVar13 < 1) {
      piVar21 = (int *)(1 - iVar13);
      bVar1 = false;
      pcVar19 = pcVar6;
    }
    else {
      bVar1 = false;
      piVar21 = (int *)0x0;
      pcVar19 = pcVar19 + (int)pcVar6;
    }
LAB_1001aa58:
    puStack_1d8 = (undefined1 *)0x0;
    p_Var4 = ptr->_mp;
    pcVar6 = pcStack_1d0;
    if ((int *)0x9 < decpt) goto LAB_1001ab02;
LAB_1001aa62:
    pcVar23 = (char *)piVar21;
    if ((int)decpt < 6) {
      if (decpt == (int *)0x4) {
        bVar2 = true;
        bVar3 = true;
        goto LAB_1001b648;
      }
      if (decpt == (int *)0x5) {
        bVar2 = true;
        bVar3 = true;
        goto LAB_1001acce;
      }
      if (decpt == (int *)0x2) {
        bVar2 = true;
        goto LAB_1001b646;
      }
      bVar3 = false;
      bVar2 = true;
      if (decpt == (int *)0x3) goto LAB_1001acce;
      goto LAB_1001ab04;
    }
    decpt = decpt + -1;
    if (decpt == (int *)0x4) {
      bVar2 = false;
      bVar3 = true;
LAB_1001b648:
      piVar24 = sign;
      piVar14 = sign;
      piStack_198 = sign;
      if (0 < (int)sign) goto LAB_1001ace0;
      p_Var4->_result_k = 0;
      p_Var10 = _Balloc(ptr,0);
      if (p_Var10 == (_Bigint *)0x0) goto LAB_1001bb1a;
      piVar14 = (int *)&DAT_00000001;
      piStack_198 = (int *)&DAT_00000001;
      ptr->_mp->_result = p_Var10;
      piStack_1e8 = (int *)&DAT_00000001;
LAB_1001ad10:
      if (!bVar2) goto LAB_1001ad14;
      if ((int)pcVar6 < 1) {
        if (pcVar6 == (char *)0x0) {
          iVar13 = 2;
        }
        else {
          uVar12 = -(int)pcVar6 >> 4;
          __muldf3(_d,DRam00000018);
          if (uVar12 == 0) {
            iVar13 = 2;
          }
          else {
            iVar13 = 2;
            do {
              do {
                uVar15 = uVar12 & 1;
                uVar12 = (int)uVar12 >> 1;
              } while (uVar15 == 0);
              iVar13 = iVar13 + 1;
              __muldf3(_d,DRam00000018);
            } while (uVar12 != 0);
          }
        }
      }
      else {
        uVar12 = (int)pcVar6 >> 4;
        if ((uVar12 & 0x10) == 0) {
          iVar13 = 2;
        }
        else {
          uVar12 = uVar12 & 0xf;
          iVar13 = 3;
          __divdf3(_d,DRam00000018);
        }
        while (uVar12 != 0) {
          do {
            uVar15 = uVar12 & 1;
            uVar12 = (int)uVar12 >> 1;
          } while (uVar15 == 0);
          iVar13 = iVar13 + 1;
          __muldf3(_d,DRam00000018);
        }
        __divdf3(_d,DRam00000018);
      }
      if ((bVar1) && (_Var5 = __ledf2(_d,DRam00000018), _Var5 < 0)) {
        if (piVar14 == (int *)0x0) {
          __floatsidf(iVar13);
          __muldf3(_d,DRam00000018);
          __adddf3(_d,DRam00000018);
          goto LAB_1001b59a;
        }
        if (0 < (int)piStack_198) {
          __muldf3(_d,DRam00000018);
          __floatsidf(iVar13 + 1);
          __muldf3(_d,DRam00000018);
          __adddf3(_d,DRam00000018);
          piStack_190 = piStack_198;
          pcStack_160 = pcVar6 + -1;
          goto LAB_1001b0fc;
        }
        goto LAB_1001ad14;
      }
      __floatsidf(iVar13);
      __muldf3(_d,DRam00000018);
      __adddf3(_d,DRam00000018);
      piStack_190 = piVar14;
      pcStack_160 = pcVar6;
      if (piVar14 == (int *)0x0) {
LAB_1001b59a:
        __subdf3(_d,DRam00000018);
        _Var5 = __gedf2(_d,DRam00000018);
        if (0 < _Var5) goto LAB_1001ad86;
        _Var5 = __ledf2(_d,DRam00000018);
        p_Stack_19c = p_Var10;
        if (-1 < _Var5) goto LAB_1001ad14;
        goto LAB_1001b5f4;
      }
LAB_1001b0fc:
      SVar18 = __fixdfsi(_d);
      cVar11 = (char)SVar18 + '0';
      __floatsidf(SVar18);
      p_Stack_19c = (_Bigint *)((int)&p_Var10->_next + 1);
      __subdf3(_d,DRam00000018);
      p_Var20 = p_Stack_19c;
      if (bVar3) {
        __divdf3(_d,DRam00000018);
        __subdf3(_d,DRam00000018);
        *(char *)&p_Var10->_next = cVar11;
        _Var5 = __gedf2(_d,DRam00000018);
        if (_Var5 < 1) {
          iVar13 = 0;
          do {
            __subdf3(_d,DRam00000018);
            _Var5 = __ledf2(_d,DRam00000018);
            if (_Var5 < 0) {
              pcVar6 = pcStack_160 + 1;
              goto LAB_1001b2b4;
            }
            iVar13 = iVar13 + 1;
            if ((int)piStack_190 <= iVar13) {
              if ((bbits < 0) || (0xe < (int)pcVar6)) goto LAB_1001b4de;
              goto LAB_1001ad2e;
            }
            p_Stack_19c = (_Bigint *)((int)&p_Var20->_next + 1);
            __muldf3(_d,DRam00000018);
            __muldf3(_d,DRam00000018);
            SVar18 = __fixdfsi(_d);
            __floatsidf(SVar18);
            __subdf3(_d,DRam00000018);
            *(char *)&p_Var20->_next = (char)SVar18 + '0';
            _Var5 = __ledf2(_d,DRam00000018);
            p_Var20 = p_Stack_19c;
          } while (-1 < _Var5);
        }
        pcVar6 = pcStack_160 + 1;
        goto LAB_1001ad9c;
      }
      __muldf3(_d,DRam00000018);
      *(char *)&p_Var10->_next = cVar11;
      if (piStack_190 != (int *)&DAT_00000001) {
        do {
          p_Var9 = (_Bigint *)((int)&p_Var20->_next + 1);
          __muldf3(_d,DRam00000018);
          SVar18 = __fixdfsi(_d);
          __floatsidf(SVar18);
          __subdf3(_d,DRam00000018);
          *(char *)&p_Var20->_next = (char)SVar18 + '0';
          p_Var20 = p_Var9;
        } while ((_Bigint *)((int)piStack_190 + (int)(p_Var10->_x + -5)) != p_Var9);
        p_Var20 = (_Bigint *)((int)piStack_190 + (int)(p_Var10->_x + -5));
      }
      __adddf3(_d,DRam00000018);
      _Var5 = __ledf2(_d,DRam00000018);
      if (-1 < _Var5) {
        __subdf3(_d,DRam00000018);
        _Var5 = __gedf2(_d,DRam00000018);
        if (0 < _Var5) {
          do {
            p_Stack_19c = p_Var20;
            p_Var20 = (_Bigint *)((int)p_Stack_19c[-1]._x + 3);
          } while (*(char *)((int)p_Stack_19c[-1]._x + 3) == '0');
          pcVar6 = pcStack_160 + 1;
          goto LAB_1001ad9c;
        }
        if ((bbits < 0) || (0xe < (int)pcVar6)) goto LAB_1001b46c;
        goto LAB_1001b820;
      }
      pcVar6 = pcStack_160 + 1;
      goto LAB_1001b2b4;
    }
    if (decpt == (int *)0x5) {
      bVar2 = false;
      bVar3 = true;
    }
    else {
      bVar2 = false;
      if (decpt == (int *)0x2) {
LAB_1001b646:
        bVar3 = false;
        goto LAB_1001b648;
      }
      decpt = (int *)0x3;
      bVar3 = false;
    }
LAB_1001acce:
    piStack_198 = (int *)((int)sign + (int)pcVar6);
    piVar14 = (int *)((int)piStack_198 + 1);
    piVar24 = piVar14;
    if ((int)piVar14 < 1) {
      piVar24 = (int *)&DAT_00000001;
    }
LAB_1001ace0:
    iVar17 = 4;
    iVar13 = 1;
    if ((int)piVar24 < 0x18) {
      p_Var4->_result_k = 0;
      iVar8 = 0;
    }
    else {
      do {
        iVar8 = iVar13;
        iVar17 = iVar17 * 2;
        iVar13 = iVar8 + 1;
      } while ((int *)(iVar17 + 0x14) <= piVar24);
      p_Var4->_result_k = iVar8;
    }
    p_Var10 = _Balloc(ptr,iVar8);
    if (p_Var10 == (_Bigint *)0x0) goto LAB_1001bb1a;
    ptr->_mp->_result = p_Var10;
    piStack_1e8 = sign;
    if (piVar14 < (int *)0xf) goto LAB_1001ad10;
LAB_1001ad14:
    if ((-1 < bbits) && ((int)pcVar6 < 0xf)) {
LAB_1001ad2e:
      if (((int)piStack_1e8 < 0) && ((int)piVar14 < 1)) {
        p_Stack_19c = p_Var10;
        if (piVar14 == (int *)0x0) {
          __muldf3(_d,DRam00000018);
          _Var5 = __ledf2(_d,DRam00000018);
          if (0 < _Var5) {
LAB_1001ad86:
            *(char *)&p_Var10->_next = '1';
            p_Stack_19c = (_Bigint *)((int)&p_Var10->_next + 1);
            _Bfree(ptr,(_Bigint *)0x0);
            pcVar6 = pcVar6 + 2;
            goto LAB_1001ad9c;
          }
        }
LAB_1001b5f4:
        _Bfree(ptr,(_Bigint *)0x0);
        pcVar6 = (char *)-(int)piStack_1e8;
        p_Var10 = p_Stack_19c;
        goto LAB_1001ad9c;
      }
      p_Stack_19c = (_Bigint *)((int)&p_Var10->_next + 1);
LAB_1001b820:
      __divdf3(_d,DRam00000018);
      uVar12 = __fixdfsi(_d);
      __floatsidf(uVar12);
      __muldf3(_d,DRam00000018);
      __subdf3(_d,DRam00000018);
      *(char *)&p_Var10->_next = (char)uVar12 + '0';
      if (piVar14 != (int *)&DAT_00000001) goto LAB_1001ae58;
      goto LAB_1001b7b2;
    }
    if (bVar3) {
LAB_1001b4de:
      p_Stack_19c = (_Bigint *)piStack_1e8;
      puVar22 = (undefined1 *)((int)piVar14 + -1);
      if ((int)puVar22 <= (int)puStack_1d8) {
        puVar22 = puStack_1d8 + -(int)puVar22;
        piVar24 = piVar14;
        if (-1 < (int)piVar14) goto LAB_1001ab42;
        p_Var20 = __i2b(ptr,1);
        pcVar23 = (char *)((int)piVar21 + -(int)piVar14);
        piStack_1e8 = piVar21;
        goto LAB_1001b632;
      }
      pcStack_1d0 = pcStack_1d0 + ((int)puVar22 - (int)puStack_1d8);
      piStack_1e8 = (int *)((int)piVar21 + (int)piVar14);
      p_Var20 = __i2b(ptr,1);
      pcVar19 = pcVar19 + (int)piVar14;
      puStack_1d8 = puVar22;
      if (piVar21 == (int *)0x0) {
        pcVar23 = (char *)0x0;
      }
      else {
        pcVar16 = (char *)piVar21;
        if ((int)pcVar19 < (int)piVar21) {
          pcVar16 = pcVar19;
        }
        piStack_1e8 = (int *)((char *)((int)piVar21 + (int)piVar14) + -(int)pcVar16);
        pcVar23 = (char *)((int)piVar21 + -(int)pcVar16);
        pcVar19 = pcVar19 + -(int)pcVar16;
      }
      goto LAB_1001afc6;
    }
LAB_1001b46c:
    p_Stack_19c = (_Bigint *)piStack_1e8;
    if (piVar21 != (int *)0x0) {
      if (pcVar19 != (char *)0x0) {
        if ((int)pcVar19 < (int)piVar21) {
          pcVar23 = pcVar19;
        }
        piVar21 = (int *)((int)piVar21 + -(int)pcVar23);
        pcVar19 = pcVar19 + -(int)pcVar23;
      }
      if (puStack_1d8 == (undefined1 *)0x0) {
        p_Var9 = __i2b(ptr,1);
        p_Var20 = (_Bigint *)0x0;
        pcVar23 = (char *)piVar21;
        if (pcStack_1d0 == (char *)0x0) {
          iVar13 = 1;
          goto LAB_1001ab9e;
        }
      }
      else {
LAB_1001b710:
        p_Stack_1f4 = __pow5mult(ptr,p_Stack_1f4,(int)puStack_1d8);
        p_Var9 = __i2b(ptr,1);
        pcVar23 = (char *)piVar21;
        if (pcStack_1d0 == (char *)0x0) {
          puStack_1d8 = (undefined1 *)0x0;
          p_Var20 = (_Bigint *)0x0;
          iVar13 = 1;
          goto LAB_1001ab9e;
        }
        puStack_1d8 = (undefined1 *)0x0;
        p_Var20 = (_Bigint *)0x0;
      }
      goto LAB_1001b492;
    }
    if (puStack_1d8 != (undefined1 *)0x0) goto LAB_1001b710;
    p_Var9 = __i2b(ptr,1);
    p_Var20 = (_Bigint *)0x0;
    pcVar23 = (char *)0x0;
    if (pcStack_1d0 != (char *)0x0) goto LAB_1001b492;
    iVar13 = 1;
    p_Var20 = (_Bigint *)0x0;
    pcVar23 = (char *)0x0;
  }
  else {
    bVar1 = true;
LAB_1001aae4:
    piVar21 = (int *)0x0;
    if ((int)pcVar19 < 0) {
      piVar21 = (int *)(1 - iVar13);
      pcVar19 = (char *)0x0;
    }
    if (-1 < (int)pcVar6) {
      pcVar19 = pcVar19 + (int)pcVar6;
      pcStack_1d0 = pcVar6;
      goto LAB_1001aa58;
    }
    puStack_1d8 = (undefined1 *)-(int)pcVar6;
    pcStack_1d0 = (char *)0x0;
    p_Var4 = ptr->_mp;
    piVar21 = (int *)((int)piVar21 + -(int)pcVar6);
    if (decpt < (int *)0xa) goto LAB_1001aa62;
LAB_1001ab02:
    decpt = (int *)0x0;
    pcVar23 = (char *)piVar21;
LAB_1001ab04:
    p_Var4->_result_k = 0;
    p_Var10 = _Balloc(ptr,0);
    if (p_Var10 == (_Bigint *)0x0) {
LAB_1001bb1a:
                    // WARNING: Subroutine does not return
      __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/dtoa.c",0x1af,(char *)0x0,
                    "Balloc succeeded");
    }
    ptr->_mp->_result = p_Var10;
    if ((-1 < bbits) && ((int)pcVar6 < 0xf)) {
      __divdf3(_d,DRam00000018);
      SVar18 = __fixdfsi(_d);
      __floatsidf(SVar18);
      __muldf3(_d,DRam00000018);
      p_Stack_19c = (_Bigint *)((int)&p_Var10->_next + 1);
      __subdf3(_d,DRam00000018);
      piVar14 = (int *)0xffffffff;
      *(char *)&p_Var10->_next = (char)SVar18 + '0';
LAB_1001ae58:
      piVar21 = (int *)&DAT_00000001;
      do {
        __muldf3(_d,DRam00000018);
        _Var5 = __eqdf2(_d,DRam00000018);
        if (_Var5 == 0) {
          pcVar6 = pcVar6 + 1;
          goto LAB_1001ad9c;
        }
        __divdf3(_d,DRam00000018);
        uVar12 = __fixdfsi(_d);
        __floatsidf(uVar12);
        p_Var20 = (_Bigint *)((int)&p_Stack_19c->_next + 1);
        piVar21 = (int *)((int)piVar21 + 1);
        __muldf3(_d,DRam00000018);
        __subdf3(_d,DRam00000018);
        *(char *)&p_Stack_19c->_next = (char)uVar12 + '0';
        p_Stack_19c = p_Var20;
      } while (piVar21 != piVar14);
LAB_1001b7b2:
      pcVar6 = pcVar6 + 1;
      __adddf3(_d,DRam00000018);
      _Var5 = __gedf2(_d,DRam00000018);
      p_Var20 = p_Stack_19c;
      if ((_Var5 < 1) && ((_Var5 = __eqdf2(_d,DRam00000018), _Var5 != 0 || ((uVar12 & 1) == 0))))
      goto LAB_1001ad9c;
LAB_1001b2b4:
      do {
        p_Stack_19c = p_Var20;
        cVar11 = *(char *)((int)p_Stack_19c[-1]._x + 3);
        p_Var20 = (_Bigint *)((int)p_Stack_19c[-1]._x + 3);
        if (cVar11 != '9') {
          cVar11 = cVar11 + '\x01';
          goto LAB_1001b2c6;
        }
      } while (p_Var20 != p_Var10);
      pcVar6 = pcVar6 + 1;
      cVar11 = '1';
LAB_1001b2c6:
      *(char *)&p_Var20->_next = cVar11;
      goto LAB_1001ad9c;
    }
    puVar22 = puStack_1d8;
    if (p_Stack_19c == (_Bigint *)0x0) {
      piVar24 = (int *)0xffffffff;
      piStack_198 = (int *)0xffffffff;
      piVar14 = (int *)(0x36 - iStack_48);
    }
    else {
      piVar24 = (int *)0xffffffff;
      piStack_198 = (int *)0xffffffff;
      piVar14 = (int *)(bbits + 0x433);
      p_Stack_19c = (_Bigint *)0x0;
    }
LAB_1001ab42:
    piStack_1e8 = (int *)(pcVar23 + (int)piVar14);
    pcVar19 = pcVar19 + (int)piVar14;
    p_Var20 = __i2b(ptr,1);
    if (pcVar23 == (char *)0x0) {
      pcVar23 = (char *)0x0;
      piVar14 = piVar24;
    }
    else {
LAB_1001b632:
      piVar14 = piVar24;
      if (0 < (int)pcVar19) {
        pcVar16 = pcVar23;
        if ((int)pcVar19 < (int)pcVar23) {
          pcVar16 = pcVar19;
        }
        pcVar23 = pcVar23 + -(int)pcVar16;
        pcVar19 = pcVar19 + -(int)pcVar16;
        piStack_1e8 = (int *)((int)piStack_1e8 + -(int)pcVar16);
      }
    }
    if (puStack_1d8 != (undefined1 *)0x0) {
      if (puVar22 != (undefined1 *)0x0) {
        p_Var20 = __pow5mult(ptr,p_Var20,(int)puVar22);
        p_Var9 = __multiply(ptr,p_Var20,p_Stack_1f4);
        _Bfree(ptr,p_Stack_1f4);
        puStack_1d8 = puStack_1d8 + -(int)puVar22;
        p_Stack_1f4 = p_Var9;
        if (puStack_1d8 == (undefined1 *)0x0) goto LAB_1001ab62;
      }
LAB_1001afc6:
      p_Stack_1f4 = __pow5mult(ptr,p_Stack_1f4,(int)puStack_1d8);
    }
LAB_1001ab62:
    p_Var9 = __i2b(ptr,1);
    piVar21 = piStack_1e8;
    if (pcStack_1d0 == (char *)0x0) {
      iVar13 = 1;
      if ((((int)decpt < 2) && (mode == 0)) &&
         (((ndigits & 0xfffffU) == 0 && (((uint)ndigits >> 0x14 & 0x7ff) != 0)))) {
        pcStack_1d0 = &DAT_00000001;
        pcVar19 = pcVar19 + 1;
        puStack_1d8 = (undefined1 *)0x1;
        piVar21 = (int *)((int)piStack_1e8 + 1);
      }
      else {
        puStack_1d8 = (undefined1 *)0x1;
      }
    }
    else {
      puStack_1d8 = (undefined1 *)0x1;
LAB_1001b492:
      p_Var9 = __pow5mult(ptr,p_Var9,(int)pcStack_1d0);
      pcStack_1d0 = (char *)0x0;
      if (((((int)decpt < 2) && (mode == 0)) && ((ndigits & 0xfffffU) == 0)) &&
         (((uint)ndigits >> 0x14 & 0x7ff) != 0)) {
        piVar21 = (int *)((int)piVar21 + 1);
        pcVar19 = pcVar19 + 1;
        pcStack_1d0 = &DAT_00000001;
      }
      iVar13 = __hi0bits(p_Var9->_x[p_Var9->_wds + -1]);
      iVar13 = 0x20 - iVar13;
    }
  }
LAB_1001ab9e:
  uVar12 = (uint)(pcVar19 + iVar13) & 0x1f;
  if (uVar12 == 0) {
    iVar13 = 0x1c;
LAB_1001afd8:
    piVar21 = (int *)((int)piVar21 + iVar13);
    pcVar23 = pcVar23 + iVar13;
    pcVar19 = pcVar19 + iVar13;
  }
  else if ((int)(0x20 - uVar12) < 5) {
    if (0x20 - uVar12 != 4) {
      iVar13 = 0x3c - uVar12;
      goto LAB_1001afd8;
    }
  }
  else {
    iVar13 = 0x1c - uVar12;
    piVar21 = (int *)((int)piVar21 + iVar13);
    pcVar23 = pcVar23 + iVar13;
    pcVar19 = pcVar19 + iVar13;
  }
  if (0 < (int)piVar21) {
    p_Stack_1f4 = __lshift(ptr,p_Stack_1f4,(int)piVar21);
  }
  if (0 < (int)pcVar19) {
    p_Var9 = __lshift(ptr,p_Var9,(int)pcVar19);
  }
  if ((bVar1) && (iVar13 = __mcmp(p_Stack_1f4,p_Var9), iVar13 < 0)) {
    p_Stack_1f4 = __multadd(ptr,p_Stack_1f4,10,0);
    pcVar19 = pcVar6 + -1;
    if (puStack_1d8 == (undefined1 *)0x0) {
      if ((0 < (int)piStack_198) || ((int)decpt < 3)) goto LAB_1001abe4;
    }
    else {
      p_Var20 = __multadd(ptr,p_Var20,10,0);
      if ((0 < (int)piStack_198) || ((int)decpt < 3)) {
LAB_1001b2f2:
        b = p_Var20;
        if (0 < (int)pcVar23) {
          b = __lshift(ptr,p_Var20,(int)pcVar23);
        }
        p_Var20 = b;
        if (pcStack_1d0 != (char *)0x0) {
          p_Var20 = _Balloc(ptr,b->_k);
          if (p_Var20 == (_Bigint *)0x0) {
                    // WARNING: Subroutine does not return
            __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/dtoa.c",0x2ef,(char *)0x0,
                          "Balloc succeeded");
          }
          memcpy(&p_Var20->_sign,&b->_sign,(b->_wds + 2) * 4);
          p_Var20 = __lshift(ptr,p_Var20,1);
        }
        p_Var25 = p_Var10;
        while( true ) {
          iVar13 = quorem(p_Stack_1f4,p_Var9);
          iVar17 = __mcmp(p_Stack_1f4,b);
          p_Var7 = __mdiff(ptr,p_Var9,p_Var20);
          uVar12 = iVar13 + 0x30;
          if (p_Var7->_sign != 0) break;
          iVar8 = __mcmp(p_Stack_1f4,p_Var7);
          _Bfree(ptr,p_Var7);
          if (iVar8 == 0 && decpt == (int *)0x0) {
            if ((mode & 1U) == 0) {
              if (uVar12 == 0x39) goto LAB_1001b404;
              if (0 < iVar17) goto LAB_1001b3f0;
              goto LAB_1001b3f4;
            }
            if (iVar17 < 0) goto LAB_1001b3f4;
          }
          else {
            if ((iVar17 < 0) || ((mode & 1U) == 0 && (iVar17 == 0 && decpt == (int *)0x0))) {
              if (0 < iVar8) goto LAB_1001b3d2;
              goto LAB_1001b3f4;
            }
            if (0 < iVar8) goto LAB_1001b444;
          }
          *(char *)&p_Var25->_next = (char)uVar12;
          p_Var7 = (_Bigint *)((int)&p_Var25->_next + 1);
          if ((_Bigint *)((undefined1 *)((int)p_Var10[-1]._x + 3) + (int)piStack_198) == p_Var25) {
            pcVar6 = pcVar19 + 1;
            goto LAB_1001ac24;
          }
          p_Stack_1f4 = __multadd(ptr,p_Stack_1f4,10,0);
          p_Var25 = p_Var7;
          if (b == p_Var20) {
            b = __multadd(ptr,b,10,0);
            p_Var20 = b;
          }
          else {
            b = __multadd(ptr,b,10,0);
            p_Var20 = __multadd(ptr,p_Var20,10,0);
          }
        }
        _Bfree(ptr,p_Var7);
        if ((iVar17 < 0) || ((mode & 1U) == 0 && (iVar17 == 0 && decpt == (int *)0x0))) {
LAB_1001b3d2:
          p_Stack_1f4 = __lshift(ptr,p_Stack_1f4,1);
          iVar17 = __mcmp(p_Stack_1f4,p_Var9);
          if ((0 < iVar17) || ((iVar17 == 0 && ((uVar12 & 1) != 0)))) {
            if (uVar12 == 0x39) goto LAB_1001b404;
LAB_1001b3f0:
            uVar12 = iVar13 + 0x31;
          }
LAB_1001b3f4:
          *(char *)&p_Var25->_next = (char)uVar12;
          pcVar6 = pcVar19 + 1;
          p_Stack_19c = (_Bigint *)((int)&p_Var25->_next + 1);
        }
        else {
LAB_1001b444:
          if (uVar12 == 0x39) {
LAB_1001b404:
            pcVar6 = pcVar19 + 1;
            *(char *)&p_Var25->_next = '9';
            p_Var7 = (_Bigint *)((int)&p_Var25->_next + 1);
            goto LAB_1001ac44;
          }
          *(char *)&p_Var25->_next = (char)uVar12 + '\x01';
          p_Stack_19c = (_Bigint *)((int)&p_Var25->_next + 1);
          pcVar6 = pcVar19 + 1;
        }
        goto LAB_1001ac56;
      }
    }
LAB_1001af4e:
    if (piStack_198 == (int *)0x0) {
      p_Var9 = __multadd(ptr,p_Var9,5,0);
      iVar13 = __mcmp(p_Stack_1f4,p_Var9);
      if (iVar13 < 1) goto LAB_1001b73a;
      *(char *)&p_Var10->_next = '1';
      _Bfree(ptr,p_Var9);
      pcVar6 = pcVar19 + 2;
      p_Stack_19c = (_Bigint *)((int)&p_Var10->_next + 1);
    }
    else {
LAB_1001b73a:
      _Bfree(ptr,p_Var9);
      pcVar6 = (char *)-(int)p_Stack_19c;
      p_Stack_19c = p_Var10;
    }
    if (p_Var20 == (_Bigint *)0x0) goto LAB_1001ad9c;
  }
  else {
    piStack_198 = piVar14;
    pcVar19 = pcVar6;
    if (((int)piVar14 < 1) && (2 < (int)decpt)) goto LAB_1001af4e;
    if (puStack_1d8 != (undefined1 *)0x0) goto LAB_1001b2f2;
    pcVar6 = pcVar6 + 1;
LAB_1001abe4:
    iVar13 = 1;
    while( true ) {
      iVar17 = quorem(p_Stack_1f4,p_Var9);
      uVar12 = iVar17 + 0x30;
      *(char *)((int)p_Var10->_x + iVar13 + -0x15) = (char)uVar12;
      if ((int)piStack_198 <= iVar13) break;
      p_Stack_1f4 = __multadd(ptr,p_Stack_1f4,10,0);
      iVar13 = iVar13 + 1;
    }
    puVar22 = (undefined1 *)0x0;
    if (0 < (int)piStack_198) {
      puVar22 = (undefined1 *)((int)piStack_198 + -1);
    }
    p_Var7 = (_Bigint *)((int)p_Var10->_x + (int)(puVar22 + -0x13));
    b = (_Bigint *)0x0;
LAB_1001ac24:
    p_Stack_1f4 = __lshift(ptr,p_Stack_1f4,1);
    iVar13 = __mcmp(p_Stack_1f4,p_Var9);
    if ((iVar13 < 1) && ((iVar13 != 0 || ((uVar12 & 1) == 0)))) {
      do {
        p_Stack_19c = p_Var7;
        p_Var7 = (_Bigint *)((int)p_Stack_19c[-1]._x + 3);
      } while (*(char *)((int)p_Stack_19c[-1]._x + 3) == '0');
    }
    else {
LAB_1001ac44:
      do {
        p_Stack_19c = p_Var7;
        cVar11 = *(char *)((int)p_Stack_19c[-1]._x + 3);
        p_Var7 = (_Bigint *)((int)p_Stack_19c[-1]._x + 3);
        if (cVar11 != '9') {
          *(char *)&p_Var7->_next = cVar11 + '\x01';
          goto LAB_1001ac56;
        }
      } while (p_Var7 != p_Var10);
      pcVar6 = pcVar6 + 1;
      *(char *)&p_Var10->_next = '1';
    }
LAB_1001ac56:
    _Bfree(ptr,p_Var9);
    if (p_Var20 == (_Bigint *)0x0) goto LAB_1001ad9c;
    if ((b != (_Bigint *)0x0) && (b != p_Var20)) {
      _Bfree(ptr,b);
    }
  }
  _Bfree(ptr,p_Var20);
LAB_1001ad9c:
  _Bfree(ptr,p_Stack_1f4);
  *(char *)&p_Stack_19c->_next = '\0';
  *rve = pcVar6;
  if (in_a7 != (undefined4 *)0x0) {
    *in_a7 = p_Stack_19c;
  }
  return (char *)p_Var10;
}



size_t strlen(char *__s)

{
  uint uVar1;
  uint *puVar2;
  uint *puVar3;
  uint uVar4;
  
  gp = &__global_pointer_;
  uVar4 = (uint)__s & 3;
  puVar3 = (uint *)__s;
  while (uVar4 != 0) {
    uVar1 = *puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    uVar4 = (uint)puVar3 & 3;
    if ((char)uVar1 == '\0') {
      return (size_t)((int)puVar3 + (-1 - (int)__s));
    }
  }
  do {
    puVar2 = puVar3;
    puVar3 = puVar2 + 1;
  } while (((*puVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | *puVar2 | 0x7f7f7f7f) == 0xffffffff);
  if ((char)*puVar2 != '\0') {
    if (*(char *)((int)puVar2 + 1) != '\0') {
      return (size_t)((int)puVar3 + ((uint)(*(char *)((int)puVar2 + 2) != '\0') - (int)__s) + -2);
    }
    return (size_t)((int)puVar3 + (-3 - (int)__s));
  }
  return (size_t)((int)puVar3 + (-4 - (int)__s));
}



// WARNING: Unknown calling convention

int _malloc_trim_r(_reent *reent_ptr,size_t pad)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  
  gp = &__global_pointer_;
  __malloc_lock(reent_ptr);
  uVar2 = __malloc_av_[2]->size & 0xfffffffc;
  iVar1 = ((uVar2 + 0xfef) - pad >> 0xc) - 1;
  if ((0xfff < iVar1 * 0x1000) &&
     (pvVar3 = _sbrk_r(reent_ptr,0), pvVar3 == (void *)((int)&__malloc_av_[2]->prev_size + uVar2)))
  {
    pvVar3 = _sbrk_r(reent_ptr,iVar1 * -0x1000);
    if (pvVar3 != (void *)0xffffffff) {
      __malloc_current_mallinfo.arena = __malloc_current_mallinfo.arena + iVar1 * -0x1000;
      __malloc_av_[2]->size = uVar2 + iVar1 * -0x1000 | 1;
      __malloc_unlock(reent_ptr);
      return 1;
    }
    pvVar3 = _sbrk_r(reent_ptr,0);
    if (0xf < (int)pvVar3 - (int)__malloc_av_[2]) {
      __malloc_current_mallinfo.arena = (int)pvVar3 - (int)__malloc_sbrk_base;
      __malloc_av_[2]->size = (int)pvVar3 - (int)__malloc_av_[2] | 1;
    }
  }
  __malloc_unlock(reent_ptr);
  return 0;
}



// WARNING: Unknown calling convention

void _free_r(_reent *reent_ptr,void *mem)

{
  ulong uVar1;
  malloc_chunk *pmVar2;
  uint uVar3;
  int iVar4;
  mbinptr pmVar5;
  int iVar6;
  uint uVar7;
  int *piVar8;
  mbinptr pmVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  malloc_chunk *pmVar13;
  
  gp = &__global_pointer_;
  if (mem == (void *)0x0) {
    return;
  }
  __malloc_lock(reent_ptr);
  uVar3 = *(uint *)((int)mem + -4);
  pmVar9 = (mbinptr)((int)mem + -8);
  uVar10 = uVar3 & 0xfffffffe;
  pmVar5 = (mbinptr)((int)&pmVar9->prev_size + uVar10);
  uVar7 = pmVar5->size & 0xfffffffc;
  if (__malloc_av_[2] == pmVar5) {
    uVar7 = uVar7 + uVar10;
    if ((uVar3 & 1) == 0) {
      pmVar9 = (mbinptr)((int)pmVar9 - *(int *)((int)mem + -8));
      pmVar2 = pmVar9->bk;
      pmVar13 = pmVar9->fd;
      uVar7 = uVar7 + *(int *)((int)mem + -8);
      pmVar13->bk = pmVar2;
      pmVar2->fd = pmVar13;
    }
    uVar1 = __malloc_trim_threshold;
    pmVar9->size = uVar7 | 1;
    __malloc_av_[2] = pmVar9;
    if (uVar1 <= uVar7) {
      _malloc_trim_r(reent_ptr,__malloc_top_pad);
    }
    goto LAB_1001bde6;
  }
  pmVar5->size = uVar7;
  uVar11 = *(uint *)((int)&pmVar5->size + uVar7) & 1;
  if ((uVar3 & 1) == 0) {
    pmVar9 = (mbinptr)((int)pmVar9 - *(int *)((int)mem + -8));
    pmVar13 = pmVar9->fd;
    uVar10 = uVar10 + *(int *)((int)mem + -8);
    if (pmVar13 == (malloc_chunk *)(__malloc_av_ + 2)) {
      if (uVar11 == 0) {
        pmVar13 = pmVar5->bk;
        pmVar2 = pmVar5->fd;
        uVar7 = uVar7 + uVar10;
        pmVar2->bk = pmVar13;
        pmVar13->fd = pmVar2;
        pmVar9->size = uVar7 | 1;
        *(uint *)((int)&pmVar9->prev_size + uVar7) = uVar7;
      }
      else {
        pmVar9->size = uVar10 | 1;
        pmVar5->prev_size = uVar10;
      }
      goto LAB_1001bde6;
    }
    pmVar2 = pmVar9->bk;
    pmVar13->bk = pmVar2;
    pmVar2->fd = pmVar13;
    if (uVar11 == 0) goto LAB_1001be00;
    pmVar9->size = uVar10 | 1;
    pmVar5->prev_size = uVar10;
  }
  else if (uVar11 == 0) {
LAB_1001be00:
    uVar10 = uVar10 + uVar7;
    pmVar13 = pmVar5->fd;
    puVar12 = (uint *)((int)&pmVar9->prev_size + uVar10);
    if (pmVar13 == (malloc_chunk *)(__malloc_av_ + 2)) {
      __malloc_av_[4] = pmVar9;
      __malloc_av_[5] = pmVar9;
      pmVar9->bk = (malloc_chunk *)(__malloc_av_ + 2);
      pmVar9->fd = (malloc_chunk *)(__malloc_av_ + 2);
      pmVar9->size = uVar10 | 1;
      *puVar12 = uVar10;
      goto LAB_1001bde6;
    }
    pmVar2 = pmVar5->bk;
    pmVar13->bk = pmVar2;
    pmVar2->fd = pmVar13;
    pmVar9->size = uVar10 | 1;
    *puVar12 = uVar10;
  }
  else {
    *(uint *)((int)mem + -4) = uVar3 | 1;
    pmVar5->prev_size = uVar10;
  }
  if (0x1ff < uVar10) {
    uVar3 = uVar10 >> 9;
    if (uVar3 < 5) {
      iVar4 = ((uVar10 >> 6) + 0x39) * 8;
      iVar6 = (uVar10 >> 6) + 0x38;
    }
    else if (uVar3 < 0x15) {
      iVar4 = (uVar3 + 0x5c) * 8;
      iVar6 = uVar3 + 0x5b;
    }
    else if (uVar3 < 0x55) {
      iVar4 = ((uVar10 >> 0xc) + 0x6f) * 8;
      iVar6 = (uVar10 >> 0xc) + 0x6e;
    }
    else if (uVar3 < 0x155) {
      iVar4 = ((uVar10 >> 0xf) + 0x78) * 8;
      iVar6 = (uVar10 >> 0xf) + 0x77;
    }
    else if (uVar3 < 0x555) {
      iVar4 = ((uVar10 >> 0x12) + 0x7d) * 8;
      iVar6 = (uVar10 >> 0x12) + 0x7c;
    }
    else {
      iVar4 = 0x3f8;
      iVar6 = 0x7e;
    }
    pmVar2 = *(malloc_chunk **)((int)__malloc_av_ + iVar4);
    pmVar13 = (malloc_chunk *)((int)&__sglue._niobs + iVar4);
    if (pmVar13 == pmVar2) {
      __malloc_av_[1] = (mbinptr)(1 << (iVar6 >> 2 & 0x1fU) | (uint)__malloc_av_[1]);
    }
    else {
      do {
        if ((pmVar2->size & 0xfffffffc) <= uVar10) break;
        pmVar2 = pmVar2->fd;
      } while (pmVar13 != pmVar2);
      pmVar13 = pmVar2->bk;
    }
    pmVar9->bk = pmVar13;
    pmVar9->fd = pmVar2;
    pmVar13->fd = pmVar9;
    pmVar2->bk = pmVar9;
    __malloc_unlock(reent_ptr);
    return;
  }
  piVar8 = (int *)((int)__malloc_av_ + (uVar10 & 0xfffffff8) + 8);
  pmVar13 = (malloc_chunk *)*piVar8;
  __malloc_av_[1] = (mbinptr)(1 << (uVar10 >> 5 & 0x1f) | (uint)__malloc_av_[1]);
  pmVar9->fd = pmVar13;
  pmVar9->bk = (malloc_chunk *)((int)__malloc_av_ + (uVar10 & 0xfffffff8));
  *piVar8 = (int)pmVar9;
  pmVar13->bk = pmVar9;
LAB_1001bde6:
  __malloc_unlock(reent_ptr);
  return;
}



// WARNING: Unknown calling convention

int _sprintf_r(_reent *ptr,char *str,char *fmt,...)

{
  int iVar1;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  FILE f;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  gp = &__global_pointer_;
  f._mbstate.__value.__wch = 0;
  f._r = 0x7fffffff;
  f._bf._base = (uchar *)0x7fffffff;
  f._w = -0xfdf8;
  ap = str;
  f._12_4_ = str;
  uStack_14 = in_a3;
  uStack_10 = in_a4;
  uStack_c = in_a5;
  uStack_8 = in_a6;
  uStack_4 = in_a7;
  iVar1 = _svfprintf_r(ptr,(FILE *)&ap,fmt,&uStack_14);
  *(undefined1 *)ap = 0;
  return iVar1;
}



int sprintf(char *__s,char *__format,...)

{
  _reent *data;
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  FILE f;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined4 uStack_8;
  undefined4 uStack_4;
  
  gp = &__global_pointer_;
  f._r = 0x7fffffff;
  f._bf._base = (uchar *)0x7fffffff;
  f._w = -0xfdf8;
  f._mbstate.__value.__wch = 0;
  ap = __s;
  f._12_4_ = __s;
  uStack_18 = in_a2;
  uStack_14 = in_a3;
  uStack_10 = in_a4;
  uStack_c = in_a5;
  uStack_8 = in_a6;
  uStack_4 = in_a7;
  data = __wrap___getreent();
  iVar1 = _svfprintf_r(data,(FILE *)&ap,__format,&uStack_18);
  *(undefined1 *)ap = 0;
  return iVar1;
}



// WARNING: Unknown calling convention

int _wctomb_r(_reent *r,char *s,wchar_t _wchar,mbstate_t *state)

{
  int iVar1;
  
  gp = &__global_pointer_;
                    // WARNING: Could not recover jumptable at 0x1001bff8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*__global_locale.wctomb)(r,s,_wchar,state);
  return iVar1;
}



// WARNING: Unknown calling convention

int __ascii_wctomb(_reent *r,char *s,wchar_t _wchar,mbstate_t *state)

{
  gp = &__global_pointer_;
  if (s == (char *)0x0) {
    return 0;
  }
  if ((uint)_wchar < 0x100) {
    *s = (char)_wchar;
    return 1;
  }
  r->_errno = 0x8a;
  return -1;
}



// WARNING: Unknown calling convention

int * __errno(void)

{
  _reent *p_Var1;
  
  gp = &__global_pointer_;
  p_Var1 = __wrap___getreent();
  return &p_Var1->_errno;
}



void * malloc(size_t __size)

{
  _reent *reent_ptr;
  void *pvVar1;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  pvVar1 = _malloc_r(reent_ptr,__size);
  return pvVar1;
}



void free(void *__ptr)

{
  _reent *reent_ptr;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  _free_r(reent_ptr,__ptr);
  return;
}



// WARNING: Unknown calling convention

void * _realloc_r(_reent *reent_ptr,void *oldmem,size_t bytes)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  void *pvVar3;
  mbinptr pmVar4;
  uint uVar5;
  malloc_chunk *pmVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  int iVar10;
  undefined4 *puVar11;
  malloc_chunk *pmVar12;
  uint uVar13;
  uint uVar14;
  int iVar15;
  int iVar16;
  
  gp = &__global_pointer_;
  if (oldmem == (void *)0x0) {
    pvVar3 = _malloc_r(reent_ptr,bytes);
    return pvVar3;
  }
  __malloc_lock(reent_ptr);
  uVar5 = *(uint *)((int)oldmem + -4);
  uVar7 = bytes + 0xb;
  uVar13 = uVar5 & 0xfffffffc;
  iVar15 = (int)oldmem + -8;
  if (uVar7 < 0x17) {
    uVar14 = 0x10;
    if (0x10 < bytes) goto LAB_1001c14a;
  }
  else {
    uVar14 = uVar7 & 0xfffffff8;
    if (((int)uVar7 < 0) || (uVar14 < bytes)) {
LAB_1001c14a:
      reent_ptr->_errno = 0xc;
      return (void *)0x0;
    }
  }
  puVar1 = (undefined4 *)oldmem;
  uVar7 = uVar13;
  iVar16 = iVar15;
  if ((int)uVar14 <= (int)uVar13) goto LAB_1001c160;
  pmVar4 = (mbinptr)(iVar15 + uVar13);
  uVar8 = pmVar4->size;
  if (__malloc_av_[2] == pmVar4) {
    iVar16 = (uVar8 & 0xfffffffc) + uVar13;
    if ((int)(uVar14 + 0x10) <= iVar16) {
      __malloc_av_[2] = (mbinptr)(iVar15 + uVar14);
      __malloc_av_[2]->size = iVar16 - uVar14 | 1;
      *(uint *)((int)oldmem + -4) = *(uint *)((int)oldmem + -4) & 1 | uVar14;
      __malloc_unlock(reent_ptr);
      return oldmem;
    }
    if ((uVar5 & 1) == 0) {
      iVar16 = iVar15 - *(int *)((int)oldmem + -8);
      uVar5 = *(uint *)(iVar16 + 4) & 0xfffffffc;
      iVar10 = (uVar8 & 0xfffffffc) + uVar5 + uVar13;
      if ((int)(uVar14 + 0x10) <= iVar10) {
        iVar9 = *(int *)(iVar16 + 0xc);
        iVar15 = *(int *)(iVar16 + 8);
        uVar13 = uVar13 - 4;
        *(int *)(iVar15 + 0xc) = iVar9;
        *(int *)(iVar9 + 8) = iVar15;
        puVar1 = (undefined4 *)(iVar16 + 8);
        if (uVar13 < 0x25) {
          puVar2 = puVar1;
          if (0x13 < uVar13) {
                    // WARNING: Load size is inaccurate
            *(undefined4 *)(iVar16 + 8) = *oldmem;
            *(undefined4 *)(iVar16 + 0xc) = *(undefined4 *)((int)oldmem + 4);
            if (uVar13 < 0x1c) {
              oldmem = (void *)((int)oldmem + 8);
              puVar2 = (undefined4 *)(iVar16 + 0x10);
            }
            else {
              *(undefined4 *)(iVar16 + 0x10) = *(undefined4 *)((int)oldmem + 8);
              *(undefined4 *)(iVar16 + 0x14) = *(undefined4 *)((int)oldmem + 0xc);
              if (uVar13 == 0x24) {
                puVar2 = (undefined4 *)(iVar16 + 0x20);
                *(undefined4 *)(iVar16 + 0x18) = *(undefined4 *)((int)oldmem + 0x10);
                puVar11 = (undefined4 *)((int)oldmem + 0x14);
                oldmem = (void *)((int)oldmem + 0x18);
                *(undefined4 *)(iVar16 + 0x1c) = *puVar11;
              }
              else {
                oldmem = (void *)((int)oldmem + 0x10);
                puVar2 = (undefined4 *)(iVar16 + 0x18);
              }
            }
          }
                    // WARNING: Load size is inaccurate
          *puVar2 = *oldmem;
          puVar2[1] = *(undefined4 *)((int)oldmem + 4);
          puVar2[2] = *(undefined4 *)((int)oldmem + 8);
        }
        else {
          memmove(puVar1,oldmem,uVar13);
        }
        __malloc_av_[2] = (mbinptr)(iVar16 + uVar14);
        __malloc_av_[2]->size = iVar10 - uVar14 | 1;
        *(uint *)(iVar16 + 4) = *(uint *)(iVar16 + 4) & 1 | uVar14;
        __malloc_unlock(reent_ptr);
        return puVar1;
      }
LAB_1001c0e8:
      uVar7 = uVar13 + uVar5;
      if ((int)uVar14 <= (int)uVar7) {
        iVar10 = *(int *)(iVar16 + 0xc);
        iVar15 = *(int *)(iVar16 + 8);
        uVar5 = uVar13 - 4;
        *(int *)(iVar15 + 0xc) = iVar10;
        *(int *)(iVar10 + 8) = iVar15;
        puVar1 = (undefined4 *)(iVar16 + 8);
        if (uVar5 < 0x25) {
          puVar2 = (undefined4 *)oldmem;
          puVar11 = puVar1;
          if (0x13 < uVar5) {
                    // WARNING: Load size is inaccurate
            *(undefined4 *)(iVar16 + 8) = *oldmem;
            *(undefined4 *)(iVar16 + 0xc) = *(undefined4 *)((int)oldmem + 4);
            if (uVar5 < 0x1c) {
              puVar2 = (undefined4 *)((int)oldmem + 8);
              puVar11 = (undefined4 *)(iVar16 + 0x10);
            }
            else {
              *(undefined4 *)(iVar16 + 0x10) = *(undefined4 *)((int)oldmem + 8);
              *(undefined4 *)(iVar16 + 0x14) = *(undefined4 *)((int)oldmem + 0xc);
              if (uVar5 == 0x24) {
                puVar11 = (undefined4 *)(iVar16 + 0x20);
                puVar2 = (undefined4 *)((int)oldmem + 0x18);
                *(undefined4 *)(iVar16 + 0x18) = *(undefined4 *)((int)oldmem + 0x10);
                *(undefined4 *)(iVar16 + 0x1c) = *(undefined4 *)((int)oldmem + 0x14);
              }
              else {
                puVar2 = (undefined4 *)((int)oldmem + 0x10);
                puVar11 = (undefined4 *)(iVar16 + 0x18);
              }
            }
          }
          *puVar11 = *puVar2;
          puVar11[1] = puVar2[1];
          puVar11[2] = puVar2[2];
          goto LAB_1001c160;
        }
        goto LAB_1001c35e;
      }
    }
  }
  else {
    if ((*(uint *)((int)&pmVar4->size + (uVar8 & 0xfffffffe)) & 1) == 0) {
      uVar7 = uVar13 + (uVar8 & 0xfffffffc);
      if ((int)uVar14 <= (int)uVar7) {
        pmVar12 = pmVar4->bk;
        pmVar6 = pmVar4->fd;
        pmVar6->bk = pmVar12;
        pmVar12->fd = pmVar6;
        goto LAB_1001c160;
      }
      if ((uVar5 & 1) != 0) goto LAB_1001c0f4;
      iVar16 = iVar15 - *(int *)((int)oldmem + -8);
      uVar5 = *(uint *)(iVar16 + 4) & 0xfffffffc;
      uVar7 = (uVar8 & 0xfffffffc) + uVar5 + uVar13;
      if ((int)uVar7 < (int)uVar14) goto LAB_1001c0e8;
      pmVar12 = pmVar4->bk;
      pmVar6 = pmVar4->fd;
      uVar5 = uVar13 - 4;
      pmVar6->bk = pmVar12;
      pmVar12->fd = pmVar6;
      iVar15 = *(int *)(iVar16 + 8);
      iVar10 = *(int *)(iVar16 + 0xc);
      puVar1 = (undefined4 *)(iVar16 + 8);
      *(int *)(iVar15 + 0xc) = iVar10;
      *(int *)(iVar10 + 8) = iVar15;
      if (uVar5 < 0x25) {
        puVar2 = (undefined4 *)oldmem;
        puVar11 = puVar1;
        if (0x13 < uVar5) {
                    // WARNING: Load size is inaccurate
          *(undefined4 *)(iVar16 + 8) = *oldmem;
          *(undefined4 *)(iVar16 + 0xc) = *(undefined4 *)((int)oldmem + 4);
          if (uVar5 < 0x1c) {
            puVar2 = (undefined4 *)((int)oldmem + 8);
            puVar11 = (undefined4 *)(iVar16 + 0x10);
          }
          else {
            *(undefined4 *)(iVar16 + 0x10) = *(undefined4 *)((int)oldmem + 8);
            *(undefined4 *)(iVar16 + 0x14) = *(undefined4 *)((int)oldmem + 0xc);
            if (uVar5 == 0x24) {
              puVar11 = (undefined4 *)(iVar16 + 0x20);
              puVar2 = (undefined4 *)((int)oldmem + 0x18);
              *(undefined4 *)(iVar16 + 0x18) = *(undefined4 *)((int)oldmem + 0x10);
              *(undefined4 *)(iVar16 + 0x1c) = *(undefined4 *)((int)oldmem + 0x14);
            }
            else {
              puVar2 = (undefined4 *)((int)oldmem + 0x10);
              puVar11 = (undefined4 *)(iVar16 + 0x18);
            }
          }
        }
        *puVar11 = *puVar2;
        puVar11[1] = puVar2[1];
        puVar11[2] = puVar2[2];
        goto LAB_1001c160;
      }
LAB_1001c35e:
      memmove(puVar1,oldmem,uVar13 - 4);
      goto LAB_1001c160;
    }
    if ((uVar5 & 1) == 0) {
      iVar16 = iVar15 - *(int *)((int)oldmem + -8);
      uVar5 = *(uint *)(iVar16 + 4) & 0xfffffffc;
      goto LAB_1001c0e8;
    }
  }
LAB_1001c0f4:
  puVar2 = (undefined4 *)_malloc_r(reent_ptr,bytes);
  if (puVar2 == (undefined4 *)0x0) {
    __malloc_unlock(reent_ptr);
    return (void *)0x0;
  }
  if ((undefined4 *)((*(uint *)((int)oldmem + -4) & 0xfffffffe) + iVar15) != puVar2 + -2) {
    uVar13 = uVar13 - 4;
    if (uVar13 < 0x25) {
      puVar11 = puVar2;
      if (0x13 < uVar13) {
                    // WARNING: Load size is inaccurate
        *puVar2 = *oldmem;
        puVar2[1] = *(undefined4 *)((int)oldmem + 4);
        if (uVar13 < 0x1c) {
          puVar1 = (undefined4 *)((int)oldmem + 8);
          puVar11 = puVar2 + 2;
        }
        else {
          puVar2[2] = *(undefined4 *)((int)oldmem + 8);
          puVar2[3] = *(undefined4 *)((int)oldmem + 0xc);
          if (uVar13 == 0x24) {
            puVar2[4] = *(undefined4 *)((int)oldmem + 0x10);
            puVar2[5] = *(undefined4 *)((int)oldmem + 0x14);
            puVar1 = (undefined4 *)((int)oldmem + 0x18);
            puVar11 = puVar2 + 6;
          }
          else {
            puVar1 = (undefined4 *)((int)oldmem + 0x10);
            puVar11 = puVar2 + 4;
          }
        }
      }
      *puVar11 = *puVar1;
      puVar11[1] = puVar1[1];
      puVar11[2] = puVar1[2];
    }
    else {
      memmove(puVar2,oldmem,uVar13);
    }
    _free_r(reent_ptr,oldmem);
    __malloc_unlock(reent_ptr);
    return puVar2;
  }
  uVar7 = uVar13 + (puVar2[-1] & 0xfffffffc);
  iVar16 = iVar15;
LAB_1001c160:
  uVar13 = *(uint *)(iVar16 + 4) & 1;
  iVar15 = iVar16 + uVar7;
  if (uVar7 - uVar14 < 0x10) {
    *(uint *)(iVar16 + 4) = uVar13 | uVar7;
    *(uint *)(iVar15 + 4) = *(uint *)(iVar15 + 4) | 1;
  }
  else {
    *(uint *)(iVar16 + 4) = uVar13 | uVar14;
    *(uint *)(iVar16 + uVar14 + 4) = uVar7 - uVar14 | 1;
    *(uint *)(iVar15 + 4) = *(uint *)(iVar15 + 4) | 1;
    _free_r(reent_ptr,(void *)(iVar16 + uVar14 + 8));
  }
  __malloc_unlock(reent_ptr);
  return puVar1;
}



// WARNING: Unknown calling convention

void __malloc_lock(_reent *ptr)

{
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive((_LOCK_T)&__lock___malloc_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention

void __malloc_unlock(_reent *ptr)

{
  gp = &__global_pointer_;
  __retarget_lock_release_recursive((_LOCK_T)&__lock___malloc_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention

void * _sbrk_r(_reent *ptr,ptrdiff_t incr)

{
  void *pvVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  pvVar1 = _sbrk(incr);
  if ((pvVar1 == (void *)0xffffffff) && (errno != 0)) {
    ptr->_errno = errno;
    return (void *)0xffffffff;
  }
  return pvVar1;
}



void * memcpy(void *__dest,void *__src,size_t __n)

{
  undefined1 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  uint uVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  char *end;
  undefined4 *puVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  
  gp = &__global_pointer_;
  puVar12 = (undefined4 *)((int)__dest + __n);
  if (((((uint)__src ^ (uint)__dest) & 3) == 0) && (3 < __n)) {
    uVar6 = (uint)__dest & 3;
    puVar5 = (undefined4 *)__dest;
    while (puVar4 = (undefined4 *)__src, puVar7 = puVar5, uVar6 != 0) {
                    // WARNING: Load size is inaccurate
      puVar7 = (undefined4 *)((int)puVar5 + 1);
      *(undefined1 *)puVar5 = *__src;
      puVar4 = (undefined4 *)((int)__src + 1);
      if (((uint)puVar7 & 3) == 0) break;
      *(undefined1 *)((int)puVar5 + 1) = *(undefined1 *)puVar4;
      __src = (void *)((int)__src + 2);
      uVar6 = (uint)((int)puVar5 + 2) & 3;
      puVar5 = (undefined4 *)((int)puVar5 + 2);
    }
    puVar5 = (undefined4 *)((uint)puVar12 & 0xfffffffc);
    __src = puVar4;
    for (; 0x20 < (int)puVar5 - (int)puVar7; puVar7 = puVar7 + 9) {
                    // WARNING: Load size is inaccurate
      uVar3 = *__src;
      uVar10 = *(undefined4 *)((int)__src + 4);
      uVar16 = *(undefined4 *)((int)__src + 8);
      uVar15 = *(undefined4 *)((int)__src + 0xc);
      uVar14 = *(undefined4 *)((int)__src + 0x10);
      uVar13 = *(undefined4 *)((int)__src + 0x14);
      uVar2 = *(undefined4 *)((int)__src + 0x18);
      uVar11 = *(undefined4 *)((int)__src + 0x1c);
      puVar7[8] = *(undefined4 *)((int)__src + 0x20);
      *puVar7 = uVar3;
      puVar7[1] = uVar10;
      puVar7[2] = uVar16;
      puVar7[3] = uVar15;
      puVar7[4] = uVar14;
      puVar7[5] = uVar13;
      puVar7[6] = uVar2;
      puVar7[7] = uVar11;
      __src = (void *)((int)__src + 0x24);
    }
    puVar4 = (undefined4 *)__src;
    puVar8 = puVar7;
    if (puVar7 < puVar5) {
      do {
        uVar10 = *puVar4;
        puVar9 = puVar8 + 1;
        puVar4 = puVar4 + 1;
        *puVar8 = uVar10;
        puVar8 = puVar9;
      } while (puVar9 < puVar5);
      uVar6 = (uint)((int)puVar5 + (-1 - (int)puVar7)) & 0xfffffffc;
      __src = (void *)((int)__src + uVar6 + 4);
      puVar7 = (undefined4 *)((int)puVar7 + uVar6 + 4);
    }
    if (puVar12 <= puVar7) {
      return __dest;
    }
  }
  else {
    puVar7 = (undefined4 *)__dest;
    if (puVar12 <= __dest) {
      return __dest;
    }
  }
  puVar12 = (undefined4 *)(((int)puVar12 - (int)puVar7) + (int)__src);
  do {
                    // WARNING: Load size is inaccurate
    uVar1 = *__src;
    __src = (void *)((int)__src + 1);
    *(undefined1 *)puVar7 = uVar1;
    puVar7 = (undefined4 *)((int)puVar7 + 1);
  } while (puVar12 != (undefined4 *)__src);
  return __dest;
}



void exit(int __status)

{
  gp = &__global_pointer_;
  __call_exitprocs(__status,(void *)0x0);
  if (__stdio_exit_handler != (_func_void *)0x0) {
    (*__stdio_exit_handler)();
  }
                    // WARNING: Subroutine does not return
  _exit(__status);
}



void * memchr(void *__s,int __c,size_t __n)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uchar d;
  
  gp = &__global_pointer_;
  puVar1 = (uint *)__s;
  if (((uint)__s & 3) != 0) {
    do {
      puVar2 = puVar1;
      puVar1 = (uint *)((int)puVar2 + 1);
      if (puVar2 == (uint *)((int)__s + __n)) {
        return (void *)0x0;
      }
      if ((uint)(byte)*puVar2 == (__c & 0xffU)) {
        return puVar2;
      }
    } while (((uint)puVar1 & 3) != 0);
    __n = (int)__s + ((__n - 1) - (int)puVar2);
  }
  if (3 < __n) {
    do {
      uVar3 = *puVar1 ^ (__c & 0xffU) * 0x1010101;
      if ((~uVar3 & uVar3 + 0xfefefeff & 0x80808080) != 0) goto LAB_1001c634;
      __n = __n - 4;
      puVar1 = puVar1 + 1;
    } while (3 < __n);
  }
  if (__n != 0) {
LAB_1001c634:
    puVar2 = (uint *)(__n + (int)puVar1);
    do {
      if ((uint)(byte)*puVar1 == (__c & 0xffU)) {
        return puVar1;
      }
      puVar1 = (uint *)((int)puVar1 + 1);
    } while (puVar1 != puVar2);
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

int __ssprint_r(_reent *ptr,FILE *fp,__suio *uio)

{
  __siov *p_Var1;
  size_t sVar2;
  int iVar3;
  size_t len;
  
  gp = &__global_pointer_;
  sVar2 = uio->uio_resid;
  p_Var1 = uio->uio_iov;
  while (sVar2 != 0) {
    while( true ) {
      iVar3 = uio->uio_iovcnt;
      uio->uio_iovcnt = iVar3 + -1;
      if (iVar3 < 1) goto LAB_1001c6ac;
      len = p_Var1->iov_len;
      if (len == 0) break;
      iVar3 = __ssputs_r(ptr,fp,(char *)p_Var1->iov_base,len);
      if (iVar3 == -1) {
        uio->uio_resid = 0;
        uio->uio_iovcnt = 0;
        return -1;
      }
      p_Var1 = p_Var1 + 1;
      sVar2 = uio->uio_resid - len;
      uio->uio_resid = sVar2;
      if (sVar2 == 0) goto LAB_1001c6ac;
    }
    p_Var1 = p_Var1 + 1;
  }
LAB_1001c6ac:
  uio->uio_resid = 0;
  uio->uio_iovcnt = 0;
  return 0;
}



// WARNING: Unknown calling convention

int __sfvwrite_r(_reent *ptr,FILE *fp,__suio *uio)

{
  size_t *psVar1;
  __siov *p_Var2;
  __siov *p_Var3;
  _ssize_t _Var4;
  void *pvVar5;
  uchar *puVar6;
  ushort uVar7;
  uint uVar8;
  int iVar9;
  size_t sVar10;
  uchar *puVar11;
  uint uVar12;
  uint uVar13;
  char *pcVar14;
  size_t sVar15;
  
  gp = &__global_pointer_;
  if (uio->uio_resid == 0) {
    return 0;
  }
  uVar7 = fp->_flags;
  if (((uVar7 & 8) == 0) || ((fp->_bf)._base == (uchar *)0x0)) {
    iVar9 = __swsetup_r(ptr,fp);
    if (iVar9 != 0) {
      return -1;
    }
    uVar7 = fp->_flags;
    p_Var2 = uio->uio_iov;
  }
  else {
    p_Var2 = uio->uio_iov;
  }
  if ((uVar7 & 2) == 0) {
    if ((uVar7 & 1) == 0) {
      puVar11 = fp->_p;
      pcVar14 = (char *)0x0;
      uVar13 = 0;
      do {
        while (uVar13 == 0) {
LAB_1001c854:
          pcVar14 = (char *)p_Var2->iov_base;
          psVar1 = &p_Var2->iov_len;
          p_Var2 = p_Var2 + 1;
          uVar13 = *psVar1;
        }
        uVar8 = fp->_w;
        if ((uVar7 & 0x200) != 0) {
          uVar12 = uVar13;
          if ((uVar8 <= uVar13) && (uVar12 = uVar8, (uVar7 & 0x480) != 0)) {
            puVar6 = (fp->_bf)._base;
            sVar15 = (int)puVar11 - (int)puVar6;
            uVar8 = ((fp->_bf)._size * 3) / 2;
            uVar12 = sVar15 + 1 + uVar13;
            if (uVar8 < uVar12) {
              uVar8 = uVar12;
            }
            if ((uVar7 & 0x400) == 0) {
              puVar6 = (uchar *)_realloc_r(ptr,puVar6,uVar8);
              if (puVar6 == (uchar *)0x0) {
                _free_r(ptr,(fp->_bf)._base);
                uVar7 = fp->_flags;
                ptr->_errno = 0xc;
                uVar7 = uVar7 & 0xff7f;
                goto LAB_1001c918;
              }
            }
            else {
              puVar6 = (uchar *)_malloc_r(ptr,uVar8);
              if (puVar6 == (uchar *)0x0) {
                ptr->_errno = 0xc;
                uVar7 = fp->_flags;
                goto LAB_1001c918;
              }
              memcpy(puVar6,(fp->_bf)._base,sVar15);
              fp->_flags = fp->_flags & 0xfb7fU | 0x80;
            }
            puVar11 = puVar6 + sVar15;
            (fp->_bf)._size = uVar8;
            (fp->_bf)._base = puVar6;
            fp->_p = puVar11;
            fp->_w = uVar8 - sVar15;
            uVar12 = uVar13;
          }
          memmove(puVar11,pcVar14,uVar12);
          fp->_w = fp->_w - uVar12;
          sVar10 = uio->uio_resid;
          puVar11 = fp->_p + uVar12;
          fp->_p = puVar11;
          sVar10 = sVar10 - uVar13;
          uio->uio_resid = sVar10;
          if (sVar10 == 0) {
            return 0;
          }
          uVar7 = fp->_flags;
          goto LAB_1001c854;
        }
        if (((fp->_bf)._base < puVar11) || (uVar12 = (fp->_bf)._size, uVar13 < uVar12)) {
          if (uVar13 < uVar8) {
            uVar8 = uVar13;
          }
          memmove(puVar11,pcVar14,uVar8);
          iVar9 = fp->_w - uVar8;
          fp->_p = fp->_p + uVar8;
          fp->_w = iVar9;
          if ((iVar9 == 0) && (iVar9 = _fflush_r(ptr,fp), iVar9 != 0)) goto LAB_1001c99a;
        }
        else {
          uVar8 = uVar13;
          if (0x7fffffff < uVar13) {
            uVar8 = 0x7fffffff;
          }
          uVar8 = (*fp->_write)(ptr,fp->_cookie,pcVar14,uVar8 - (int)uVar8 % (int)uVar12);
          if ((int)uVar8 < 1) {
LAB_1001c99a:
            uVar7 = fp->_flags;
            goto LAB_1001c918;
          }
        }
        uVar13 = uVar13 - uVar8;
        pcVar14 = pcVar14 + uVar8;
        sVar10 = uio->uio_resid - uVar8;
        uio->uio_resid = sVar10;
        if (sVar10 == 0) {
          return 0;
        }
        uVar7 = fp->_flags;
        puVar11 = fp->_p;
      } while( true );
    }
    uVar13 = 0;
    iVar9 = 0;
    pcVar14 = (char *)0x0;
    uVar8 = 0;
    do {
      if (uVar8 == 0) {
        do {
          p_Var3 = p_Var2;
          uVar8 = p_Var3->iov_len;
          p_Var2 = p_Var3 + 1;
        } while (uVar8 == 0);
        pcVar14 = (char *)p_Var3->iov_base;
LAB_1001c8e4:
        pvVar5 = memchr(pcVar14,10,uVar8);
        if (pvVar5 == (void *)0x0) {
          uVar13 = uVar8 + 1;
        }
        else {
          uVar13 = (int)pvVar5 + (1 - (int)pcVar14);
        }
      }
      else if (iVar9 == 0) goto LAB_1001c8e4;
      uVar12 = uVar8;
      if (uVar13 < uVar8) {
        uVar12 = uVar13;
      }
      puVar11 = fp->_p;
      iVar9 = (fp->_bf)._size;
      if (((fp->_bf)._base < puVar11) && (sVar15 = fp->_w + iVar9, (int)sVar15 < (int)uVar12)) {
        memmove(puVar11,pcVar14,sVar15);
        fp->_p = fp->_p + sVar15;
        iVar9 = _fflush_r(ptr,fp);
        if (iVar9 != 0) goto LAB_1001c910;
      }
      else if ((int)uVar12 < iVar9) {
        memmove(puVar11,pcVar14,uVar12);
        fp->_w = fp->_w - uVar12;
        fp->_p = fp->_p + uVar12;
        sVar15 = uVar12;
      }
      else {
        sVar15 = (*fp->_write)(ptr,fp->_cookie,pcVar14,iVar9);
        if ((int)sVar15 < 1) goto LAB_1001c910;
      }
      uVar13 = uVar13 - sVar15;
      iVar9 = 1;
      if ((uVar13 == 0) && (iVar9 = _fflush_r(ptr,fp), iVar9 != 0)) {
LAB_1001c910:
        uVar7 = fp->_flags;
LAB_1001c918:
        fp->_flags = uVar7 | 0x40;
        return -1;
      }
      pcVar14 = pcVar14 + sVar15;
      uVar8 = uVar8 - sVar15;
      sVar10 = uio->uio_resid - sVar15;
      uio->uio_resid = sVar10;
    } while (sVar10 != 0);
  }
  else {
    pcVar14 = (char *)0x0;
    uVar13 = 0;
    do {
      while (uVar13 == 0) {
        pcVar14 = (char *)p_Var2->iov_base;
        psVar1 = &p_Var2->iov_len;
        p_Var2 = p_Var2 + 1;
        uVar13 = *psVar1;
      }
      uVar8 = uVar13;
      if (0x7ffffc00 < uVar13) {
        uVar8 = 0x7ffffc00;
      }
      _Var4 = (*fp->_write)(ptr,fp->_cookie,pcVar14,uVar8);
      if (_Var4 < 1) {
        uVar7 = fp->_flags;
        goto LAB_1001c918;
      }
      pcVar14 = pcVar14 + _Var4;
      uVar13 = uVar13 - _Var4;
      sVar10 = uio->uio_resid - _Var4;
      uio->uio_resid = sVar10;
    } while (sVar10 != 0);
  }
  return 0;
}



// WARNING: Unknown calling convention

_ssize_t __sread(_reent *ptr,void *cookie,char *buf,int n)

{
  _ssize_t _Var1;
  
  gp = &__global_pointer_;
  _Var1 = _read_r(ptr,(int)*(short *)((int)cookie + 0xe),buf,n);
  if (-1 < _Var1) {
    *(int *)((int)cookie + 0x54) = *(int *)((int)cookie + 0x54) + _Var1;
    return _Var1;
  }
  *(ushort *)((int)cookie + 0xc) = *(ushort *)((int)cookie + 0xc) & 0xefff;
  return _Var1;
}



// WARNING: Unknown calling convention

_ssize_t __seofread(_reent *_ptr,void *cookie,char *buf,int len)

{
  gp = &__global_pointer_;
  return 0;
}



// WARNING: Unknown calling convention

_ssize_t __swrite(_reent *ptr,void *cookie,char *buf,int n)

{
  _ssize_t _Var1;
  ushort uVar2;
  
  gp = &__global_pointer_;
  uVar2 = *(ushort *)((int)cookie + 0xc);
  if ((uVar2 & 0x100) != 0) {
    _lseek_r(ptr,(int)*(short *)((int)cookie + 0xe),0,2);
    uVar2 = *(ushort *)((int)cookie + 0xc);
  }
  *(ushort *)((int)cookie + 0xc) = uVar2 & 0xefff;
  _Var1 = _write_r(ptr,(int)*(short *)((int)cookie + 0xe),buf,n);
  return _Var1;
}



// WARNING: Unknown calling convention

_fpos_t __sseek(_reent *ptr,void *cookie,_fpos_t offset,int whence)

{
  _off_t _Var1;
  
  gp = &__global_pointer_;
  _Var1 = _lseek_r(ptr,(int)*(short *)((int)cookie + 0xe),offset,whence);
  if (_Var1 != -1) {
    *(_off_t *)((int)cookie + 0x54) = _Var1;
    *(ushort *)((int)cookie + 0xc) = *(ushort *)((int)cookie + 0xc) | 0x1000;
    return _Var1;
  }
  *(ushort *)((int)cookie + 0xc) = *(ushort *)((int)cookie + 0xc) & 0xefff;
  return -1;
}



// WARNING: Unknown calling convention

int __sclose(_reent *ptr,void *cookie)

{
  int iVar1;
  
  gp = &__global_pointer_;
  iVar1 = _close_r(ptr,(int)*(short *)((int)cookie + 0xe));
  return iVar1;
}



// WARNING: Unknown calling convention

int __sflush_r(_reent *ptr,FILE *fp)

{
  ushort uVar1;
  int iVar2;
  uchar *puVar3;
  _fpos_t _Var4;
  _ssize_t _Var5;
  uchar *puVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  _func__fpos_t__reent_ptr_void_ptr__fpos_t_int *p_Var10;
  
  gp = &__global_pointer_;
  uVar7 = (uint)fp->_flags;
  if ((uVar7 & 8) != 0) {
    puVar6 = (fp->_bf)._base;
    if (puVar6 == (uchar *)0x0) {
      return 0;
    }
    puVar3 = fp->_p;
    fp->_p = puVar6;
    iVar2 = (int)puVar3 - (int)puVar6;
    iVar9 = 0;
    if ((uVar7 & 3) == 0) {
      iVar9 = (fp->_bf)._size;
    }
    fp->_w = iVar9;
    while( true ) {
      if (iVar2 < 1) {
        return 0;
      }
      _Var5 = (*fp->_write)(ptr,fp->_cookie,(char *)puVar6,iVar2);
      iVar2 = iVar2 - _Var5;
      if (_Var5 < 1) break;
      puVar6 = puVar6 + _Var5;
    }
    uVar1 = fp->_flags;
LAB_1001cc22:
    fp->_flags = uVar1 | 0x40;
    return -1;
  }
  uVar8 = uVar7 | 0x800;
  fp->_flags = (short)uVar8;
  if ((fp->_r < 1) && (fp->_ur < 1)) {
    return 0;
  }
  p_Var10 = fp->_seek;
  if (p_Var10 == (_func__fpos_t__reent_ptr_void_ptr__fpos_t_int *)0x0) {
    return 0;
  }
  iVar2 = ptr->_errno;
  ptr->_errno = 0;
  if ((int)(uVar7 << 0x13) < 0) {
    _Var4 = fp->_offset;
  }
  else {
    _Var4 = (*p_Var10)(ptr,fp->_cookie,0,1);
    if ((_Var4 == -1) && (iVar9 = ptr->_errno, iVar9 != 0)) {
      if ((iVar9 == 0x1d) || (iVar9 == 0x16)) {
        ptr->_errno = iVar2;
        return 0;
      }
      uVar1 = fp->_flags;
      goto LAB_1001cc22;
    }
    uVar8 = (uint)fp->_flags;
    p_Var10 = fp->_seek;
  }
  if (((uVar8 & 4) != 0) && (_Var4 = _Var4 - fp->_r, (fp->_ub)._base != (uchar *)0x0)) {
    _Var4 = _Var4 - fp->_ur;
  }
  _Var4 = (*p_Var10)(ptr,fp->_cookie,_Var4,0);
  uVar1 = fp->_flags;
  if (_Var4 == -1) {
    if ((0x1d < (uint)ptr->_errno) || ((0x20400001U >> (ptr->_errno & 0x1fU) & 1) == 0))
    goto LAB_1001cc22;
    puVar6 = (fp->_bf)._base;
    fp->_flags = uVar1 & 0xf7ff;
    fp->_r = 0;
    fp->_p = puVar6;
    if (((int)(short)uVar1 << 0x13 < 0) && (ptr->_errno == 0)) goto LAB_1001cc62;
  }
  else {
    puVar6 = (fp->_bf)._base;
    fp->_flags = uVar1 & 0xf7ff;
    fp->_r = 0;
    fp->_p = puVar6;
    if ((int)(short)uVar1 << 0x13 < 0) {
LAB_1001cc62:
      puVar6 = (fp->_ub)._base;
      fp->_offset = _Var4;
      ptr->_errno = iVar2;
      goto joined_r0x1001cc6a;
    }
  }
  puVar6 = (fp->_ub)._base;
  ptr->_errno = iVar2;
joined_r0x1001cc6a:
  if (puVar6 != (uchar *)0x0) {
    if (puVar6 != fp->_ubuf) {
      _free_r(ptr,puVar6);
    }
    (fp->_ub)._base = (uchar *)0x0;
  }
  return 0;
}



// WARNING: Unknown calling convention

int _fflush_r(_reent *ptr,FILE *fp)

{
  int iVar1;
  
  gp = &__global_pointer_;
  if ((fp->_bf)._base != (uchar *)0x0) {
    if ((ptr != (_reent *)0x0) && (ptr->__cleanup == (_func_void__reent_ptr *)0x0)) {
      __sinit(ptr);
    }
    if (fp->_flags != 0) {
      if (((fp->_flags2 & 1U) == 0) && ((fp->_flags & 0x200U) == 0)) {
        __retarget_lock_acquire_recursive(&fp->_lock);
      }
      iVar1 = __sflush_r(ptr,fp);
      if (((fp->_flags2 & 1U) == 0) && ((fp->_flags & 0x200U) == 0)) {
        __retarget_lock_release_recursive(&fp->_lock);
      }
      return iVar1;
    }
  }
  return 0;
}



int fflush(FILE *__stream)

{
  _reent *ptr;
  int iVar1;
  
  gp = &__global_pointer_;
  if (__stream != (FILE *)0x0) {
    ptr = __wrap___getreent();
    iVar1 = _fflush_r(ptr,(FILE *)__stream);
    return iVar1;
  }
  iVar1 = _fwalk_sglue(&_impure_data,_fflush_r,&__sglue);
  return iVar1;
}



// WARNING: Unknown calling convention

int _init_signal_r(_reent *ptr)

{
  _func_void_int **pp_Var1;
  int iVar2;
  _func_void_int **pp_Var3;
  
  gp = &__global_pointer_;
  if (ptr->_sig_func != (_func_void_int **)0x0) {
    return 0;
  }
  pp_Var1 = (_func_void_int **)_malloc_r(ptr,0x80);
  ptr->_sig_func = pp_Var1;
  if (pp_Var1 == (_func_void_int **)0x0) {
    iVar2 = -1;
  }
  else {
    pp_Var3 = pp_Var1 + 0x20;
    do {
      *pp_Var1 = (_func_void_int *)0x0;
      pp_Var1 = pp_Var1 + 1;
    } while (pp_Var1 != pp_Var3);
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

_sig_func_ptr _signal_r(_reent *ptr,int sig,_sig_func_ptr func)

{
  _sig_func_ptr p_Var1;
  _func_void_int **pp_Var2;
  _func_void_int **pp_Var3;
  
  gp = &__global_pointer_;
  if (0x1f < (uint)sig) {
    ptr->_errno = 0x16;
    return (_sig_func_ptr)0xffffffff;
  }
  pp_Var3 = ptr->_sig_func;
  if (pp_Var3 == (_func_void_int **)0x0) {
    pp_Var3 = (_func_void_int **)_malloc_r(ptr,0x80);
    ptr->_sig_func = pp_Var3;
    pp_Var2 = pp_Var3;
    if (pp_Var3 == (_func_void_int **)0x0) {
      return (_sig_func_ptr)0xffffffff;
    }
    do {
      *pp_Var2 = (_func_void_int *)0x0;
      pp_Var2 = pp_Var2 + 1;
    } while (pp_Var2 != pp_Var3 + 0x20);
  }
  p_Var1 = pp_Var3[sig];
  pp_Var3[sig] = func;
  return p_Var1;
}



// WARNING: Unknown calling convention

int _raise_r(_reent *ptr,int sig)

{
  int iVar1;
  _func_void_int *p_Var2;
  _func_void_int **pp_Var3;
  
  gp = &__global_pointer_;
  if (0x1f < (uint)sig) {
    ptr->_errno = 0x16;
    return -1;
  }
  if (ptr->_sig_func != (_func_void_int **)0x0) {
    pp_Var3 = ptr->_sig_func + sig;
    p_Var2 = *pp_Var3;
    if (p_Var2 != (_func_void_int *)0x0) {
      if (p_Var2 != (_func_void_int *)&DAT_00000001) {
        if (p_Var2 == (_func_void_int *)0xffffffff) {
          ptr->_errno = 0x16;
          return 1;
        }
        *pp_Var3 = (_func_void_int *)0x0;
        (*p_Var2)(sig);
      }
      gp = &__global_pointer_;
      return 0;
    }
  }
  iVar1 = _getpid_r(ptr);
  iVar1 = _kill_r(ptr,iVar1,sig);
  return iVar1;
}



// WARNING: Unknown calling convention

int __sigtramp_r(_reent *ptr,int sig)

{
  int iVar1;
  _func_void_int *p_Var2;
  _func_void_int **pp_Var3;
  _func_void_int **pp_Var4;
  
  gp = &__global_pointer_;
  if (0x1f < (uint)sig) {
    return -1;
  }
  pp_Var4 = ptr->_sig_func;
  if (pp_Var4 == (_func_void_int **)0x0) {
    pp_Var4 = (_func_void_int **)_malloc_r(ptr,0x80);
    ptr->_sig_func = pp_Var4;
    if (pp_Var4 == (_func_void_int **)0x0) {
      return -1;
    }
    pp_Var3 = pp_Var4;
    do {
      *pp_Var3 = (_func_void_int *)0x0;
      pp_Var3 = pp_Var3 + 1;
    } while (pp_Var3 != pp_Var4 + 0x20);
  }
  p_Var2 = pp_Var4[sig];
  if (p_Var2 != (_func_void_int *)0x0) {
    if (p_Var2 == (_func_void_int *)0xffffffff) {
      iVar1 = 2;
    }
    else {
      if (p_Var2 == (_func_void_int *)&DAT_00000001) {
        return 3;
      }
      pp_Var4[sig] = (_func_void_int *)0x0;
      (*p_Var2)(sig);
      iVar1 = 0;
    }
    return iVar1;
  }
  return 1;
}



int raise(int __sig)

{
  _reent *ptr;
  int iVar1;
  
  gp = &__global_pointer_;
  ptr = __wrap___getreent();
  iVar1 = _raise_r(ptr,__sig);
  return iVar1;
}



__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  _reent *reent_ptr;
  __sighandler_t p_Var1;
  _func_void_int **pp_Var2;
  _func_void_int **pp_Var3;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  if (0x1f < (uint)__sig) {
    reent_ptr->_errno = 0x16;
    return (__sighandler_t)0xffffffff;
  }
  pp_Var3 = reent_ptr->_sig_func;
  if (pp_Var3 == (_func_void_int **)0x0) {
    pp_Var3 = (_func_void_int **)_malloc_r(reent_ptr,0x80);
    reent_ptr->_sig_func = pp_Var3;
    pp_Var2 = pp_Var3;
    if (pp_Var3 == (_func_void_int **)0x0) {
      return (__sighandler_t)0xffffffff;
    }
    do {
      *pp_Var2 = (_func_void_int *)0x0;
      pp_Var2 = pp_Var2 + 1;
    } while (pp_Var3 + 0x20 != pp_Var2);
  }
  p_Var1 = (__sighandler_t)pp_Var3[__sig];
  pp_Var3[__sig] = (_func_void_int *)__handler;
  return p_Var1;
}



// WARNING: Unknown calling convention

int _init_signal(void)

{
  _reent *reent_ptr;
  _func_void_int **pp_Var1;
  _func_void_int **pp_Var2;
  
  gp = &__global_pointer_;
  reent_ptr = __wrap___getreent();
  if (reent_ptr->_sig_func == (_func_void_int **)0x0) {
    pp_Var1 = (_func_void_int **)_malloc_r(reent_ptr,0x80);
    reent_ptr->_sig_func = pp_Var1;
    if (pp_Var1 == (_func_void_int **)0x0) {
      return -1;
    }
    pp_Var2 = pp_Var1 + 0x20;
    do {
      *pp_Var1 = (_func_void_int *)0x0;
      pp_Var1 = pp_Var1 + 1;
    } while (pp_Var1 != pp_Var2);
  }
  return 0;
}



// WARNING: Unknown calling convention

int __sigtramp(int sig)

{
  _reent *ptr;
  int iVar1;
  
  gp = &__global_pointer_;
  ptr = __wrap___getreent();
  iVar1 = __sigtramp_r(ptr,sig);
  return iVar1;
}



int * frexp(double __x,int *__exponent)

{
  uint in_a1;
  int iVar1;
  uint extraout_a1;
  int *in_a2;
  uint uVar2;
  
  gp = &__global_pointer_;
  *in_a2 = 0;
  uVar2 = in_a1 & 0x7fffffff;
  if ((uVar2 < 0x7ff00000) && (uVar2 != 0 || __exponent != (int *)0x0)) {
    if ((in_a1 >> 0x14 & 0x7ff) == 0) {
      __exponent = (int *)__muldf3(__x,DRam00000018);
      uVar2 = extraout_a1 & 0x7fffffff;
      iVar1 = -0x36;
    }
    else {
      iVar1 = 0;
    }
    *in_a2 = ((int)uVar2 >> 0x14) + -0x3fe + iVar1;
  }
  return __exponent;
}



// WARNING: Unknown calling convention

int _fwalk_sglue(_reent *ptr,_func_int__reent_ptr_FILE_ptr *func,_glue *g)

{
  FILE *pFVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  gp = &__global_pointer_;
  uVar4 = 0;
  do {
    pFVar1 = g->_iobs;
    iVar2 = g->_niobs + -1;
    if (-1 < iVar2) {
      do {
        if ((1 < (ushort)pFVar1->_flags) && (pFVar1->_file != -1)) {
          uVar3 = (*func)(ptr,pFVar1);
          uVar4 = uVar4 | uVar3;
        }
        iVar2 = iVar2 + -1;
        pFVar1 = pFVar1 + 1;
      } while (iVar2 != -1);
    }
    g = g->_next;
  } while (g != (_glue *)0x0);
  return uVar4;
}



// WARNING: Unknown calling convention

_Bigint * _Balloc(_reent *ptr,int k)

{
  _mprec *p_Var1;
  int iVar2;
  _Bigint *p_Var3;
  _Bigint **pp_Var4;
  _mprec *p_Var5;
  
  gp = &__global_pointer_;
  p_Var1 = ptr->_mp;
  if (p_Var1 == (_mprec *)0x0) {
    p_Var1 = (_mprec *)__wrap_malloc(0x10);
    ptr->_mp = p_Var1;
    if (p_Var1 == (_mprec *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x6b,(char *)0x0,
                    "REENT malloc succeeded");
    }
    p_Var1->_result_k = 0;
    p_Var1->_p5s = (_Bigint *)0x0;
    p_Var1->_result = (_Bigint *)0x0;
    p_Var1->_freelist = (_Bigint **)0x0;
LAB_1001d0e4:
    pp_Var4 = (_Bigint **)_calloc_r(ptr,4,0x21);
    p_Var5 = ptr->_mp;
    p_Var1->_freelist = pp_Var4;
    pp_Var4 = p_Var5->_freelist;
    if (pp_Var4 != (_Bigint **)0x0) goto LAB_1001d0a6;
LAB_1001d0f8:
    p_Var3 = (_Bigint *)0x0;
  }
  else {
    pp_Var4 = p_Var1->_freelist;
    if (pp_Var4 == (_Bigint **)0x0) goto LAB_1001d0e4;
LAB_1001d0a6:
    p_Var3 = pp_Var4[k];
    if (p_Var3 == (_Bigint *)0x0) {
      iVar2 = 1 << (k & 0x1fU);
      p_Var3 = (_Bigint *)_calloc_r(ptr,1,(iVar2 + 5) * 4);
      if (p_Var3 == (_Bigint *)0x0) goto LAB_1001d0f8;
      p_Var3->_k = k;
      p_Var3->_maxwds = iVar2;
    }
    else {
      pp_Var4[k] = p_Var3->_next;
    }
    p_Var3->_wds = 0;
    p_Var3->_sign = 0;
  }
  return p_Var3;
}



// WARNING: Unknown calling convention

void _Bfree(_reent *ptr,_Bigint *v)

{
  _mprec *p_Var1;
  _Bigint **pp_Var2;
  
  gp = &__global_pointer_;
  if (ptr->_mp == (_mprec *)0x0) {
    p_Var1 = (_mprec *)__wrap_malloc(0x10);
    ptr->_mp = p_Var1;
    if (p_Var1 == (_mprec *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x8f,(char *)0x0,
                    "REENT malloc succeeded");
    }
    p_Var1->_result_k = 0;
    p_Var1->_p5s = (_Bigint *)0x0;
    p_Var1->_result = (_Bigint *)0x0;
    p_Var1->_freelist = (_Bigint **)0x0;
  }
  if (v != (_Bigint *)0x0) {
    pp_Var2 = ptr->_mp->_freelist + v->_k;
    v->_next = *pp_Var2;
    *pp_Var2 = v;
  }
  return;
}



// WARNING: Unknown calling convention

_Bigint * __multadd(_reent *ptr,_Bigint *b,int m,int a)

{
  int iVar1;
  _Bigint *p_Var2;
  uint uVar3;
  uint uVar4;
  __ULong *p_Var5;
  int iVar6;
  
  gp = &__global_pointer_;
  iVar1 = b->_wds;
  iVar6 = 0;
  p_Var5 = b->_x;
  do {
    iVar6 = iVar6 + 1;
    uVar3 = (*p_Var5 & 0xffff) * m + a;
    uVar4 = (*p_Var5 >> 0x10) * m + (uVar3 >> 0x10);
    *p_Var5 = (uVar3 & 0xffff) + uVar4 * 0x10000;
    a = uVar4 >> 0x10;
    p_Var5 = p_Var5 + 1;
  } while (iVar6 < iVar1);
  p_Var2 = b;
  if (a != 0) {
    if (iVar1 < b->_maxwds) {
      b->_x[iVar1] = a;
      b->_wds = iVar1 + 1;
    }
    else {
      p_Var2 = _Balloc(ptr,b->_k + 1);
      if (p_Var2 == (_Bigint *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0xba,(char *)0x0,
                      "Balloc succeeded");
      }
      memcpy(&p_Var2->_sign,&b->_sign,(b->_wds + 2) * 4);
      _Bfree(ptr,b);
      p_Var2->_x[iVar1] = a;
      p_Var2->_wds = iVar1 + 1;
    }
  }
  return p_Var2;
}



// WARNING: Unknown calling convention

_Bigint * __s2b(_reent *ptr,char *s,int nd0,int nd,__ULong y9)

{
  byte bVar1;
  byte *pbVar2;
  _Bigint *b;
  int k;
  int iVar3;
  byte *pbVar4;
  
  gp = &__global_pointer_;
  if (nd < 10) {
    k = 0;
  }
  else {
    iVar3 = 1;
    k = 0;
    do {
      iVar3 = iVar3 << 1;
      k = k + 1;
    } while (iVar3 < (nd + 8) / 9);
  }
  b = _Balloc(ptr,k);
  if (b != (_Bigint *)0x0) {
    b->_wds = 1;
    b->_x[0] = y9;
    if (nd0 < 10) {
      pbVar2 = (byte *)(s + 10);
      nd0 = 9;
    }
    else {
      pbVar2 = (byte *)(s + 9);
      do {
        bVar1 = *pbVar2;
        pbVar2 = pbVar2 + 1;
        b = __multadd(ptr,b,10,bVar1 - 0x30);
      } while (pbVar2 != (byte *)(s + nd0));
      pbVar2 = (byte *)(s + 9 + nd0 + -8);
    }
    if (nd0 < nd) {
      pbVar4 = pbVar2 + (nd - nd0);
      do {
        bVar1 = *pbVar2;
        pbVar2 = pbVar2 + 1;
        b = __multadd(ptr,b,10,bVar1 - 0x30);
      } while (pbVar2 != pbVar4);
    }
    return b;
  }
                    // WARNING: Subroutine does not return
  __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0xd3,(char *)0x0,
                "Balloc succeeded");
}



// WARNING: Unknown calling convention

int __hi0bits(__ULong x)

{
  int iVar1;
  uint uVar2;
  
  gp = &__global_pointer_;
  iVar1 = 0;
  if (x < 0x10000) {
    x = x << 0x10;
    iVar1 = 0x10;
  }
  if (x < 0x1000000) {
    iVar1 = iVar1 + 8;
    x = x << 8;
  }
  if (x < 0x10000000) {
    iVar1 = iVar1 + 4;
    uVar2 = x << 4;
    if (0x3fffffff < x << 4) goto LAB_1001d38e;
    if ((int)(x << 6) < 0) goto LAB_1001d398;
    if (-1 < (int)(x << 7)) {
      return 0x20;
    }
  }
  else {
    uVar2 = x;
    if (0x3fffffff < x) {
LAB_1001d38e:
      return iVar1 - ((int)~uVar2 >> 0x1f);
    }
    if ((int)(x << 2) < 0) {
LAB_1001d398:
      return iVar1 + 2;
    }
  }
  return iVar1 + 3;
}



// WARNING: Unknown calling convention

int __lo0bits(__ULong *y)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  gp = &__global_pointer_;
  uVar2 = *y;
  if ((uVar2 & 7) != 0) {
    if ((uVar2 & 1) != 0) {
      return 0;
    }
    if ((uVar2 & 2) == 0) {
      *y = uVar2 >> 2;
      return 2;
    }
    *y = uVar2 >> 1;
    return 1;
  }
  if ((uVar2 & 0xffff) == 0) {
    uVar3 = uVar2 >> 0x10;
    iVar1 = 0x10;
    if ((uVar3 & 0xff) == 0) {
      iVar1 = 0x18;
      uVar3 = uVar2 >> 0x18;
    }
LAB_1001d3dc:
    if ((uVar3 & 0xf) == 0) {
      iVar1 = iVar1 + 4;
      uVar2 = uVar3;
      goto LAB_1001d406;
    }
  }
  else {
    if ((uVar2 & 0xff) == 0) {
      iVar1 = 8;
      uVar3 = uVar2 >> 8;
      goto LAB_1001d3dc;
    }
    if ((uVar2 & 0xf) != 0) {
      uVar2 = uVar2 >> 3;
      iVar1 = 3;
      goto LAB_1001d3f2;
    }
    iVar1 = 4;
LAB_1001d406:
    uVar3 = uVar2 >> 4;
  }
  if ((uVar3 & 3) == 0) {
    uVar2 = uVar3 >> 2;
    if ((uVar2 & 1) == 0) {
      uVar2 = uVar3 >> 3;
      if (uVar2 == 0) {
        return 0x20;
      }
      iVar1 = iVar1 + 3;
    }
    else {
      iVar1 = iVar1 + 2;
    }
  }
  else {
    uVar2 = uVar3;
    if ((uVar3 & 1) == 0) {
      iVar1 = iVar1 + 1;
      uVar2 = uVar3 >> 1;
    }
  }
LAB_1001d3f2:
  *y = uVar2;
  return iVar1;
}



// WARNING: Unknown calling convention

_Bigint * __i2b(_reent *ptr,int i)

{
  _Bigint *p_Var1;
  
  gp = &__global_pointer_;
  p_Var1 = _Balloc(ptr,1);
  if (p_Var1 != (_Bigint *)0x0) {
    p_Var1->_x[0] = i;
    p_Var1->_wds = 1;
    return p_Var1;
  }
                    // WARNING: Subroutine does not return
  __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x145,(char *)0x0,
                "Balloc succeeded");
}



// WARNING: Unknown calling convention

_Bigint * __multiply(_reent *ptr,_Bigint *a,_Bigint *b)

{
  int *piVar1;
  __ULong *p_Var2;
  _Bigint *p_Var3;
  _Bigint *p_Var4;
  __ULong *p_Var5;
  __ULong *p_Var6;
  __ULong *p_Var7;
  __ULong *p_Var8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  __ULong *p_Var12;
  __ULong *p_Var13;
  int iVar14;
  int iVar15;
  uint uVar16;
  int iVar17;
  __ULong *p_Var18;
  uint uVar19;
  uint uVar20;
  __ULong *p_Var21;
  
  gp = &__global_pointer_;
  iVar14 = a->_wds;
  iVar17 = b->_wds;
  p_Var3 = b;
  iVar15 = iVar14;
  if (iVar17 <= iVar14) {
    p_Var3 = a;
    iVar15 = iVar17;
    iVar17 = iVar14;
    a = b;
  }
  iVar14 = iVar17 + iVar15;
  p_Var4 = _Balloc(ptr,p_Var3->_k + (uint)(p_Var3->_maxwds < iVar14));
  if (p_Var4 == (_Bigint *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x162,(char *)0x0,
                  "Balloc succeeded");
  }
  p_Var13 = p_Var4->_x;
  p_Var12 = p_Var13 + iVar14;
  for (p_Var5 = p_Var13; p_Var5 < p_Var12; p_Var5 = p_Var5 + 1) {
    *p_Var5 = 0;
  }
  p_Var5 = a->_x;
  p_Var18 = p_Var3->_x;
  p_Var2 = p_Var5 + iVar15;
  p_Var8 = p_Var18 + iVar17;
  if (p_Var5 < p_Var2) {
    uVar19 = 0;
    if (p_Var8 < (ushort *)((int)p_Var3->_x + 1)) goto LAB_1001d512;
    uVar20 = *p_Var5;
    uVar19 = (int)p_Var8 + (-0x15 - (int)p_Var3) & 0xfffffffc;
    while( true ) {
      uVar11 = uVar20 & 0xffff;
      if (uVar11 != 0) {
        uVar20 = 0;
        p_Var6 = p_Var18;
        p_Var21 = p_Var13;
        do {
          uVar9 = *p_Var6;
          p_Var6 = p_Var6 + 1;
          uVar20 = (uVar9 & 0xffff) * uVar11 + (*p_Var21 & 0xffff) + uVar20;
          uVar9 = (uVar9 >> 0x10) * uVar11 + (*p_Var21 >> 0x10) + (uVar20 >> 0x10);
          *p_Var21 = uVar20 & 0xffff | uVar9 * 0x10000;
          uVar20 = uVar9 >> 0x10;
          p_Var21 = p_Var21 + 1;
        } while (p_Var6 < p_Var8);
        *(uint *)((int)p_Var13 + uVar19 + 4) = uVar20;
        uVar20 = *p_Var5;
      }
      uVar20 = uVar20 >> 0x10;
      if (uVar20 != 0) {
        uVar10 = *p_Var13;
        uVar9 = 0;
        p_Var6 = p_Var18;
        uVar11 = uVar10;
        p_Var21 = p_Var13;
        do {
          uVar16 = uVar10 >> 0x10;
          p_Var7 = p_Var6 + 1;
          uVar10 = p_Var21[1];
          uVar16 = (ushort)*p_Var6 * uVar20 + uVar9 + uVar16;
          *p_Var21 = uVar16 * 0x10000 | uVar11 & 0xffff;
          uVar11 = *(ushort *)((int)p_Var6 + 2) * uVar20 + (uVar10 & 0xffff) + (uVar16 >> 0x10);
          uVar9 = uVar11 >> 0x10;
          p_Var6 = p_Var7;
          p_Var21 = p_Var21 + 1;
        } while (p_Var7 < p_Var8);
        *(uint *)((int)p_Var13 + uVar19 + 4) = uVar11;
      }
      p_Var5 = p_Var5 + 1;
      p_Var13 = p_Var13 + 1;
      if (p_Var2 <= p_Var5) break;
LAB_1001d512:
      uVar20 = *p_Var5;
    }
  }
  if (0 < iVar14) {
    do {
      piVar1 = (int *)(p_Var12 + -1);
      p_Var12 = p_Var12 + -1;
      if (*piVar1 != 0) break;
      iVar14 = iVar14 + -1;
    } while (iVar14 != 0);
  }
  p_Var4->_wds = iVar14;
  return p_Var4;
}



// WARNING: Unknown calling convention

_Bigint * __pow5mult(_reent *ptr,_Bigint *b,int k)

{
  uint uVar1;
  _Bigint *a;
  _Bigint *p_Var2;
  uint uVar3;
  _mprec *p_Var4;
  
  gp = &__global_pointer_;
  if ((k & 3U) != 0) {
    b = __multadd(ptr,b,*(int *)("" + (k & 3U) * 4 + 0x100),0);
  }
  if (k >> 2 == 0) {
    return b;
  }
  p_Var4 = ptr->_mp;
  if (p_Var4 == (_mprec *)0x0) {
    p_Var4 = (_mprec *)__wrap_malloc(0x10);
    ptr->_mp = p_Var4;
    if (p_Var4 == (_mprec *)0x0) {
                    // WARNING: Subroutine does not return
      __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x1b3,(char *)0x0,
                    "REENT malloc succeeded");
    }
    p_Var4->_result_k = 0;
    p_Var4->_p5s = (_Bigint *)0x0;
    p_Var4->_result = (_Bigint *)0x0;
    p_Var4->_freelist = (_Bigint **)0x0;
  }
  else {
    a = p_Var4->_p5s;
    if (a != (_Bigint *)0x0) goto LAB_1001d64a;
  }
  a = _Balloc(ptr,1);
  if (a == (_Bigint *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x145,(char *)0x0,
                  "Balloc succeeded");
  }
  a->_x[0] = 0x271;
  a->_wds = 1;
  p_Var4->_p5s = a;
  a->_next = (_Bigint *)0x0;
LAB_1001d64a:
  uVar1 = k >> 3;
  p_Var2 = b;
  if ((k >> 2 & 1U) != 0) goto LAB_1001d660;
  do {
    do {
      p_Var2 = a->_next;
      if (p_Var2 == (_Bigint *)0x0) {
        p_Var2 = __multiply(ptr,a,a);
        a->_next = p_Var2;
        p_Var2->_next = (_Bigint *)0x0;
      }
      uVar3 = uVar1 & 1;
      uVar1 = (int)uVar1 >> 1;
      a = p_Var2;
      p_Var2 = b;
    } while (uVar3 == 0);
LAB_1001d660:
    b = __multiply(ptr,p_Var2,a);
    _Bfree(ptr,p_Var2);
  } while (uVar1 != 0);
  return b;
}



// WARNING: Unknown calling convention

_Bigint * __lshift(_reent *ptr,_Bigint *b,int k)

{
  __ULong *p_Var1;
  int iVar2;
  _Bigint *p_Var3;
  int k_00;
  uint uVar4;
  uint uVar5;
  int iVar6;
  __ULong *p_Var7;
  __ULong *p_Var8;
  __ULong *p_Var9;
  __ULong *p_Var10;
  int iVar11;
  int iVar12;
  
  gp = &__global_pointer_;
  iVar12 = k >> 5;
  iVar11 = b->_wds + iVar12;
  iVar2 = iVar11 + 1;
  k_00 = b->_k;
  for (iVar6 = b->_maxwds; iVar6 < iVar2; iVar6 = iVar6 << 1) {
    k_00 = k_00 + 1;
  }
  p_Var3 = _Balloc(ptr,k_00);
  if (p_Var3 == (_Bigint *)0x0) {
                    // WARNING: Subroutine does not return
    __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x1de,(char *)0x0,
                  "Balloc succeeded");
  }
  p_Var10 = p_Var3->_x;
  if (0 < iVar12) {
    p_Var9 = p_Var10;
    do {
      p_Var7 = p_Var9 + 1;
      *p_Var9 = 0;
      p_Var9 = p_Var7;
    } while (p_Var7 != p_Var3->_x + iVar12);
    p_Var10 = p_Var10 + iVar12;
  }
  p_Var9 = b->_x;
  uVar4 = k & 0x1f;
  p_Var7 = p_Var9 + b->_wds;
  if (uVar4 == 0) {
    do {
      p_Var1 = p_Var9 + 1;
      *p_Var10 = *p_Var9;
      if (p_Var7 <= p_Var1) break;
      p_Var9 = p_Var9 + 2;
      p_Var10[1] = *p_Var1;
      p_Var10 = p_Var10 + 2;
    } while (p_Var9 < p_Var7);
  }
  else {
    uVar5 = 0;
    p_Var1 = p_Var10;
    do {
      p_Var8 = p_Var9 + 1;
      *p_Var1 = *p_Var9 << uVar4 | uVar5;
      uVar5 = *p_Var9 >> (0x20 - uVar4 & 0x1f);
      p_Var1 = p_Var1 + 1;
      p_Var9 = p_Var8;
    } while (p_Var8 < p_Var7);
    uVar4 = 0;
    if ((__ULong *)((int)b->_x + 1) <= p_Var7) {
      uVar4 = (int)p_Var7 + (-0x15 - (int)b) & 0xfffffffc;
    }
    *(uint *)((int)p_Var10 + uVar4 + 4) = uVar5;
    if (uVar5 != 0) goto LAB_1001d7d4;
  }
  iVar2 = iVar11;
LAB_1001d7d4:
  p_Var3->_wds = iVar2;
  _Bfree(ptr,b);
  return p_Var3;
}



// WARNING: Unknown calling convention

int __mcmp(_Bigint *a,_Bigint *b)

{
  int *piVar1;
  int *piVar2;
  __ULong *p_Var3;
  int iVar4;
  __ULong *p_Var5;
  
  gp = &__global_pointer_;
  iVar4 = b->_wds;
  if (a->_wds == iVar4) {
    p_Var3 = b->_x + iVar4;
    p_Var5 = a->_x + iVar4;
    do {
      piVar1 = (int *)(p_Var5 + -1);
      piVar2 = (int *)(p_Var3 + -1);
      p_Var5 = p_Var5 + -1;
      p_Var3 = p_Var3 + -1;
      if (*piVar1 != *piVar2) {
        if ((uint)*piVar2 <= (uint)*piVar1) {
          gp = &__global_pointer_;
          return 1;
        }
        return -1;
      }
    } while (a->_x < p_Var5);
  }
  return a->_wds - iVar4;
}



// WARNING: Unknown calling convention

_Bigint * __mdiff(_reent *ptr,_Bigint *a,_Bigint *b)

{
  int *piVar1;
  int *piVar2;
  __ULong *p_Var3;
  __ULong *p_Var4;
  _Bigint *p_Var5;
  _Bigint *p_Var6;
  uint *puVar7;
  __ULong *p_Var8;
  uint *puVar9;
  __ULong *p_Var10;
  uint uVar11;
  int iVar12;
  int iVar13;
  __ULong *p_Var14;
  uint uVar15;
  int iVar16;
  uint *puVar17;
  int iVar18;
  __ULong *p_Var19;
  __ULong *p_Var20;
  
  gp = &__global_pointer_;
  iVar13 = b->_wds;
  iVar16 = a->_wds - iVar13;
  p_Var6 = b;
  if (a->_wds == iVar13) {
    p_Var14 = a->_x + iVar13;
    p_Var10 = b->_x + iVar13;
    while( true ) {
      piVar1 = (int *)(p_Var14 + -1);
      piVar2 = (int *)(p_Var10 + -1);
      p_Var14 = p_Var14 + -1;
      p_Var10 = p_Var10 + -1;
      if (*piVar1 != *piVar2) break;
      if (p_Var14 <= a->_x) {
        p_Var6 = _Balloc(ptr,0);
        if (p_Var6 != (_Bigint *)0x0) {
          p_Var6->_x[0] = 0;
          p_Var6->_wds = 1;
          return p_Var6;
        }
                    // WARNING: Subroutine does not return
        __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x237,(char *)0x0,
                      "Balloc succeeded");
      }
    }
    if ((uint)*piVar2 <= (uint)*piVar1) goto LAB_1001d8bc;
  }
  else if (-1 < iVar16) {
    iVar16 = 0;
    goto LAB_1001d8bc;
  }
  iVar16 = 1;
  p_Var6 = a;
  a = b;
LAB_1001d8bc:
  p_Var5 = _Balloc(ptr,a->_k);
  if (p_Var5 != (_Bigint *)0x0) {
    iVar13 = a->_wds;
    iVar18 = p_Var6->_wds;
    p_Var4 = a->_x;
    p_Var8 = p_Var6->_x;
    p_Var20 = p_Var5->_x;
    p_Var5->_sign = iVar16;
    p_Var3 = p_Var4 + iVar13;
    p_Var19 = p_Var8 + iVar18;
    iVar16 = 0;
    p_Var10 = p_Var20;
    p_Var14 = p_Var4;
    do {
      uVar15 = ((*p_Var14 & 0xffff) - (*p_Var8 & 0xffff)) + iVar16;
      iVar16 = ((*p_Var14 >> 0x10) - (*p_Var8 >> 0x10)) + ((int)uVar15 >> 0x10);
      uVar15 = uVar15 & 0xffff | iVar16 * 0x10000;
      p_Var8 = p_Var8 + 1;
      *p_Var10 = uVar15;
      p_Var14 = p_Var14 + 1;
      iVar16 = iVar16 >> 0x10;
      p_Var10 = p_Var10 + 1;
    } while (p_Var8 < p_Var19);
    uVar11 = 0;
    if ((undefined1 *)((int)p_Var6->_x + 1) <= p_Var19) {
      uVar11 = (uint)((int)p_Var19 + (-0x15 - (int)p_Var6)) & 0xfffffffc;
    }
    puVar17 = (uint *)((int)p_Var4 + uVar11 + 4);
    iVar18 = uVar11 + (int)p_Var20;
    puVar9 = puVar17;
    if (puVar17 < p_Var3) {
      do {
        uVar15 = *puVar9;
        puVar7 = (uint *)((int)puVar9 + ((int)p_Var20 - (int)p_Var4));
        puVar9 = puVar9 + 1;
        iVar12 = ((int)((uVar15 & 0xffff) + iVar16) >> 0x10) + (uVar15 >> 0x10);
        uVar15 = uVar15 + iVar16 & 0xffff | iVar12 * 0x10000;
        *puVar7 = uVar15;
        iVar16 = iVar12 >> 0x10;
      } while (puVar9 < p_Var3);
      iVar18 = ((int)p_Var3 + (-1 - (int)puVar17) & 0xfffffffcU) + iVar18 + 4;
    }
    while (uVar15 == 0) {
      puVar9 = (uint *)(iVar18 + -4);
      iVar18 = iVar18 + -4;
      iVar13 = iVar13 + -1;
      uVar15 = *puVar9;
    }
    p_Var5->_wds = iVar13;
    return p_Var5;
  }
                    // WARNING: Subroutine does not return
  __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x245,(char *)0x0,
                "Balloc succeeded");
}



uint __ulp(double _x)

{
  uint in_a1;
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  gp = &__global_pointer_;
  iVar1 = (in_a1 & 0x7ff00000) + 0xfcc00000;
  if (0 < iVar1) {
    return 0;
  }
  iVar1 = -iVar1 >> 0x14;
  if (iVar1 < 0x14) {
    return 0;
  }
  uVar2 = iVar1 - 0x14;
  uVar3 = 1;
  if ((int)uVar2 < 0x1f) {
    uVar3 = 0x80000000 >> (uVar2 & 0x1f);
  }
  return uVar3;
}



// WARNING: Unknown calling convention

__ULong __b2d(_Bigint *a,int *e)

{
  __ULong *p_Var1;
  int iVar2;
  int iVar3;
  uint uVar4;
  __ULong _Var5;
  
  gp = &__global_pointer_;
  iVar2 = a->_wds;
  p_Var1 = a->_x;
  _Var5 = p_Var1[iVar2 + -1];
  iVar3 = __hi0bits(_Var5);
  *e = 0x20 - iVar3;
  if (iVar3 < 0xb) {
    uVar4 = 0;
    if (p_Var1 < p_Var1 + iVar2 + -1) {
      uVar4 = p_Var1[iVar2 + -2] >> (0xbU - iVar3 & 0x1f);
    }
    _Var5 = _Var5 << (iVar3 + 0x15U & 0x1f) | uVar4;
  }
  else {
    uVar4 = iVar3 - 0xb;
    if (p_Var1 < p_Var1 + iVar2 + -1) {
      _Var5 = p_Var1[iVar2 + -2];
      if (uVar4 != 0) {
        _Var5 = _Var5 << (uVar4 & 0x1f);
        if (p_Var1 < p_Var1 + iVar2 + -2) {
          _Var5 = _Var5 | p_Var1[iVar2 + -3] >> (0x20 - uVar4 & 0x1f);
        }
      }
    }
    else if (iVar3 == 0xb) {
      _Var5 = 0;
    }
    else {
      _Var5 = 0;
    }
  }
  return _Var5;
}



_Bigint * __d2b(_reent *ptr,double _d,int *e,int *bits)

{
  int iVar1;
  _Bigint *p_Var2;
  int iVar3;
  __ULong x;
  uint uVar4;
  int *in_a3;
  int *piVar5;
  int *in_a4;
  uint uVar6;
  uint uVar7;
  int *piStack_28;
  __ULong y;
  __ULong z;
  
  gp = &__global_pointer_;
  p_Var2 = _Balloc(ptr,1);
  if (p_Var2 != (_Bigint *)0x0) {
    uVar7 = (uint)bits >> 0x14 & 0x7ff;
    y = (uint)bits & 0xfffff;
    if (uVar7 != 0) {
      y = y | 0x100000;
    }
    if (e == (int *)0x0) {
      iVar3 = __lo0bits(&y);
      iVar1 = 1;
      p_Var2->_wds = 1;
      p_Var2->_x[0] = y;
      uVar6 = iVar3 + 0x20;
    }
    else {
      piStack_28 = e;
      uVar6 = __lo0bits((__ULong *)&piStack_28);
      piVar5 = piStack_28;
      if (uVar6 != 0) {
        uVar4 = y << (0x20 - uVar6 & 0x1f);
        y = y >> (uVar6 & 0x1f);
        piVar5 = (int *)((uint)piStack_28 | uVar4);
      }
      iVar1 = (y != 0) + 1;
      p_Var2->_x[0] = (__ULong)piVar5;
      p_Var2[1]._next = (_Bigint *)y;
      p_Var2->_wds = iVar1;
    }
    if (uVar7 == 0) {
      x = p_Var2->_x[iVar1 + -1];
      *in_a3 = uVar6 - 0x432;
      iVar3 = __hi0bits(x);
      iVar3 = iVar1 * 0x20 - iVar3;
    }
    else {
      *in_a3 = (uVar7 - 0x433) + uVar6;
      iVar3 = 0x35 - uVar6;
    }
    *in_a4 = iVar3;
    return p_Var2;
  }
                    // WARNING: Subroutine does not return
  __assert_func("/workdir/repo/newlib/newlib/libc/stdlib/mprec.c",0x30f,(char *)0x0,
                "Balloc succeeded");
}



// WARNING: Unknown calling convention

void __ratio(_Bigint *a,_Bigint *b)

{
  int iStack_38;
  int ka;
  int kb;
  
  gp = &__global_pointer_;
  __b2d(a,&iStack_38);
  __b2d(b,&ka);
  __divdf3(DRam00000010,DRam00000018);
  return;
}



// WARNING: Unknown calling convention

undefined4 _mprec_log10(int dig)

{
  undefined4 uVar1;
  
  gp = &__global_pointer_;
  if (dig < 0x18) {
    return *(undefined4 *)(__mprec_tens + dig);
  }
  do {
    dig = dig + -1;
    uVar1 = __muldf3(DRam00000010,DRam00000018);
  } while (dig != 0);
  return uVar1;
}



// WARNING: Unknown calling convention

void __copybits(__ULong *c,int n,_Bigint *b)

{
  __ULong *p_Var1;
  __ULong *p_Var2;
  __ULong *p_Var3;
  __ULong *x;
  __ULong *p_Var4;
  __ULong _Var5;
  
  gp = &__global_pointer_;
  p_Var4 = b->_x;
  p_Var2 = p_Var4 + b->_wds;
  p_Var1 = c + (n + -1 >> 5) + 1;
  p_Var3 = c;
  if (p_Var4 < p_Var2) {
    do {
      _Var5 = *p_Var4;
      p_Var4 = p_Var4 + 1;
      *p_Var3 = _Var5;
      p_Var3 = p_Var3 + 1;
    } while (p_Var4 < p_Var2);
    c = (__ULong *)((int)c + ((int)p_Var2 + (-0x15 - (int)b) & 0xfffffffcU) + 4);
  }
  for (; c < p_Var1; c = c + 1) {
    *c = 0;
  }
  return;
}



// WARNING: Unknown calling convention

__ULong __any_on(_Bigint *b,int k)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  __ULong *p_Var4;
  int iVar5;
  __ULong *p_Var6;
  
  gp = &__global_pointer_;
  iVar5 = b->_wds;
  iVar3 = k >> 5;
  p_Var4 = b->_x;
  if (iVar5 < iVar3) {
    p_Var6 = p_Var4 + iVar5;
  }
  else {
    p_Var6 = p_Var4 + iVar3;
    if (((iVar3 < iVar5) && (uVar2 = k & 0x1f, uVar2 != 0)) &&
       (*p_Var6 != (*p_Var6 >> uVar2) << uVar2)) {
      return 1;
    }
  }
  do {
    if (p_Var6 <= p_Var4) {
      return 0;
    }
    piVar1 = (int *)(p_Var6 + -1);
    p_Var6 = p_Var6 + -1;
  } while (*piVar1 == 0);
  return 1;
}



// WARNING: Unknown calling convention

lconv * __localeconv_l(__locale_t *locale)

{
  gp = &__global_pointer_;
  return &locale->lconv;
}



// WARNING: Unknown calling convention

lconv * _localeconv_r(_reent *data)

{
  gp = &__global_pointer_;
  return &__global_locale.lconv;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

lconv * localeconv(void)

{
  gp = &__global_pointer_;
  return (lconv *)&__global_locale.lconv;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int _vfprintf_r(_reent *data,FILE *fp,char *fmt0,va_list ap)

{
  bool bVar1;
  undefined1 a [16];
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  undefined1 uVar9;
  size_t *psVar10;
  lconv *plVar11;
  size_t sVar12;
  int *extraout_a0;
  void *pvVar13;
  __gcc_CMPtype _Var14;
  char *pcVar15;
  int iVar16;
  byte bVar17;
  uint extraout_a1;
  undefined1 *puVar18;
  byte bVar19;
  size_t *psVar20;
  uint uVar21;
  __siov *p_Var22;
  uint uVar23;
  undefined1 *puVar24;
  byte bVar25;
  char cVar26;
  uint uVar27;
  undefined1 *puVar28;
  ushort uVar29;
  char *__s;
  uint uVar30;
  int *piVar31;
  uint uVar32;
  uint *puVar33;
  undefined1 *puVar34;
  int iVar35;
  byte *pbVar36;
  byte *pbVar37;
  size_t *psVar38;
  byte *pbVar39;
  byte *pbVar40;
  undefined4 *puVar41;
  size_t *psVar42;
  size_t *psVar43;
  byte *pbVar44;
  uint uVar45;
  byte *pbVar46;
  int iStack_214;
  size_t *psStack_210;
  uint *puStack_20c;
  int iStack_208;
  byte *pbStack_200;
  int iStack_1fc;
  uint uStack_1f8;
  int *piStack_1f4;
  byte *pbStack_1e4;
  char *pcStack_1dc;
  char *pcStack_1d0;
  int iStack_1cc;
  size_t sStack_1c8;
  byte *pbStack_1c4;
  char cStack_10d;
  undefined2 uStack_10c;
  char sign;
  char ox [2];
  int expt;
  int dsgn;
  char expstr [7];
  char *rve;
  undefined1 auStack_f0 [4];
  __suio uio;
  __siov iov [8];
  char buf [100];
  
  gp = &__global_pointer_;
  plVar11 = _localeconv_r(data);
  __s = plVar11->decimal_point;
  sVar12 = strlen(__s);
  if ((data != (_reent *)0x0) && (data->__cleanup == (_func_void__reent_ptr *)0x0)) {
    __sinit(data);
  }
  uVar21 = fp->_flags2;
  uVar29 = fp->_flags;
  uVar27 = (uint)(short)uVar29;
  if ((uVar21 & 1) == 0) {
    if ((uVar27 & 0x200) == 0) {
      __retarget_lock_acquire_recursive(&fp->_lock);
      uVar29 = fp->_flags;
      uVar27 = (uint)(short)uVar29;
      uVar21 = fp->_flags2;
      if ((int)(uVar27 << 0x12) < 0) {
        if ((int)(uVar21 << 0x12) < 0) {
          if ((uVar21 & 1) != 0) {
            return -1;
          }
          goto LAB_1001ebde;
        }
        goto LAB_1001ddfc;
      }
LAB_1001dde6:
      fp->_flags = uVar29 | 0x2000;
      fp->_flags2 = uVar21 & 0xffffdfff;
      uVar27 = (uint)(short)(uVar29 | 0x2000);
      goto LAB_1001ddfc;
    }
    if (-1 < (int)(uVar27 << 0x12)) goto LAB_1001dde6;
    if (-1 < (int)(uVar21 << 0x12)) goto LAB_1001ddfc;
LAB_1001ebde:
    uVar29 = fp->_flags;
joined_r0x1001ebe8:
    if ((uVar29 & 0x200) == 0) {
      __retarget_lock_release_recursive(&fp->_lock);
    }
  }
  else {
    if (-1 < (int)(uVar27 << 0x12)) goto LAB_1001dde6;
    if ((int)(uVar21 << 0x12) < 0) {
      return -1;
    }
LAB_1001ddfc:
    if (((uVar27 & 8) == 0) || ((fp->_bf)._base == (uchar *)0x0)) {
      iVar35 = __swsetup_r(data,fp);
      if (iVar35 != 0) {
        if ((fp->_flags2 & 1U) != 0) {
          return -1;
        }
        uVar29 = fp->_flags;
        goto joined_r0x1001ebe8;
      }
      uVar27 = (uint)fp->_flags;
    }
    if (((uVar27 & 0x1a) == 10) && (-1 < fp->_file)) {
      if (((fp->_flags2 & 1U) == 0) && ((uVar27 & 0x200) == 0)) {
        __retarget_lock_release_recursive(&fp->_lock);
      }
      iVar35 = __sbprintf(data,fp,fmt0,ap);
      return iVar35;
    }
    auStack_f0 = (undefined1  [4])&uio.uio_resid;
    uio.uio_iovcnt = 0;
    uio.uio_iov = (__siov *)0x0;
    bVar25 = *fmt0;
    pbStack_200 = (byte *)0x0;
    pcStack_1dc = (char *)0x0;
    pbStack_1e4 = (byte *)0x0;
    sStack_1c8 = 0;
    pcStack_1d0 = (char *)0x0;
    iStack_214 = 0;
    puStack_20c = (uint *)ap;
    psVar43 = (size_t *)fmt0;
    psVar10 = (size_t *)auStack_f0;
    if (bVar25 != 0) {
LAB_1001de74:
      if (bVar25 == 0x25) {
        iVar35 = (int)fmt0 - (int)psVar43;
        if ((size_t *)fmt0 != psVar43) goto LAB_1001de88;
        bVar25 = (byte)*(size_t *)fmt0;
      }
      else {
        bVar25 = *(byte *)((int)fmt0 + 1);
        fmt0 = (char *)((int)fmt0 + 1);
        if (bVar25 != 0) goto LAB_1001de74;
        iVar35 = (int)fmt0 - (int)psVar43;
        if ((size_t *)fmt0 == psVar43) goto LAB_1001dfde;
LAB_1001de88:
        *psVar10 = (size_t)psVar43;
        psVar10[1] = iVar35;
        uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar16 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar16 != 0) goto LAB_1001eb0c;
          psVar10 = &uio.uio_resid;
        }
        bVar25 = (byte)*(size_t *)fmt0;
        iStack_214 = iStack_214 + iVar35;
      }
      if (bVar25 != 0) {
        uVar27 = (uint)*(byte *)((int)fmt0 + 1);
        cStack_10d = '\0';
        pbVar36 = (byte *)0xffffffff;
        bVar25 = 0;
        bVar8 = false;
        bVar7 = false;
        bVar6 = false;
        bVar5 = false;
        bVar4 = false;
        bVar3 = false;
        bVar2 = false;
        bVar1 = false;
        pbVar39 = (byte *)0x0;
        fmt0 = (char *)((int)fmt0 + 1);
LAB_1001ded2:
        fmt0 = (char *)((int)fmt0 + 1);
LAB_1001ded4:
        uVar9 = (undefined1)uVar27;
        pbVar44 = pbVar36;
        bVar19 = bVar25;
        pbVar37 = pbVar36;
        switch(uVar27) {
        case 0x20:
          goto switchD_1001deea_caseD_20;
        default:
          if (uVar27 == 0) goto LAB_1001dfde;
LAB_1001defc:
          iov[7].iov_len._0_1_ = uVar9;
          cStack_10d = '\0';
          psStack_210 = (size_t *)0x0;
          iStack_208 = 0;
          iStack_1fc = 0;
          pbVar40 = (byte *)0x0;
          psVar43 = &iov[7].iov_len;
          pbVar37 = (byte *)0x0;
          pbVar44 = &DAT_00000001;
          pbVar46 = &DAT_00000001;
          goto joined_r0x1001e2fc;
        case 0x23:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          bVar8 = true;
          goto LAB_1001ded2;
        case 0x27:
          plVar11 = _localeconv_r(data);
          pcStack_1d0 = plVar11->thousands_sep;
          sStack_1c8 = strlen(pcStack_1d0);
          plVar11 = _localeconv_r(data);
          pbStack_1e4 = (byte *)plVar11->grouping;
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          if (((sStack_1c8 != 0) && (pbStack_1e4 != (byte *)0x0)) && (*pbStack_1e4 != 0)) {
            bVar6 = true;
          }
          goto LAB_1001ded2;
        case 0x2a:
          pbVar39 = (byte *)*puStack_20c;
          puStack_20c = puStack_20c + 1;
          if ((int)pbVar39 < 0) {
            pbVar39 = (byte *)-(int)pbVar39;
            goto switchD_1001deea_caseD_2d;
          }
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          goto LAB_1001ded2;
        case 0x2b:
          cStack_10d = '+';
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          goto LAB_1001ded2;
        case 0x2d:
switchD_1001deea_caseD_2d:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          bVar25 = bVar25 | 4;
          goto LAB_1001ded2;
        case 0x2e:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          psVar42 = (size_t *)((int)fmt0 + 1);
          if (uVar27 == 0x2a) {
            pbVar36 = (byte *)*puStack_20c;
            puStack_20c = puStack_20c + 1;
            if ((int)pbVar36 < 0) {
              pbVar36 = (byte *)0xffffffff;
            }
            uVar27 = (uint)*(byte *)((int)fmt0 + 1);
            fmt0 = (char *)psVar42;
            goto LAB_1001ded2;
          }
          uVar21 = uVar27 - 0x30;
          pbVar36 = (byte *)0x0;
          fmt0 = (char *)psVar42;
          if (uVar21 < 10) {
            do {
              uVar27 = (uint)(byte)*psVar42;
              pbVar36 = (byte *)((int)pbVar36 * 10 + uVar21);
              uVar21 = uVar27 - 0x30;
              psVar42 = (size_t *)((int)psVar42 + 1);
            } while (uVar21 < 10);
            fmt0 = (char *)psVar42;
            if ((int)pbVar36 < 0) {
              pbVar36 = (byte *)0xffffffff;
            }
          }
          goto LAB_1001ded4;
        case 0x30:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          bVar25 = bVar25 | 0x80;
          goto LAB_1001ded2;
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x38:
        case 0x39:
          goto switchD_1001deea_caseD_31;
        case 0x41:
        case 0x45:
        case 0x46:
        case 0x47:
        case 0x61:
        case 0x65:
        case 0x66:
        case 0x67:
          if (bVar2) {
            puStack_20c = puStack_20c + 1;
            a._8_8_ = DRam00000018;
            a._0_8_ = dRam00000010;
            __trunctfdf2((TFtype)a);
            uStack_1f8 = extraout_a1;
            piStack_1f4 = extraout_a0;
          }
          else {
            puVar41 = (undefined4 *)((int)puStack_20c + 7U & 0xfffffff8);
            piStack_1f4 = (int *)*puVar41;
            uStack_1f8 = puVar41[1];
            puStack_20c = puVar41 + 2;
          }
          _Var14 = __unorddf2(dRam00000010,DRam00000018);
          if ((_Var14 == 0) && (_Var14 = __ledf2(dRam00000010,DRam00000018), 0 < _Var14)) {
            _Var14 = __ledf2(dRam00000010,DRam00000018);
            if (_Var14 < 0) {
              cStack_10d = '-';
              if (uVar27 < 0x48) {
                psVar43 = (size_t *)&UNK_10022528;
              }
              else {
                psVar43 = (size_t *)&UNK_1002252c;
              }
            }
            else {
              if (uVar27 < 0x48) {
                psVar43 = (size_t *)&UNK_10022528;
              }
              else {
                psVar43 = (size_t *)&UNK_1002252c;
              }
              if (cStack_10d == '\0') {
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x3;
                bVar25 = bVar25 & 0x7f;
                goto LAB_1001e2e8;
              }
            }
          }
          else {
            _Var14 = __unorddf2(dRam00000010,DRam00000018);
            if (_Var14 == 0) {
              if (uVar27 == 0x61) {
                uStack_10c = 0x7830;
                bVar19 = bVar25 | 2;
                if (99 < (int)pbVar36) {
LAB_1001fef8:
                  bVar25 = bVar25 | 2;
                  psVar43 = (size_t *)_malloc_r(data,(size_t)(pbVar36 + 1));
                  psStack_210 = psVar43;
                  if (psVar43 != (size_t *)0x0) goto LAB_1001f276;
                  fp->_flags = fp->_flags | 0x40;
                  goto LAB_1001eb0c;
                }
                if ((int)uStack_1f8 < 0) goto LAB_1001ff1c;
                frexp(dRam00000010,piStack_1f4);
                __muldf3(dRam00000010,DRam00000018);
                _Var14 = __eqdf2(dRam00000010,DRam00000018);
                if (_Var14 != 0) {
                  pcVar15 = "0123456789abcdef";
                  iStack_1cc = 0;
                  psStack_210 = (size_t *)0x0;
                  psVar43 = &iov[7].iov_len;
                  psVar42 = psVar43;
                  bVar25 = bVar19;
                  goto LAB_1001f5fe;
                }
                _ox = &DAT_00000001;
                iStack_1cc = 0;
                psStack_210 = (size_t *)0x0;
                psVar43 = &iov[7].iov_len;
              }
              else {
                if (uVar27 != 0x41) {
                  if (pbVar36 == (byte *)0xffffffff) {
                    psStack_210 = (size_t *)0x0;
                    pbVar36 = (byte *)0x6;
LAB_1001f276:
                    iStack_1cc = 0;
                    if ((int)uStack_1f8 < 0) {
                      uStack_1f8 = uStack_1f8 ^ 0x80000000;
                      iStack_1cc = 0x2d;
                    }
                    switch(uVar27) {
                    case 0x41:
                    case 0x61:
                      goto switchD_1001f2a6_caseD_41;
                    default:
                      psVar43 = (size_t *)
                                _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,(int *)0x2,
                                        (int *)pbVar36,(char **)ox);
                      goto LAB_1001f856;
                    case 0x45:
                    case 0x65:
                      pbStack_200 = pbVar36 + 1;
                      piVar31 = (int *)0x2;
                      break;
                    case 0x46:
                    case 0x66:
                      piVar31 = (int *)0x3;
                      pbStack_200 = pbVar36;
                    }
                    psVar43 = (size_t *)
                              _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,piVar31,
                                      (int *)pbStack_200,(char **)ox);
                    pbStack_1c4 = (byte *)((int)psVar43 + (int)pbStack_200);
                    if ((uVar27 & 0xffffffdf) != 0x46) {
                      _Var14 = __eqdf2(dRam00000010,DRam00000018);
                      if (_Var14 == 0) goto LAB_1001f998;
                      iVar35 = 0x45;
                      if (stack0xffffff08 < pbStack_1c4) goto LAB_1001f96a;
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)psVar43);
                      goto LAB_1001f998;
                    }
                    iVar35 = 0x46;
                    if ((byte)*psVar43 != 0x30) {
LAB_1001fdae:
                      pbStack_1c4 = pbStack_1c4 + (int)_ox;
                      goto LAB_1001fdb0;
                    }
                    _Var14 = __eqdf2(dRam00000010,DRam00000018);
                    if (_Var14 != 0) {
                      _ox = (byte *)(1 - (int)pbStack_200);
                      goto LAB_1001fdae;
                    }
                    pbStack_1c4 = pbStack_1c4 + (int)_ox;
                  }
                  else {
                    if (uVar27 == 0x67) {
                      if (pbVar36 == (byte *)0x0) {
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                          pbVar36 = &DAT_00000001;
                        }
                        else {
                          iStack_1cc = 0;
                          pbVar36 = &DAT_00000001;
                        }
                      }
                      else {
                        iStack_1cc = 0;
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                        }
                      }
                    }
                    else {
                      psStack_210 = (size_t *)0x0;
                      if (uVar27 != 0x47) goto LAB_1001f276;
                      if (pbVar36 == (byte *)0x0) {
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                          pbVar36 = &DAT_00000001;
                        }
                        else {
                          iStack_1cc = 0;
                          pbVar36 = &DAT_00000001;
                        }
                      }
                      else {
                        iStack_1cc = 0;
                        if ((int)uStack_1f8 < 0) {
                          uStack_1f8 = uStack_1f8 ^ 0x80000000;
                          iStack_1cc = 0x2d;
                        }
                      }
                    }
                    psVar43 = (size_t *)
                              _dtoa_r(data,dRam00000010,(int)piStack_1f4,uStack_1f8,(int *)0x2,
                                      (int *)pbVar36,(char **)ox);
                    psStack_210 = (size_t *)0x0;
LAB_1001f856:
                    if (!bVar8) {
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)psVar43);
                      if ((int)_ox < -3) goto LAB_1001fe46;
                      if ((int)pbVar36 < (int)_ox) goto LAB_1001fd64;
                      pbVar46 = _ox;
                      if ((int)_ox < (int)pbStack_200) goto LAB_1001fec4;
                      goto LAB_1001f87c;
                    }
                    pbStack_1c4 = (byte *)((int)psVar43 + (int)pbVar36);
                    iVar35 = 0x47;
LAB_1001fdb0:
                    _Var14 = __eqdf2(dRam00000010,DRam00000018);
                    if (_Var14 != 0) {
                      if (stack0xffffff08 < pbStack_1c4) goto LAB_1001f96a;
                      pbStack_200 = (byte *)((int)stack0xffffff08 - (int)psVar43);
                      if (iVar35 != 0x47) goto LAB_1001fdf2;
                      goto LAB_1001fd5a;
                    }
                  }
                  pbStack_200 = pbStack_1c4 + -(int)psVar43;
                  if (iVar35 == 0x47) goto LAB_1001fd5a;
                  goto LAB_1001fdf2;
                }
                uStack_10c = 0x5830;
                if (99 < (int)pbVar36) goto LAB_1001fef8;
                if (-1 < (int)uStack_1f8) {
                  frexp(dRam00000010,piStack_1f4);
                  __muldf3(dRam00000010,DRam00000018);
                  _Var14 = __eqdf2(dRam00000010,DRam00000018);
                  if (_Var14 == 0) {
                    _ox = &DAT_00000001;
                  }
                  pcVar15 = "0123456789ABCDEF";
                  iStack_1cc = 0;
                  psStack_210 = (size_t *)0x0;
                  psVar43 = &iov[7].iov_len;
                  psVar42 = psVar43;
                  bVar25 = bVar25 | 2;
                  goto LAB_1001f5fe;
                }
LAB_1001ff1c:
                bVar25 = bVar25 | 2;
                psStack_210 = (size_t *)0x0;
                psVar43 = &iov[7].iov_len;
                iStack_1cc = 0x2d;
switchD_1001f2a6_caseD_41:
                frexp(dRam00000010,piStack_1f4);
                __muldf3(dRam00000010,DRam00000018);
                _Var14 = __eqdf2(dRam00000010,DRam00000018);
                if (_Var14 == 0) {
                  _ox = &DAT_00000001;
                }
                bVar19 = bVar25;
                if (uVar27 != 0x61) {
                  pcVar15 = "0123456789ABCDEF";
                  psVar42 = psVar43;
                  goto LAB_1001f5fe;
                }
              }
              pcVar15 = "0123456789abcdef";
              psVar42 = psVar43;
              bVar25 = bVar19;
              goto LAB_1001f5fe;
            }
            bVar1 = false;
            if ((uStack_1f8 & 0x80000000) == 0) {
              if (uVar27 < 0x48) {
                psVar43 = (size_t *)&UNK_10022530;
              }
              else {
                psVar43 = (size_t *)&UNK_10022534;
              }
              pbVar40 = (byte *)0x0;
              if (cStack_10d == '\0') {
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x3;
                iStack_208 = 0;
                iStack_1fc = 0;
                psStack_210 = (size_t *)0x0;
                pbVar37 = (byte *)0x0;
                bVar25 = bVar25 & 0x7f;
              }
              else {
                iStack_208 = 0;
                iStack_1fc = 0;
                psStack_210 = (size_t *)0x0;
                pbVar46 = (byte *)0x3;
                pbVar44 = (byte *)0x4;
                pbVar37 = (byte *)0x0;
                bVar25 = bVar25 & 0x7f;
              }
              goto joined_r0x1001e2fc;
            }
            cStack_10d = '-';
            if (uVar27 < 0x48) {
              psVar43 = (size_t *)&UNK_10022530;
            }
            else {
              psVar43 = (size_t *)&UNK_10022534;
            }
          }
          bVar1 = false;
          psStack_210 = (size_t *)0x0;
          pbVar46 = (byte *)0x3;
          iStack_208 = 0;
          iStack_1fc = 0;
          pbVar40 = (byte *)0x0;
          pbVar44 = (byte *)0x4;
          pbVar37 = (byte *)0x0;
          bVar25 = bVar25 & 0x7f;
          goto joined_r0x1001e2fc;
        case 0x43:
        case 99:
          uVar21 = *puStack_20c;
          puStack_20c = puStack_20c + 1;
          uVar9 = (char)uVar21;
          goto LAB_1001defc;
        case 0x44:
          if (bVar3) goto LAB_1001e51a;
LAB_1001ef40:
          uVar21 = *puStack_20c;
          uVar23 = (int)uVar21 >> 0x1f;
LAB_1001e4d6:
          puStack_20c = puStack_20c + 1;
          if (-1 < (int)uVar23) goto LAB_1001e4da;
LAB_1001e530:
          cStack_10d = '-';
          uVar23 = -(uint)(uVar21 != 0) - uVar23;
          uVar21 = -uVar21;
          if (-1 < (int)pbVar36) {
            bVar19 = bVar25 & 0x7f;
          }
LAB_1001e550:
          bVar25 = bVar19;
          puVar33 = puStack_20c;
          if (uVar23 == 0) {
joined_r0x1001e82e:
            puStack_20c = puVar33;
            if (uVar21 < 10) goto LAB_1001e55a;
          }
          pbStack_200 = (byte *)0x0;
          psVar43 = (size_t *)(buf + 0x60);
          goto LAB_1001e8ac;
        case 0x4c:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          bVar2 = true;
          goto LAB_1001ded2;
        case 0x4f:
          if (bVar3) {
LAB_1001e724:
            puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
            puStack_20c = puVar33 + 2;
            uVar23 = puVar33[1];
            uVar21 = *puVar33;
          }
          else {
LAB_1001ef5c:
            uVar23 = 0;
            uVar21 = *puStack_20c;
            puStack_20c = puStack_20c + 1;
          }
          goto LAB_1001e734;
        case 0x53:
        case 0x73:
          cStack_10d = '\0';
          psVar43 = (size_t *)*puStack_20c;
          puStack_20c = puStack_20c + 1;
          if (psVar43 == (size_t *)0x0) {
            if ((byte *)0x6 < pbVar36) {
              pbVar36 = (byte *)0x6;
            }
            psVar43 = (size_t *)&UNK_10022560;
            psStack_210 = (size_t *)0x0;
            iStack_208 = 0;
            iStack_1fc = 0;
            pbVar40 = (byte *)0x0;
            pbVar37 = (byte *)0x0;
            pbVar44 = pbVar36;
            pbVar46 = pbVar36;
            goto joined_r0x1001e2fc;
          }
          if ((int)pbVar36 < 0) {
            pbVar46 = (byte *)strlen((char *)psVar43);
            pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          }
          else {
            pvVar13 = memchr(psVar43,0,(size_t)pbVar36);
            if (pvVar13 == (void *)0x0) {
              psStack_210 = (size_t *)0x0;
              pbVar46 = pbVar36;
              if (cStack_10d == '\0') {
                iStack_208 = 0;
                iStack_1fc = 0;
                pbVar40 = (byte *)0x0;
                pbVar37 = (byte *)0x0;
              }
              else {
                iStack_208 = 0;
                iStack_1fc = 0;
                pbVar40 = (byte *)0x0;
                pbVar37 = (byte *)0x0;
                pbVar44 = pbVar36 + 1;
              }
              goto joined_r0x1001e2fc;
            }
            pbVar46 = (byte *)((int)pvVar13 - (int)psVar43);
            pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          }
          if (cStack_10d != '\0') {
            pbVar44 = pbVar44 + 1;
          }
LAB_1001e2e8:
          bVar1 = false;
          psStack_210 = (size_t *)0x0;
          iStack_208 = 0;
          iStack_1fc = 0;
          pbVar40 = (byte *)0x0;
          pbVar37 = (byte *)0x0;
          goto joined_r0x1001e2fc;
        case 0x55:
          if (!bVar3) {
LAB_1001e810:
            cStack_10d = '\0';
            uVar23 = 0;
            uVar21 = *puStack_20c;
            puVar33 = puStack_20c + 1;
            if (-1 < (int)pbVar36) {
joined_r0x1001ef10:
              bVar19 = bVar25 & 0x7f;
              if (uVar21 != 0) goto LAB_1001e82a;
              puStack_20c = puStack_20c + 1;
              goto joined_r0x1001ef16;
            }
            goto joined_r0x1001e82e;
          }
LAB_1001e916:
          cStack_10d = '\0';
          puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
          puStack_20c = puVar33 + 2;
          uVar21 = *puVar33;
          uVar23 = puVar33[1];
          if (((int)pbVar36 < 0) || (bVar19 = bVar25 & 0x7f, uVar21 != 0 || uVar23 != 0))
          goto LAB_1001e550;
joined_r0x1001ef16:
          if (pbVar36 == (byte *)0x0) {
            bVar1 = false;
            cStack_10d = '\0';
            iStack_208 = 0;
            iStack_1fc = 0;
            pbVar40 = (byte *)0x0;
            psStack_210 = (size_t *)0x0;
            psVar43 = (size_t *)(buf + 0x60);
            pbVar44 = (byte *)0x0;
            pbVar46 = (byte *)0x0;
            bVar25 = bVar25 & 0x7f;
            goto joined_r0x1001e2fc;
          }
LAB_1001e942:
          bVar25 = bVar25 & 0x7f;
          cStack_10d = '\0';
          uVar21 = 0;
LAB_1001e55a:
          buf[0x5f] = (char)uVar21 + '0';
          bVar19 = bVar25;
LAB_1001e562:
          pbVar44 = pbVar36;
          if ((int)pbVar36 < 1) {
            pbVar44 = &DAT_00000001;
          }
          bVar17 = 0;
          pbVar46 = &DAT_00000001;
          psVar43 = (size_t *)(buf + 0x5f);
          goto LAB_1001e57a;
        case 0x58:
          pcVar15 = "0123456789ABCDEF";
          goto LAB_1001efe8;
        case 100:
        case 0x69:
          if (!bVar3) {
            uVar21 = *puStack_20c;
            if (bVar4) goto LAB_1001ef40;
            if (bVar5) {
              uVar21 = (uint)(short)uVar21;
              uVar23 = (int)uVar21 >> 0x1f;
            }
            else if (bVar7) {
              uVar21 = (uint)(char)uVar21;
              uVar23 = (int)uVar21 >> 0x1f;
            }
            else {
              uVar23 = (int)uVar21 >> 0x1f;
            }
            goto LAB_1001e4d6;
          }
LAB_1001e51a:
          puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
          uVar23 = puVar33[1];
          puStack_20c = puVar33 + 2;
          uVar21 = *puVar33;
          if ((int)uVar23 < 0) goto LAB_1001e530;
LAB_1001e4da:
          if (((int)pbVar36 < 0) || (bVar19 = bVar25 & 0x7f, uVar21 != 0 || uVar23 != 0))
          goto LAB_1001e550;
          if (pbVar36 != (byte *)0x0) {
            buf[0x5f] = '0';
            goto LAB_1001e562;
          }
          goto LAB_1001f0c6;
        case 0x68:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          if (uVar27 == 0x68) {
            uVar27 = (uint)*(byte *)((int)fmt0 + 1);
            bVar7 = true;
            fmt0 = (char *)((int)fmt0 + 1);
          }
          else {
            bVar5 = true;
          }
          goto LAB_1001ded2;
        case 0x6a:
        case 0x71:
          uVar27 = (uint)(byte)*(size_t *)fmt0;
          bVar3 = true;
          goto LAB_1001ded2;
        case 0x6c:
          goto switchD_1001deea_caseD_6c;
        case 0x6e:
          puVar33 = puStack_20c + 1;
          if (bVar3) {
            piVar31 = (int *)*puStack_20c;
            *piVar31 = iStack_214;
            piVar31[1] = iStack_214 >> 0x1f;
            puStack_20c = puVar33;
            goto LAB_1001dfd6;
          }
          if (!bVar4) {
            if (bVar5) {
              *(short *)*puStack_20c = (short)iStack_214;
              puStack_20c = puVar33;
              goto LAB_1001dfd6;
            }
            if (bVar7) {
              *(char *)*puStack_20c = (char)iStack_214;
              puStack_20c = puVar33;
              goto LAB_1001dfd6;
            }
          }
          *(int *)*puStack_20c = iStack_214;
          puStack_20c = puVar33;
          goto LAB_1001dfd6;
        case 0x6f:
          if (bVar3) goto LAB_1001e724;
          puVar33 = puStack_20c + 1;
          uVar21 = *puStack_20c;
          if (bVar4) goto LAB_1001ef5c;
          puStack_20c = puVar33;
          if (bVar5) {
            uVar21 = uVar21 & 0xffff;
            uVar23 = 0;
          }
          else if (bVar7) {
            uVar21 = uVar21 & 0xff;
            uVar23 = 0;
          }
          else {
            uVar23 = 0;
          }
LAB_1001e734:
          cStack_10d = '\0';
          if (-1 < (int)pbVar36) {
            bVar19 = bVar25 & 0x7f;
            bVar6 = false;
            bVar1 = false;
            if ((uVar21 == 0 && uVar23 == 0) && (pbVar36 == (byte *)0x0)) {
              pbVar44 = (byte *)(uint)bVar8;
              if (pbVar44 == (byte *)0x0) {
LAB_1001f1ce:
                bVar1 = false;
                cStack_10d = '\0';
                iStack_208 = 0;
                iStack_1fc = 0;
                pbVar40 = (byte *)0x0;
                psStack_210 = (size_t *)0x0;
                psVar43 = (size_t *)(buf + 0x60);
                pbVar46 = (byte *)0x0;
                bVar25 = bVar25 & 0x7f;
              }
              else {
                buf[0x5f] = '0';
                iStack_208 = 0;
                iStack_1fc = 0;
                pbVar40 = (byte *)0x0;
                psStack_210 = (size_t *)0x0;
                psVar43 = (size_t *)(buf + 0x5f);
                pbVar46 = pbVar44;
                bVar25 = bVar19;
              }
              goto joined_r0x1001e2fc;
            }
          }
          bVar6 = false;
          psVar43 = (size_t *)(buf + 0x60);
          do {
            psVar42 = psVar43;
            iVar35 = (uVar21 & 7) + 0x30;
            uVar21 = uVar21 >> 3 | uVar23 << 0x1d;
            uVar23 = uVar23 >> 3;
            *(byte *)((int)psVar42 + -1) = (byte)iVar35;
            psVar43 = (size_t *)((int)psVar42 + -1);
          } while (uVar21 != 0 || uVar23 != 0);
          bVar17 = bVar8;
          if (bVar8 != false) {
            if (iVar35 == 0x30) goto LAB_1001e7dc;
            psVar43 = (size_t *)((int)psVar42 + -2);
            *(byte *)((int)psVar42 + -2) = 0x30;
            pbVar46 = (byte *)(buf + (0x60 - (int)psVar43));
            if ((int)pbVar36 < (int)pbVar46) {
              pbVar44 = pbVar46;
            }
            goto LAB_1001e7ba;
          }
LAB_1001e99c:
          cStack_10d = '\0';
          pbVar46 = (byte *)(buf + (0x60 - (int)psVar43));
          if ((int)pbVar36 < (int)pbVar46) {
            pbVar44 = pbVar46;
          }
          goto LAB_1001e57a;
        case 0x70:
          uStack_10c = 0x7830;
          cStack_10d = '\0';
          uVar23 = *puStack_20c;
          puStack_20c = puStack_20c + 1;
          uVar21 = 0;
          if (-1 < (int)pbVar36) {
            bVar25 = bVar25 & 0x7f;
            bVar1 = false;
            if (uVar23 != 0) {
              buf[0x5f] = "0123456789abcdef"[uVar23 & 0xf];
              pcVar15 = "0123456789abcdef";
              bVar17 = 2;
              uVar27 = 0x78;
              break;
            }
            if (pbVar36 != (byte *)0x0) {
              buf[0x5f] = '0';
              uVar27 = 0x78;
              psVar43 = (size_t *)(buf + 0x5f);
              bVar17 = 2;
              bVar19 = bVar25;
              goto LAB_1001e99c;
            }
            pbVar44 = (byte *)0x0;
            iStack_208 = 0;
            iStack_1fc = 0;
            pbVar40 = (byte *)0x0;
            pbVar46 = (byte *)0x0;
            psStack_210 = (size_t *)0x0;
            uVar27 = 0x78;
            psVar43 = (size_t *)(buf + 0x60);
            goto LAB_1001e58a;
          }
          buf[0x5f] = "0123456789abcdef"[uVar23 & 0xf];
          pcVar15 = "0123456789abcdef";
          bVar17 = 2;
          uVar27 = 0x78;
          break;
        case 0x74:
        case 0x7a:
          goto switchD_1001deea_caseD_74;
        case 0x75:
          if (bVar3) goto LAB_1001e916;
          puVar33 = puStack_20c + 1;
          uVar21 = *puStack_20c;
          if (bVar4) goto LAB_1001e810;
          if (bVar5) {
            uVar21 = uVar21 & 0xffff;
joined_r0x1001ef08:
            if (-1 < (int)pbVar36) goto joined_r0x1001ef10;
LAB_1001e82a:
            cStack_10d = '\0';
            uVar23 = 0;
            puVar33 = puStack_20c + 1;
            bVar25 = bVar19;
            goto joined_r0x1001e82e;
          }
          if (bVar7) {
            uVar21 = uVar21 & 0xff;
            goto joined_r0x1001ef08;
          }
          pbVar44 = (byte *)0x0;
          if (((int)pbVar36 < 0) || (bVar19 = bVar25 & 0x7f, uVar21 != 0)) goto LAB_1001e82a;
          puStack_20c = puVar33;
          if (pbVar36 != (byte *)0x0) goto LAB_1001e942;
          goto LAB_1001f1ce;
        case 0x78:
          pcVar15 = "0123456789abcdef";
LAB_1001efe8:
          if (bVar3) {
            puVar33 = (uint *)((int)puStack_20c + 7U & 0xfffffff8);
            uVar23 = *puVar33;
            uVar21 = puVar33[1];
            puVar33 = puVar33 + 2;
          }
          else {
            puVar33 = puStack_20c + 1;
            uVar23 = *puStack_20c;
            if (bVar4) {
LAB_1001f17e:
              uVar21 = 0;
            }
            else if (bVar5) {
              uVar23 = uVar23 & 0xffff;
              uVar21 = 0;
            }
            else {
              if (!bVar7) goto LAB_1001f17e;
              uVar23 = uVar23 & 0xff;
              uVar21 = 0;
            }
          }
          puStack_20c = puVar33;
          if (bVar8) {
            if (uVar23 == 0 && uVar21 == 0) {
              if ((int)pbVar36 < 0) {
                buf[0x5f] = *pcVar15;
                bVar6 = false;
                psVar43 = (size_t *)(buf + 0x5f);
                bVar17 = 0;
                goto LAB_1001e99c;
              }
LAB_1001f0c0:
              cStack_10d = '\0';
              bVar6 = false;
              if (pbVar36 != (byte *)0x0) {
                buf[0x5f] = *pcVar15;
                psVar43 = (size_t *)(buf + 0x5f);
                bVar17 = 0;
                bVar19 = bVar25 & 0x7f;
                goto LAB_1001e99c;
              }
LAB_1001f0c6:
              bVar19 = bVar25 & 0x7f;
              bVar17 = 0;
              pbVar46 = (byte *)0x0;
              psVar43 = (size_t *)(buf + 0x60);
              pbVar44 = (byte *)0x0;
              goto LAB_1001e57a;
            }
            uStack_10c = CONCAT11(uVar9,0x30);
            if ((int)pbVar36 < 0) {
              bVar25 = bVar25 | 2;
              goto LAB_1001f186;
            }
            bVar19 = bVar25 & 0x7f | 2;
LAB_1001f028:
            bVar25 = bVar19;
            bVar6 = false;
            buf[0x5f] = pcVar15[uVar23 & 0xf];
            bVar17 = bVar25 & 2;
          }
          else {
            if (-1 < (int)pbVar36) {
              bVar19 = bVar25 & 0x7f;
              if (uVar23 != 0 || uVar21 != 0) goto LAB_1001f028;
              goto LAB_1001f0c0;
            }
LAB_1001f186:
            bVar17 = bVar25 & 2;
            buf[0x5f] = pcVar15[uVar23 & 0xf];
            bVar6 = false;
          }
        }
        uVar23 = uVar23 >> 4 | uVar21 << 0x1c;
        uVar21 = uVar21 >> 4;
        psVar43 = (size_t *)(buf + 0x5f);
        bVar19 = bVar25;
        if (uVar23 != 0 || uVar21 != 0) {
          do {
            uVar32 = uVar23 & 0xf;
            uVar23 = uVar23 >> 4 | uVar21 << 0x1c;
            uVar21 = uVar21 >> 4;
            *(char *)((int)psVar43 + -1) = pcVar15[uVar32];
            psVar43 = (size_t *)((int)psVar43 + -1);
          } while (uVar23 != 0 || uVar21 != 0);
        }
        goto LAB_1001e99c;
      }
    }
LAB_1001dfde:
    if (uio.uio_iovcnt == 0) {
      uio.uio_iov = (__siov *)0x0;
    }
    else {
      iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
      if (iVar35 == 0) {
        uio.uio_iov = (__siov *)0x0;
      }
    }
LAB_1001eb0c:
    uVar29 = fp->_flags;
    if (((fp->_flags2 & 1U) == 0) && ((uVar29 & 0x200) == 0)) {
      __retarget_lock_release_recursive(&fp->_lock);
      uVar29 = fp->_flags;
    }
    if ((uVar29 & 0x40) == 0) {
      return iStack_214;
    }
  }
  return -1;
switchD_1001deea_caseD_6c:
  uVar27 = (uint)(byte)*(size_t *)fmt0;
  if (uVar27 == 0x6c) {
    uVar27 = (uint)*(byte *)((int)fmt0 + 1);
    bVar3 = true;
    fmt0 = (char *)((int)fmt0 + 1);
  }
  else {
    bVar4 = true;
  }
  goto LAB_1001ded2;
  while( true ) {
    uVar30 = uVar30 + (uVar30 < uVar32);
    uVar30 = uVar32 - (uVar30 - (((uint)((ulonglong)uVar30 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                uVar30 / 5));
    uVar21 = (uVar23 - (uVar32 < uVar30)) * -0x33333333 + uVar30 * -0x33333334 +
             (int)((ulonglong)uVar30 * 0xcccccccd >> 0x20);
    uVar45 = uVar21 >> 1;
    uVar21 = uVar21 * -0x80000000 | uVar30 * -0x33333333 >> 1;
    bVar1 = uVar23 == 0;
    uVar23 = uVar45;
    if ((bVar1) && (uVar32 < 10)) break;
LAB_1001e8ac:
    uVar32 = uVar21;
    uVar30 = uVar32 + uVar23;
    uVar21 = (uVar30 < uVar32) + uVar30;
    pbStack_200 = pbStack_200 + 1;
    psVar42 = (size_t *)((int)psVar43 + -1);
    *(byte *)((int)psVar43 + -1) =
         (char)uVar32 +
         (char)((uVar32 - (uVar21 - (((uint)((ulonglong)uVar21 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar21 / 5))) * -0x33333333 >> 1) * -10 + 0x30;
    psVar43 = psVar42;
    bVar19 = bVar25;
    if (bVar6) {
      while ((psVar43 = psVar42, (byte *)(uint)*pbStack_1e4 == pbStack_200 &&
             (pbStack_200 != (byte *)0xff))) {
        if ((uVar23 == 0) && (uVar32 < 10)) goto LAB_1001e7dc;
        pcVar15 = (char *)((int)psVar42 - sStack_1c8);
        strncpy(pcVar15,pcStack_1d0,sStack_1c8);
        uVar21 = uVar32 + uVar23 + (uint)(uVar32 + uVar23 < uVar32);
        pbStack_1e4 = pbStack_1e4 + (pbStack_1e4[1] != 0);
        uVar30 = uVar32 - (uVar21 - (((uint)((ulonglong)uVar21 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar21 / 5));
        psVar42 = (size_t *)(pcVar15 + -1);
        uVar21 = (uVar23 - (uVar32 < uVar30)) * -0x33333333 + uVar30 * -0x33333334 +
                 (int)((ulonglong)uVar30 * 0xcccccccd >> 0x20);
        uVar23 = uVar21 >> 1;
        uVar30 = uVar30 * -0x33333333 >> 1;
        uVar32 = uVar21 * -0x80000000 | uVar30;
        uVar21 = uVar32 + uVar23 + (uint)(uVar32 + uVar23 < uVar32);
        pcVar15[-1] = (char)uVar30 +
                      (char)((uVar32 - (uVar21 - (((uint)((ulonglong)uVar21 * 0xcccccccd >> 0x20) &
                                                  0xfffffffc) + uVar21 / 5))) * -0x33333333 >> 1) *
                      -10 + '0';
        pbStack_200 = &DAT_00000001;
      }
      uVar30 = uVar32 + uVar23;
    }
  }
LAB_1001e7dc:
  pbVar46 = (byte *)(buf + (0x60 - (int)psVar43));
  pbVar44 = pbVar36;
  if ((int)pbVar36 < (int)pbVar46) {
    bVar17 = 0;
    pbVar44 = pbVar46;
  }
  else {
LAB_1001e7ba:
    bVar17 = 0;
  }
LAB_1001e57a:
  bVar1 = false;
  psStack_210 = (size_t *)0x0;
  iStack_208 = 0;
  iStack_1fc = 0;
  pbVar40 = (byte *)0x0;
  bVar25 = bVar19;
  goto joined_r0x1001e582;
LAB_1001f96a:
  do {
    psVar42 = (size_t *)((int)register0x0000203c + 1);
    *(byte *)register0x0000203c = 0x30;
    unique0x1000148c = psVar42;
  } while (psVar42 < pbStack_1c4);
  pbStack_200 = (byte *)((int)psVar42 - (int)psVar43);
  if (iVar35 == 0x47) {
LAB_1001fd5a:
    if ((int)_ox < -3) {
LAB_1001fe46:
      uVar27 = uVar27 - 2;
      pbVar36 = _ox;
      _ox = _ox + -1;
      dsgn._0_1_ = (char)uVar27;
LAB_1001fe54:
      dsgn._1_1_ = 0x2d;
      pbVar36 = (byte *)(1 - (int)pbVar36);
joined_r0x1001fe64:
      if (9 < (int)pbVar36) goto LAB_1001f75c;
    }
    else {
      if ((int)_ox <= (int)pbVar36) {
        if ((int)_ox < (int)pbStack_200) {
LAB_1001fec4:
          uVar27 = 0x67;
          pbVar46 = pbStack_200 + sVar12;
          if (0 < (int)_ox) goto LAB_1001fe08;
          pbVar46 = pbStack_200 + sVar12 + (1 - (int)_ox);
          pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
        }
        else {
          pbVar46 = _ox;
          if (bVar8) {
            pbVar46 = _ox + sVar12;
          }
LAB_1001f87c:
          if ((bVar6) && (0 < (int)_ox)) {
            uVar27 = 0x67;
            goto LAB_1001fff8;
          }
          pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
          uVar27 = 0x67;
        }
        goto LAB_1001f89a;
      }
LAB_1001fd64:
      uVar27 = uVar27 - 2;
      pbVar44 = _ox + -1;
      dsgn._0_1_ = (undefined1)uVar27;
      if (-1 < (int)pbVar44) goto LAB_1001f9a8;
      pbVar36 = (byte *)(1 - (int)_ox);
      dsgn._1_1_ = 0x2d;
      _ox = pbVar44;
    }
    cVar26 = (char)pbVar36;
    dsgn._2_1_ = 0x30;
    pcVar15 = (char *)((int)&dsgn + 3);
    goto LAB_1001f8de;
  }
  if (iVar35 != 0x46) {
LAB_1001f998:
    pbVar44 = _ox + -1;
    pbVar36 = _ox;
    _ox = pbVar44;
    dsgn._0_1_ = uVar9;
    if ((int)pbVar44 < 0) goto LAB_1001fe54;
LAB_1001f9a8:
    dsgn._1_1_ = 0x2b;
    pbVar36 = pbVar44;
    _ox = pbVar44;
    goto joined_r0x1001fe64;
  }
LAB_1001fdf2:
  if ((int)_ox < 1) {
    if (bVar8 || pbVar36 != (byte *)0x0) {
      uVar27 = 0x66;
      pbVar46 = pbVar36 + sVar12 + 1;
      pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
    }
    else {
      pbVar44 = &DAT_00000001;
      pbVar46 = &DAT_00000001;
      uVar27 = 0x66;
    }
  }
  else {
    if (bVar8 || pbVar36 != (byte *)0x0) {
      uVar27 = 0x66;
      pbVar46 = pbVar36 + (int)_ox + sVar12;
    }
    else {
      uVar27 = 0x66;
      pbVar46 = _ox;
    }
LAB_1001fe08:
    if (bVar6) {
LAB_1001fff8:
      uVar21 = (uint)*pbStack_1e4;
      pbVar40 = _ox;
      if (uVar21 == 0xff) {
        iStack_208 = 0;
        iStack_1fc = 0;
      }
      else {
        iStack_208 = 0;
        iStack_1fc = 0;
        do {
          if ((int)pbVar40 <= (int)uVar21) break;
          pbVar40 = pbVar40 + -uVar21;
          uVar21 = (uint)pbStack_1e4[1];
          if (uVar21 == 0) {
            uVar21 = (uint)*pbStack_1e4;
            iStack_208 = iStack_208 + 1;
          }
          else {
            iStack_1fc = iStack_1fc + 1;
            pbStack_1e4 = pbStack_1e4 + 1;
          }
        } while (uVar21 != 0xff);
      }
      pbVar46 = pbVar46 + (iStack_1fc + iStack_208) * sStack_1c8;
      pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
      goto LAB_1001f89e;
    }
    pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
  }
LAB_1001f89a:
  iStack_208 = 0;
  iStack_1fc = 0;
  pbVar40 = _ox;
  goto LAB_1001f89e;
  while (_Var14 = __eqdf2(dRam00000010,DRam00000018), psVar42 = psVar38, _Var14 != 0) {
LAB_1001f5fe:
    pbVar44 = pbVar36;
    pbVar36 = pbVar44 + -1;
    __muldf3(dRam00000010,DRam00000018);
    uVar21 = __fixdfsi(dRam00000010);
    __floatsidf(uVar21);
    __subdf3(dRam00000010,DRam00000018);
    psVar38 = (size_t *)((int)psVar42 + 1);
    *(char *)psVar42 = pcVar15[uVar21];
    if (pbVar36 == (byte *)0xffffffff) {
      _Var14 = __gedf2(dRam00000010,DRam00000018);
      if ((0 < _Var14) ||
         ((_Var14 = __eqdf2(dRam00000010,DRam00000018), _Var14 == 0 && ((uVar21 & 1) != 0)))) {
        bVar19 = (byte)*psVar42;
        psVar20 = psVar38;
        unique0x10001678 = psVar42;
        if (pcVar15[0xf] == bVar19) {
          do {
            *(byte *)((int)psVar20 + -1) = 0x30;
            psVar42 = (size_t *)((int)stack0xffffff08 + -1);
            bVar19 = *(byte *)((int)stack0xffffff08 + -1);
            psVar20 = stack0xffffff08;
            unique0x10001674 = psVar42;
          } while (pcVar15[0xf] == bVar19);
        }
        bVar17 = bVar19 + 1;
        if (bVar19 == 0x39) {
          bVar17 = pcVar15[10];
        }
        *(byte *)((int)psVar20 + -1) = bVar17;
      }
      goto LAB_1001f720;
    }
  }
  if (-1 < (int)pbVar36) {
    do {
      psVar20 = (size_t *)((int)psVar42 + 1);
      *(byte *)psVar42 = 0x30;
      psVar42 = psVar20;
    } while ((size_t *)(pbVar44 + (int)psVar38) != psVar20);
    psVar38 = (size_t *)((byte *)((int)psVar38 + (int)pbVar36) + 1);
  }
LAB_1001f720:
  pbStack_200 = (byte *)((int)psVar38 - (int)psVar43);
  pbVar44 = _ox + -1;
  dsgn._0_1_ = 0x70;
  if (uVar27 != 0x61) {
    dsgn._0_1_ = 0x50;
    uVar27 = 0x41;
  }
  if ((int)pbVar44 < 0) {
    dsgn._1_1_ = 0x2d;
    pbVar36 = (byte *)(1 - (int)_ox);
  }
  else {
    dsgn._1_1_ = 0x2b;
    pbVar36 = pbVar44;
  }
  _ox = pbVar44;
  if ((int)pbVar36 < 10) {
    cVar26 = (char)pbVar36;
    pcVar15 = (char *)((int)&dsgn + 2);
LAB_1001f8de:
    pcStack_1dc = pcVar15 + (0xc1 - (int)(buf + 0x60));
    *pcVar15 = cVar26 + '0';
  }
  else {
LAB_1001f75c:
    puVar34 = (undefined1 *)((int)&rve + 3);
    puVar28 = puVar34;
    do {
      puVar18 = puVar28;
      cVar26 = (char)(byte *)((uint)pbVar36 / 10);
      puVar18[-1] = (char)pbVar36 + cVar26 * -10 + '0';
      bVar1 = 99 < (int)pbVar36;
      puVar28 = puVar18 + -1;
      pbVar36 = (byte *)((uint)pbVar36 / 10);
    } while (bVar1);
    puVar18[-2] = cVar26 + '0';
    puVar28 = puVar18 + -2;
    if (puVar28 < puVar34) {
      puVar24 = (undefined1 *)((int)&dsgn + 2);
      do {
        uVar9 = *puVar28;
        puVar28 = puVar28 + 1;
        *puVar24 = uVar9;
        puVar24 = puVar24 + 1;
      } while (puVar28 != puVar34);
      pcStack_1dc = puVar28 + (4 - (int)puVar18);
    }
    else {
      pcStack_1dc = (char *)0x2;
    }
  }
  pbVar46 = pbStack_200 + (int)pcStack_1dc;
  if ((1 < (int)pbStack_200) || (bVar8)) {
    pbVar46 = pbVar46 + sVar12;
  }
  bVar6 = false;
  pbVar44 = (byte *)((uint)pbVar46 & (int)~(uint)pbVar46 >> 0x1f);
  iStack_208 = 0;
  iStack_1fc = 0;
  pbVar40 = (byte *)0x0;
LAB_1001f89e:
  bVar1 = true;
  bVar17 = bVar25 & 2;
  if (iStack_1cc == 0) {
    pbVar36 = (byte *)0x0;
joined_r0x1001e582:
    if (cStack_10d != '\0') {
      pbVar44 = pbVar44 + 1;
    }
  }
  else {
    cStack_10d = '-';
    pbVar36 = (byte *)0x0;
    pbVar44 = pbVar44 + 1;
  }
  pbVar37 = pbVar36;
  if (bVar17 == 0) {
joined_r0x1001e2fc:
    pbVar36 = pbVar37;
    bVar19 = bVar25 & 0x84;
    if (bVar19 != 0) {
      if (cStack_10d != '\0') {
LAB_1001df20:
        bVar2 = false;
        goto LAB_1001df26;
      }
LAB_1001df68:
      if ((bVar19 == 0x80) && (iVar35 = (int)pbVar39 - (int)pbVar44, 0 < iVar35)) {
        if (0x10 < iVar35) {
          do {
            while( true ) {
              iVar16 = iVar35;
              *psVar10 = (size_t)"0000000000000000";
              psVar10[1] = 0x10;
              uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              psVar10 = psVar10 + 2;
              if ((int)uio.uio_iov < 8) break;
              iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_1001eb02;
              psVar10 = &uio.uio_resid;
              iVar35 = iVar16 + -0x10;
              if (iVar16 + -0x10 < 0x11) goto LAB_1001eaac;
            }
            iVar35 = iVar16 + -0x10;
          } while (0x10 < iVar16 + -0x10);
LAB_1001eaac:
          iVar35 = iVar16 + -0x10;
        }
        *psVar10 = (size_t)"0000000000000000";
        psVar10[1] = iVar35;
        uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
        }
      }
      goto LAB_1001df70;
    }
    iVar35 = (int)pbVar39 - (int)pbVar44;
    if (0 < iVar35) {
      bVar2 = false;
      goto LAB_1001e5b2;
    }
    if (cStack_10d != '\0') goto LAB_1001df20;
    iVar35 = (int)pbVar36 - (int)pbVar46;
    if (0 < iVar35) goto LAB_1001e318;
LAB_1001df78:
    if (!bVar1) goto LAB_1001df80;
LAB_1001e3c6:
    pbVar36 = (byte *)uio.uio_iovcnt;
    if (0x65 < (int)uVar27) {
      _Var14 = __eqdf2(dRam00000010,DRam00000018);
      if (_Var14 == 0) {
        *psVar10 = (size_t)&DAT_10022568;
        psVar10[1] = 1;
        uio.uio_iovcnt = (int)pbVar36 + 1;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
        }
        if (((int)_ox < (int)pbStack_200) || (pbVar36 = (byte *)uio.uio_iovcnt, bVar8)) {
          *psVar10 = (size_t)__s;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10[1] = sVar12;
          uio.uio_iovcnt = uio.uio_iovcnt + sVar12;
          psVar10 = psVar10 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_1001eb02;
            psVar10 = &uio.uio_resid;
          }
          pbVar37 = pbStack_200 + -1;
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (0 < (int)pbVar37) {
            for (; 0x10 < (int)pbVar37; pbVar37 = pbVar37 + -0x10) {
              *psVar10 = (size_t)"0000000000000000";
              psVar10[1] = 0x10;
              uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
              uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
              psVar10 = psVar10 + 2;
              if (7 < (int)uio.uio_iov) {
                iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_1001eb02;
                psVar10 = &uio.uio_resid;
              }
            }
            goto LAB_1001f2cc;
          }
        }
        goto LAB_1001dfa2;
      }
      if ((int)_ox < 1) {
        *psVar10 = (size_t)&DAT_10022568;
        psVar10[1] = 1;
        uio.uio_iovcnt = (int)pbVar36 + 1;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
        }
        if (_ox == (byte *)0x0) {
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (!bVar8 && pbStack_200 == (byte *)0x0) goto LAB_1001dfa2;
          *psVar10 = (size_t)__s;
          p_Var22 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar42 = psVar10 + 2;
          psVar10[1] = sVar12;
          iVar35 = uio.uio_iovcnt + sVar12;
          if (7 < (int)p_Var22) goto LAB_1001f80c;
        }
        else {
          *psVar10 = (size_t)__s;
          p_Var22 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10[1] = sVar12;
          if ((int)p_Var22 < 8) {
            psVar42 = psVar10 + 2;
            uio.uio_iovcnt = uio.uio_iovcnt + sVar12;
            uio.uio_iov = p_Var22;
          }
          else {
LAB_1001f80c:
            uio.uio_iovcnt = uio.uio_iovcnt + sVar12;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_1001eb02;
            psVar42 = &uio.uio_resid;
          }
          iVar35 = uio.uio_iovcnt;
          p_Var22 = uio.uio_iov;
          if ((int)_ox < 0) {
            iVar35 = -(int)_ox;
            if ((int)_ox < -0x10) {
              do {
                *psVar42 = (size_t)"0000000000000000";
                psVar42[1] = 0x10;
                uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
                uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
                psVar42 = psVar42 + 2;
                if (7 < (int)uio.uio_iov) {
                  iVar16 = __sprint_r(data,fp,(__suio *)auStack_f0);
                  if (iVar16 != 0) goto LAB_1001eb02;
                  psVar42 = &uio.uio_resid;
                }
                iVar35 = iVar35 + -0x10;
              } while (0x10 < iVar35);
            }
            *psVar42 = (size_t)"0000000000000000";
            psVar42[1] = iVar35;
            iVar35 = uio.uio_iovcnt + iVar35;
            p_Var22 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar42 = psVar42 + 2;
            if (7 < (int)p_Var22) {
              uio.uio_iov = p_Var22;
              uio.uio_iovcnt = iVar35;
              iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_1001eb02;
              psVar42 = &uio.uio_resid;
              iVar35 = uio.uio_iovcnt;
              p_Var22 = uio.uio_iov;
            }
          }
        }
        *psVar42 = (size_t)psVar43;
        psVar42[1] = (size_t)pbStack_200;
        pbVar36 = pbStack_200 + iVar35;
        goto joined_r0x1001e1ce;
      }
      pbVar37 = pbVar40;
      if ((int)pbStack_200 < (int)pbVar40) {
        pbVar37 = pbStack_200;
      }
      if (0 < (int)pbVar37) {
        uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
        *psVar10 = (size_t)psVar43;
        psVar10[1] = (size_t)pbVar37;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        pbVar36 = (byte *)uio.uio_iovcnt;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
          pbVar36 = (byte *)uio.uio_iovcnt;
        }
      }
      iVar35 = (int)pbVar40 - ((uint)pbVar37 & (int)~(uint)pbVar37 >> 0x1f);
      if (0 < iVar35) {
        for (; 0x10 < iVar35; iVar35 = iVar35 + -0x10) {
          *psVar10 = (size_t)"0000000000000000";
          psVar10[1] = 0x10;
          uio.uio_iovcnt = (int)(pbVar36 + 0x10);
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar16 = __sprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar16 != 0) goto LAB_1001eb02;
            psVar10 = &uio.uio_resid;
          }
          pbVar36 = (byte *)uio.uio_iovcnt;
        }
        *psVar10 = (size_t)"0000000000000000";
        psVar10[1] = iVar35;
        uio.uio_iovcnt = (int)(pbVar36 + iVar35);
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        pbVar36 = (byte *)uio.uio_iovcnt;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
          pbVar36 = (byte *)uio.uio_iovcnt;
        }
      }
      pbVar40 = (byte *)((int)psVar43 + (int)pbVar40);
      if (bVar6) {
        if (iStack_1fc < 1) goto LAB_1001fb98;
LAB_1001fb28:
        if (iStack_208 < 1) {
          pbStack_1e4 = pbStack_1e4 + -1;
          iStack_1fc = iStack_1fc + -1;
          goto LAB_1001fb2e;
        }
        do {
          iStack_208 = iStack_208 + -1;
LAB_1001fb2e:
          psVar10[1] = sStack_1c8;
          uio.uio_iovcnt = (int)(pbVar36 + sStack_1c8);
          *psVar10 = (size_t)pcStack_1d0;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_1001eb02;
            psVar10 = &uio.uio_resid;
          }
          uVar21 = (uint)*pbStack_1e4;
          uVar27 = (int)(pbStack_200 + (int)psVar43) - (int)pbVar40;
          if ((int)uVar21 < (int)(pbStack_200 + (int)psVar43) - (int)pbVar40) {
            uVar27 = uVar21;
          }
          if (0 < (int)uVar27) {
            uio.uio_iovcnt = uio.uio_iovcnt + uVar27;
            *psVar10 = (size_t)pbVar40;
            psVar10[1] = uVar27;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            if ((int)uio.uio_iov < 8) {
              uVar21 = (uint)*pbStack_1e4;
              psVar10 = psVar10 + 2;
            }
            else {
              iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_1001eb02;
              uVar21 = (uint)*pbStack_1e4;
              psVar10 = &uio.uio_resid;
            }
          }
          iVar35 = uVar21 - (uVar27 & (int)~uVar27 >> 0x1f);
          if (iVar35 < 1) {
            pbVar40 = pbVar40 + uVar21;
          }
          else {
            if (0x10 < iVar35) {
              do {
                while( true ) {
                  iVar16 = iVar35;
                  *psVar10 = (size_t)"0000000000000000";
                  psVar10[1] = 0x10;
                  uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
                  uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
                  psVar10 = psVar10 + 2;
                  if ((int)uio.uio_iov < 8) break;
                  iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
                  if (iVar35 != 0) goto LAB_1001eb02;
                  psVar10 = &uio.uio_resid;
                  iVar35 = iVar16 + -0x10;
                  if (iVar16 + -0x10 < 0x11) goto LAB_1001fc1e;
                }
                iVar35 = iVar16 + -0x10;
              } while (0x10 < iVar16 + -0x10);
LAB_1001fc1e:
              iVar35 = iVar16 + -0x10;
            }
            *psVar10 = (size_t)"0000000000000000";
            psVar10[1] = iVar35;
            uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            if ((int)uio.uio_iov < 8) {
              psVar10 = psVar10 + 2;
              pbVar40 = pbVar40 + *pbStack_1e4;
            }
            else {
              iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
              if (iVar35 != 0) goto LAB_1001eb02;
              psVar10 = &uio.uio_resid;
              pbVar40 = pbVar40 + *pbStack_1e4;
            }
          }
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (0 < iStack_1fc) goto LAB_1001fb28;
LAB_1001fb98:
          if (iStack_208 < 1) {
            if ((byte *)((int)psVar43 + (int)pbStack_200) < pbVar40) {
              pbVar40 = (byte *)((int)psVar43 + (int)pbStack_200);
            }
            break;
          }
        } while( true );
      }
      if (((int)_ox < (int)pbStack_200) || (bVar8)) {
        *psVar10 = (size_t)__s;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10[1] = sVar12;
        uio.uio_iovcnt = (int)(pbVar36 + sVar12);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
        }
        uVar27 = (int)((int)psVar43 + (int)pbStack_200) - (int)pbVar40;
        uVar21 = (int)pbStack_200 - (int)_ox;
        if ((int)uVar21 < (int)uVar27) {
          uVar27 = uVar21;
        }
        pbVar36 = (byte *)uio.uio_iovcnt;
        if (0 < (int)uVar27) {
          uio.uio_iovcnt = uio.uio_iovcnt + uVar27;
          *psVar10 = (size_t)pbVar40;
          psVar10[1] = uVar27;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          pbVar36 = (byte *)uio.uio_iovcnt;
          if (7 < (int)uio.uio_iov) {
            iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
            if (iVar35 != 0) goto LAB_1001eb02;
            psVar10 = &uio.uio_resid;
            uVar21 = (int)pbStack_200 - (int)_ox;
            pbVar36 = (byte *)uio.uio_iovcnt;
          }
        }
      }
      else {
        uVar21 = (int)pbStack_200 - (int)_ox;
        uVar27 = (int)(pbStack_200 + (int)psVar43) - (int)pbVar40;
        if ((int)uVar21 < (int)(pbStack_200 + (int)psVar43) - (int)pbVar40) {
          uVar27 = uVar21;
        }
      }
      pbVar37 = (byte *)(uVar21 - (uVar27 & (int)~uVar27 >> 0x1f));
      if ((int)pbVar37 < 1) goto LAB_1001dfa2;
      for (; uio.uio_iovcnt = (int)pbVar36, 0x10 < (int)pbVar37; pbVar37 = pbVar37 + -0x10) {
        *psVar10 = (size_t)"0000000000000000";
        psVar10[1] = 0x10;
        uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if (7 < (int)uio.uio_iov) {
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
        }
        pbVar36 = (byte *)uio.uio_iovcnt;
      }
LAB_1001f2cc:
      *psVar10 = (size_t)"0000000000000000";
      psVar10[1] = (size_t)pbVar37;
      uio.uio_iovcnt = uio.uio_iovcnt + (int)pbVar37;
      goto joined_r0x1001df9c;
    }
    pbVar36 = (byte *)(uio.uio_iovcnt + 1);
    p_Var22 = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    psVar42 = psVar10 + 2;
    uio.uio_iovcnt = (int)pbVar36;
    uio.uio_iov = p_Var22;
    if ((1 < (int)pbStack_200) || (bVar8)) {
      psVar10[1] = 1;
      *psVar10 = (size_t)psVar43;
      if (7 < (int)p_Var22) {
        iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_1001eb02;
        psVar42 = &uio.uio_resid;
      }
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      *psVar42 = (size_t)__s;
      psVar10 = psVar42 + 2;
      psVar42[1] = sVar12;
      uio.uio_iovcnt = uio.uio_iovcnt + sVar12;
      if (7 < (int)uio.uio_iov) {
        iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_1001eb02;
        psVar10 = &uio.uio_resid;
      }
      pbVar36 = (byte *)uio.uio_iovcnt;
      p_Var22 = uio.uio_iov;
      pbVar37 = pbStack_200 + -1;
      _Var14 = __eqdf2(dRam00000010,DRam00000018);
      if (_Var14 == 0) {
        psVar42 = psVar10;
        if (1 < (int)pbStack_200) {
          if (0x11 < (int)pbStack_200) {
            do {
              *psVar10 = (size_t)"0000000000000000";
              psVar10[1] = 0x10;
              uio.uio_iovcnt = (int)pbVar36 + 0x10;
              uio.uio_iov = (__siov *)((int)&p_Var22->iov_base + 1);
              psVar10 = psVar10 + 2;
              if (7 < (int)uio.uio_iov) {
                iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
                if (iVar35 != 0) goto LAB_1001eb02;
                psVar10 = &uio.uio_resid;
              }
              pbVar37 = pbVar37 + -0x10;
              pbVar36 = (byte *)uio.uio_iovcnt;
              p_Var22 = uio.uio_iov;
            } while (0x10 < (int)pbVar37);
          }
          *psVar10 = (size_t)"0000000000000000";
          psVar10[1] = (size_t)pbVar37;
          uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
          uio.uio_iov = (__siov *)((int)&p_Var22->iov_base + 1);
          if ((int)uio.uio_iov < 8) goto LAB_1001e1ae;
          goto LAB_1001eda0;
        }
      }
      else {
        *psVar10 = (size_t)((int)psVar43 + 1);
        psVar10[1] = (size_t)pbVar37;
        uio.uio_iov = (__siov *)((int)&p_Var22->iov_base + 1);
        uio.uio_iovcnt = (int)(pbVar37 + (int)pbVar36);
        if ((int)uio.uio_iov < 8) {
LAB_1001e1ae:
          pbVar36 = (byte *)uio.uio_iovcnt;
          p_Var22 = uio.uio_iov;
          psVar42 = psVar10 + 2;
        }
        else {
LAB_1001eda0:
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          pbVar36 = (byte *)uio.uio_iovcnt;
          p_Var22 = uio.uio_iov;
          psVar42 = &uio.uio_resid;
        }
      }
    }
    else {
      *psVar10 = (size_t)psVar43;
      psVar10[1] = 1;
      if (7 < (int)p_Var22) goto LAB_1001eda0;
    }
    *psVar42 = (size_t)&dsgn;
    psVar42[1] = (size_t)pcStack_1dc;
    pbVar36 = pbVar36 + (int)pcStack_1dc;
joined_r0x1001e1ce:
    uio.uio_iov = (__siov *)((int)&p_Var22->iov_base + 1);
    psVar10 = psVar42 + 2;
    uio.uio_iovcnt = (int)pbVar36;
    if (7 < (int)uio.uio_iov) goto LAB_1001e1d2;
  }
  else {
LAB_1001e58a:
    bVar19 = bVar25 & 0x84;
    pbVar44 = pbVar44 + 2;
    if ((bVar19 != 0) || (iVar35 = (int)pbVar39 - (int)pbVar44, iVar35 < 1)) {
      if (cStack_10d != '\0') {
        bVar2 = true;
        goto LAB_1001df26;
      }
LAB_1001df4c:
      psVar10[1] = 2;
      *psVar10 = (size_t)&uStack_10c;
      uio.uio_iovcnt = uio.uio_iovcnt + 2;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar10 = psVar10 + 2;
      if (7 < (int)uio.uio_iov) {
        iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_1001eb02;
        psVar10 = &uio.uio_resid;
      }
      goto LAB_1001df68;
    }
    bVar2 = true;
LAB_1001e5b2:
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar16 = iVar35;
          *psVar10 = (size_t)"                ";
          psVar10[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
          iVar35 = iVar16 + -0x10;
          if (iVar16 + -0x10 < 0x11) goto LAB_1001e616;
        }
        iVar35 = iVar16 + -0x10;
      } while (0x10 < iVar16 + -0x10);
LAB_1001e616:
      iVar35 = iVar16 + -0x10;
    }
    psVar10[1] = iVar35;
    *psVar10 = (size_t)"                ";
    uio.uio_iovcnt = iVar35 + uio.uio_iovcnt;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    if (7 < (int)uio.uio_iov) {
      iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
      if (iVar35 != 0) goto LAB_1001eb02;
      if (cStack_10d != '\0') {
        bVar19 = 0;
        psVar10 = &uio.uio_resid;
        goto LAB_1001df26;
      }
      if (!bVar2) {
        psVar10 = &uio.uio_resid;
        goto LAB_1001df70;
      }
      bVar19 = 0;
      psVar10 = &uio.uio_resid;
      goto LAB_1001df4c;
    }
    psVar10 = psVar10 + 2;
    if (cStack_10d != '\0') {
      bVar19 = 0;
LAB_1001df26:
      psVar10[1] = 1;
      *psVar10 = (size_t)&cStack_10d;
      uio.uio_iovcnt = uio.uio_iovcnt + 1;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar10 = psVar10 + 2;
      if (7 < (int)uio.uio_iov) {
        iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
        if (iVar35 != 0) goto LAB_1001eb02;
        psVar10 = &uio.uio_resid;
      }
      if (!bVar2) goto LAB_1001df68;
      goto LAB_1001df4c;
    }
    if (bVar2) {
      bVar19 = 0;
      goto LAB_1001df4c;
    }
LAB_1001df70:
    iVar35 = (int)pbVar36 - (int)pbVar46;
    if (iVar35 < 1) goto LAB_1001df78;
LAB_1001e318:
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar16 = iVar35;
          *psVar10 = (size_t)"0000000000000000";
          psVar10[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
          iVar35 = iVar16 + -0x10;
          if (iVar16 + -0x10 < 0x11) goto LAB_1001e378;
        }
        iVar35 = iVar16 + -0x10;
      } while (0x10 < iVar16 + -0x10);
LAB_1001e378:
      iVar35 = iVar16 + -0x10;
    }
    *psVar10 = (size_t)"0000000000000000";
    psVar10[1] = iVar35;
    uio.uio_iovcnt = uio.uio_iovcnt + iVar35;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    psVar10 = psVar10 + 2;
    if ((int)uio.uio_iov < 8) goto LAB_1001df78;
    iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
    if (iVar35 != 0) goto LAB_1001eb02;
    psVar10 = &uio.uio_resid;
    if (bVar1) goto LAB_1001e3c6;
LAB_1001df80:
    uio.uio_iovcnt = (int)(pbVar46 + uio.uio_iovcnt);
    *psVar10 = (size_t)psVar43;
    psVar10[1] = (size_t)pbVar46;
joined_r0x1001df9c:
    uio.uio_iov = (__siov *)((int)uio.uio_iov + 1);
    if ((int)uio.uio_iov < 8) {
      psVar10 = (size_t *)((int)psVar10 + 8);
      pbVar36 = (byte *)uio.uio_iovcnt;
    }
    else {
LAB_1001e1d2:
      iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
      if (iVar35 != 0) goto LAB_1001eb02;
      psVar10 = &uio.uio_resid;
      pbVar36 = (byte *)uio.uio_iovcnt;
    }
  }
LAB_1001dfa2:
  if (((bVar25 & 4) != 0) && (iVar35 = (int)pbVar39 - (int)pbVar44, 0 < iVar35)) {
    if (0x10 < iVar35) {
      do {
        while( true ) {
          iVar16 = iVar35;
          *psVar10 = (size_t)"                ";
          psVar10[1] = 0x10;
          pbVar36 = pbVar36 + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if ((int)uio.uio_iov < 8) break;
          uio.uio_iovcnt = (int)pbVar36;
          iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0);
          if (iVar35 != 0) goto LAB_1001eb02;
          psVar10 = &uio.uio_resid;
          pbVar36 = (byte *)uio.uio_iovcnt;
          iVar35 = iVar16 + -0x10;
          if (iVar16 + -0x10 < 0x11) goto LAB_1001e24a;
        }
        iVar35 = iVar16 + -0x10;
      } while (0x10 < iVar16 + -0x10);
LAB_1001e24a:
      iVar35 = iVar16 + -0x10;
    }
    *psVar10 = (size_t)"                ";
    psVar10[1] = iVar35;
    uio.uio_iovcnt = (int)(pbVar36 + iVar35);
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    pbVar36 = (byte *)uio.uio_iovcnt;
    if ((7 < (int)uio.uio_iov) &&
       (iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0), pbVar36 = (byte *)uio.uio_iovcnt,
       iVar35 != 0)) goto LAB_1001eb02;
  }
  if ((int)pbVar39 < (int)pbVar44) {
    pbVar39 = pbVar44;
  }
  iStack_214 = iStack_214 + (int)pbVar39;
  if ((pbVar36 == (byte *)0x0) || (iVar35 = __sprint_r(data,fp,(__suio *)auStack_f0), iVar35 == 0))
  {
    uio.uio_iov = (__siov *)0x0;
    if (psStack_210 != (size_t *)0x0) {
      _free_r(data,psStack_210);
    }
    psVar10 = &uio.uio_resid;
LAB_1001dfd6:
    bVar25 = (byte)*(size_t *)fmt0;
    psVar43 = (size_t *)fmt0;
    if (bVar25 == 0) goto LAB_1001dfde;
    goto LAB_1001de74;
  }
LAB_1001eb02:
  if (psStack_210 != (size_t *)0x0) {
    _free_r(data,psStack_210);
  }
  goto LAB_1001eb0c;
switchD_1001deea_caseD_31:
  uVar21 = uVar27 - 0x30;
  pbVar39 = (byte *)0x0;
  do {
    uVar27 = (uint)(byte)*(size_t *)fmt0;
    pbVar39 = (byte *)(uVar21 + (int)pbVar39 * 10);
    uVar21 = uVar27 - 0x30;
    fmt0 = (char *)((int)fmt0 + 1);
  } while (uVar21 < 10);
  goto LAB_1001ded4;
switchD_1001deea_caseD_20:
  if (cStack_10d == '\0') {
    cStack_10d = ' ';
    uVar27 = (uint)(byte)*(size_t *)fmt0;
  }
  else {
switchD_1001deea_caseD_74:
    uVar27 = (uint)(byte)*(size_t *)fmt0;
  }
  goto LAB_1001ded2;
}



int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)

{
  _reent *data;
  int iVar1;
  
  gp = &__global_pointer_;
  data = __wrap___getreent();
  iVar1 = _vfprintf_r(data,(FILE *)__s,__format,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention

int __sbprintf(_reent *rptr,FILE *fp,char *fmt,va_list ap)

{
  int iVar1;
  int iVar2;
  undefined1 local_490 [4];
  FILE fake;
  uchar buf [1024];
  
  gp = &__global_pointer_;
  fake._w._2_2_ = fp->_file;
  fake._data = (_reent *)fp->_cookie;
  fake._read = fp->_write;
  fake._mbstate.__value = (anon_union_4_2_91654ee9_for___value)fp->_flags2;
  fake._w._0_2_ = fp->_flags & 0xfffd;
  local_490 = (undefined1  [4])&fake.field_0x6c;
  fake._r = 0x400;
  fake._bf._base = (uchar *)0x400;
  fake._bf._size = 0;
  fake._12_4_ = local_490;
  __retarget_lock_init_recursive((_LOCK_T)&fake._offset);
  iVar1 = _vfprintf_r(rptr,(FILE *)local_490,fmt,ap);
  if ((-1 < iVar1) && (iVar2 = _fflush_r(rptr,(FILE *)local_490), iVar2 != 0)) {
    iVar1 = -1;
  }
  if (((ushort)fake._w & 0x40) != 0) {
    fp->_flags = fp->_flags | 0x40;
  }
  __retarget_lock_close_recursive((_LOCK_T)&fake._offset);
  return iVar1;
}



// WARNING: Removing unreachable block (ram,0x10021286)
// WARNING: Removing unreachable block (ram,0x10020af8)
// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

int _vfiprintf_r(_reent *data,FILE *fp,char *fmt0,va_list ap)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  uint uVar8;
  char *pcVar9;
  size_t *psVar10;
  byte *pbVar11;
  char *__n;
  void *pvVar12;
  lconv *plVar13;
  int iVar14;
  char *pcVar15;
  uint *puVar16;
  uint uVar17;
  byte bVar18;
  ushort uVar19;
  uint uVar20;
  int *piVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  char *pcVar25;
  char *pcVar26;
  int iVar27;
  size_t *psVar28;
  size_t *psVar29;
  size_t *psVar30;
  char *pcVar31;
  uint uVar32;
  int iStack_128;
  uint *puStack_124;
  byte *pbStack_120;
  size_t sStack_114;
  char *pcStack_110;
  char cStack_f5;
  undefined2 uStack_f4;
  char sign;
  char ox [2];
  __suio uio;
  __siov iov [8];
  char buf [100];
  
  gp = &__global_pointer_;
  if ((data != (_reent *)0x0) && (data->__cleanup == (_func_void__reent_ptr *)0x0)) {
    __sinit(data);
  }
  uVar17 = fp->_flags2;
  uVar19 = fp->_flags;
  uVar20 = (uint)(short)uVar19;
  if ((uVar17 & 1) == 0) {
    if ((uVar20 & 0x200) != 0) {
      if ((int)(uVar20 << 0x12) < 0) {
        if ((int)(uVar17 << 0x12) < 0) goto LAB_10020df2;
        goto LAB_100203e8;
      }
LAB_100203d2:
      fp->_flags = uVar19 | 0x2000;
      fp->_flags2 = uVar17 & 0xffffdfff;
      uVar20 = (uint)(short)(uVar19 | 0x2000);
      goto LAB_100203e8;
    }
    __retarget_lock_acquire_recursive(&fp->_lock);
    uVar19 = fp->_flags;
    uVar20 = (uint)(short)uVar19;
    uVar17 = fp->_flags2;
    if (-1 < (int)(uVar20 << 0x12)) goto LAB_100203d2;
    if (-1 < (int)(uVar17 << 0x12)) goto LAB_100203e8;
  }
  else {
    if (-1 < (int)(uVar20 << 0x12)) goto LAB_100203d2;
    if ((int)(uVar17 << 0x12) < 0) {
      return -1;
    }
LAB_100203e8:
    if (((uVar20 & 8) != 0) && ((fp->_bf)._base != (uchar *)0x0)) {
joined_r0x10020da4:
      if (((uVar20 & 0x1a) == 10) && (-1 < fp->_file)) {
        if (((fp->_flags2 & 1U) == 0) && ((uVar20 & 0x200) == 0)) {
          __retarget_lock_release_recursive(&fp->_lock);
        }
        iVar27 = __sbprintf(data,fp,fmt0,ap);
        return iVar27;
      }
      psVar30 = &uio.uio_resid;
      uio.uio_iovcnt = 0;
      uio.uio_iov = (__siov *)0x0;
      pbStack_120 = (byte *)0x0;
      sStack_114 = 0;
      pcStack_110 = (char *)0x0;
      iStack_128 = 0;
      psVar10 = psVar30;
      puStack_124 = (uint *)ap;
      _ox = (__siov *)psVar30;
LAB_10020440:
      bVar18 = *fmt0;
joined_r0x10020444:
      pbVar11 = (byte *)fmt0;
      if (bVar18 != 0) {
        do {
          if (bVar18 == 0x25) {
            iVar27 = (int)pbVar11 - (int)fmt0;
            if (pbVar11 != (byte *)fmt0) goto LAB_1002045e;
            bVar18 = *pbVar11;
            goto LAB_10020482;
          }
          bVar18 = pbVar11[1];
          pbVar11 = pbVar11 + 1;
        } while (bVar18 != 0);
        iVar27 = (int)pbVar11 - (int)fmt0;
        if (pbVar11 != (byte *)fmt0) {
LAB_1002045e:
          *psVar10 = (size_t)fmt0;
          *(int *)((int)psVar10 + 4) = iVar27;
          uio.uio_iovcnt = uio.uio_iovcnt + iVar27;
          uio.uio_iov = (__siov *)((int)uio.uio_iov + 1);
          psVar10 = (size_t *)((int)psVar10 + 8);
          if ((7 < (int)uio.uio_iov) &&
             (iVar14 = __sprint_r(data,fp,(__suio *)ox), psVar10 = psVar30, iVar14 != 0))
          goto LAB_1002057a;
          bVar18 = *pbVar11;
          iStack_128 = iStack_128 + iVar27;
LAB_10020482:
          if (bVar18 != 0) {
            uVar17 = (uint)pbVar11[1];
            cStack_f5 = '\0';
            __n = (char *)0xffffffff;
            uVar20 = 0;
            bVar7 = false;
            bVar6 = false;
            bVar1 = false;
            bVar4 = false;
            bVar3 = false;
            bVar2 = false;
            bVar5 = false;
            pcVar25 = (char *)0x0;
            fmt0 = (char *)(pbVar11 + 1);
LAB_1002049c:
            fmt0 = (char *)((byte *)fmt0 + 1);
LAB_1002049e:
            pcVar31 = __n;
            pcVar26 = __n;
            uVar24 = uVar20;
            switch(uVar17) {
            case 0x20:
              goto switchD_100204b4_caseD_20;
            default:
              if (uVar17 == 0) goto LAB_10020572;
              cStack_f5 = '\0';
              psVar29 = &iov[7].iov_len;
              pcVar9 = &DAT_00000001;
              pcVar31 = (char *)0x0;
              pcVar26 = &DAT_00000001;
              iov[7].iov_len._0_1_ = (char)uVar17;
              goto LAB_100204cc;
            case 0x23:
              uVar17 = (uint)(byte)*fmt0;
              bVar1 = true;
              goto LAB_1002049c;
            case 0x27:
              plVar13 = _localeconv_r(data);
              pcStack_110 = plVar13->thousands_sep;
              sStack_114 = strlen(pcStack_110);
              plVar13 = _localeconv_r(data);
              pbStack_120 = (byte *)plVar13->grouping;
              uVar17 = (uint)(byte)*fmt0;
              if (((sStack_114 != 0) && (pbStack_120 != (byte *)0x0)) && (*pbStack_120 != 0)) {
                bVar6 = true;
              }
              goto LAB_1002049c;
            case 0x2a:
              pcVar25 = (char *)*puStack_124;
              puStack_124 = puStack_124 + 1;
              if (-1 < (int)pcVar25) {
                uVar17 = (uint)(byte)*fmt0;
                goto LAB_1002049c;
              }
              pcVar25 = (char *)-(int)pcVar25;
            case 0x2d:
              uVar17 = (uint)(byte)*fmt0;
              uVar20 = uVar20 | 4;
              goto LAB_1002049c;
            case 0x2b:
              cStack_f5 = '+';
              uVar17 = (uint)(byte)*fmt0;
              goto LAB_1002049c;
            case 0x2e:
              uVar17 = (uint)(byte)*fmt0;
              pbVar11 = (byte *)fmt0 + 1;
              if (uVar17 == 0x2a) {
                __n = (char *)*puStack_124;
                puStack_124 = puStack_124 + 1;
                if ((int)__n < 0) {
                  __n = (char *)0xffffffff;
                }
                uVar17 = (uint)((byte *)fmt0)[1];
                fmt0 = (char *)pbVar11;
                goto LAB_1002049c;
              }
              uVar24 = uVar17 - 0x30;
              __n = (char *)0x0;
              fmt0 = (char *)pbVar11;
              if (uVar24 < 10) {
                do {
                  uVar17 = (uint)*pbVar11;
                  __n = (char *)((int)__n * 10 + uVar24);
                  uVar24 = uVar17 - 0x30;
                  pbVar11 = pbVar11 + 1;
                } while (uVar24 < 10);
                fmt0 = (char *)pbVar11;
                if ((int)__n < 0) {
                  __n = (char *)0xffffffff;
                }
              }
              goto LAB_1002049e;
            case 0x30:
              uVar17 = (uint)(byte)*fmt0;
              uVar20 = uVar20 | 0x80;
              goto LAB_1002049c;
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
              goto switchD_100204b4_caseD_31;
            case 0x43:
            case 99:
              pcVar9 = &DAT_00000001;
              cStack_f5 = '\0';
              iov[7].iov_len._0_1_ = (undefined1)*puStack_124;
              puStack_124 = puStack_124 + 1;
              psVar29 = &iov[7].iov_len;
              pcVar31 = (char *)0x0;
              pcVar26 = &DAT_00000001;
              goto LAB_100204cc;
            case 0x44:
              if (bVar2) goto LAB_100207ae;
LAB_10020f54:
              uVar17 = *puStack_124;
              uVar8 = (int)uVar17 >> 0x1f;
LAB_100206da:
              puStack_124 = puStack_124 + 1;
              if (-1 < (int)uVar8) goto LAB_100206de;
LAB_100207c4:
              cStack_f5 = '-';
              uVar8 = -(uint)(uVar17 != 0) - uVar8;
              uVar17 = -uVar17;
              if (-1 < (int)__n) {
                uVar24 = uVar20 & 0xffffff7f;
              }
joined_r0x100206ee:
              puVar16 = puStack_124;
              if (uVar8 == 0) goto LAB_100206f2;
              goto LAB_100207e8;
            case 0x4f:
              if (bVar2) {
LAB_10020a82:
                puVar16 = (uint *)((int)puStack_124 + 7U & 0xfffffff8);
                puStack_124 = puVar16 + 2;
                uVar17 = *puVar16;
                uVar8 = puVar16[1];
              }
              else {
LAB_10020f94:
                uVar8 = 0;
                uVar17 = *puStack_124;
                puStack_124 = puStack_124 + 1;
              }
              goto LAB_10020a94;
            case 0x53:
            case 0x73:
              cStack_f5 = '\0';
              psVar29 = (size_t *)*puStack_124;
              puStack_124 = puStack_124 + 1;
              if (psVar29 == (size_t *)0x0) {
                if ((char *)0x6 < __n) {
                  __n = (char *)0x6;
                }
                psVar29 = (size_t *)&UNK_10022560;
                pcVar9 = __n;
                pcVar31 = (char *)0x0;
                pcVar26 = __n;
                goto LAB_100204cc;
              }
              if ((int)__n < 0) {
                pcVar9 = (char *)strlen((char *)psVar29);
                pcVar26 = (char *)((uint)pcVar9 & (int)~(uint)pcVar9 >> 0x1f);
              }
              else {
                pvVar12 = memchr(psVar29,0,(size_t)__n);
                if (pvVar12 == (void *)0x0) {
                  pcVar9 = __n;
                  if (cStack_f5 != '\0') {
                    pcVar26 = __n + 1;
                    __n = (char *)0x0;
                    goto LAB_1002071c;
                  }
                  pcVar31 = (char *)0x0;
                  goto LAB_100204cc;
                }
                pcVar9 = (char *)((int)pvVar12 - (int)psVar29);
                pcVar26 = (char *)((uint)pcVar9 & (int)~(uint)pcVar9 >> 0x1f);
              }
              if (cStack_f5 == '\0') {
                pcVar31 = (char *)0x0;
                goto LAB_100204cc;
              }
              pcVar26 = pcVar26 + 1;
              __n = (char *)0x0;
              goto LAB_1002071c;
            case 0x55:
              if (bVar2) goto LAB_10020922;
LAB_100208f6:
              cStack_f5 = '\0';
              uVar8 = 0;
              uVar17 = *puStack_124;
              puVar16 = puStack_124 + 1;
              if (-1 < (int)__n) {
joined_r0x10020f48:
                cStack_f5 = '\0';
                uVar8 = 0;
                puStack_124 = puStack_124 + 1;
                uVar24 = uVar20 & 0xffffff7f;
                puVar16 = puStack_124;
                if (uVar17 != 0) goto LAB_100206f2;
                goto LAB_1002090e;
              }
LAB_100206f2:
              puStack_124 = puVar16;
              uVar20 = uVar24;
              if (9 < uVar17) {
LAB_100207e8:
                uVar20 = 0;
                psVar29 = (size_t *)(buf + 0x60);
                goto LAB_10020862;
              }
LAB_100206f8:
              buf[0x5f] = (char)uVar17 + '0';
LAB_10020700:
              if ((int)__n < 1) {
                pcVar26 = &DAT_00000001;
              }
              if (cStack_f5 != '\0') {
                pcVar26 = pcVar26 + 1;
                psVar29 = (size_t *)(buf + 0x5f);
                pcVar9 = &DAT_00000001;
                goto LAB_1002071c;
              }
              psVar29 = (size_t *)(buf + 0x5f);
              pcVar9 = &DAT_00000001;
              uVar24 = uVar20;
              goto LAB_100204cc;
            case 0x58:
              pcVar15 = "0123456789ABCDEF";
              goto LAB_10020fe8;
            case 100:
            case 0x69:
              if (!bVar2) {
                uVar17 = *puStack_124;
                if (bVar3) goto LAB_10020f54;
                if (bVar4) {
                  uVar17 = (uint)(short)uVar17;
                  uVar8 = (int)uVar17 >> 0x1f;
                }
                else if (bVar5) {
                  uVar17 = (uint)(char)uVar17;
                  uVar8 = (int)uVar17 >> 0x1f;
                }
                else {
                  uVar8 = (int)uVar17 >> 0x1f;
                }
                goto LAB_100206da;
              }
LAB_100207ae:
              puVar16 = (uint *)((int)puStack_124 + 7U & 0xfffffff8);
              uVar8 = puVar16[1];
              puStack_124 = puVar16 + 2;
              uVar17 = *puVar16;
              if ((int)uVar8 < 0) goto LAB_100207c4;
LAB_100206de:
              if (((int)__n < 0) ||
                 (uVar20 = uVar20 & 0xffffff7f, uVar24 = uVar20, uVar17 != 0 || uVar8 != 0))
              goto joined_r0x100206ee;
              if (__n != (char *)0x0) {
                buf[0x5f] = '0';
                goto LAB_10020700;
              }
              pcVar9 = (char *)0x0;
              psVar29 = (size_t *)(buf + 0x60);
              pcVar26 = &DAT_00000001;
              if (cStack_f5 == '\0') goto LAB_10021024;
              goto LAB_1002071c;
            case 0x68:
              uVar17 = (uint)(byte)*fmt0;
              if (uVar17 == 0x68) {
                uVar17 = (uint)((byte *)fmt0)[1];
                bVar5 = true;
                fmt0 = (char *)((byte *)fmt0 + 1);
              }
              else {
                bVar4 = true;
              }
              goto LAB_1002049c;
            case 0x6a:
            case 0x71:
              uVar17 = (uint)(byte)*fmt0;
              bVar2 = true;
              goto LAB_1002049c;
            case 0x6c:
              uVar17 = (uint)(byte)*fmt0;
              if (uVar17 == 0x6c) {
                uVar17 = (uint)((byte *)fmt0)[1];
                bVar2 = true;
                fmt0 = (char *)((byte *)fmt0 + 1);
              }
              else {
                bVar3 = true;
              }
              goto LAB_1002049c;
            case 0x6e:
              if (bVar2) {
                piVar21 = (int *)*puStack_124;
                *piVar21 = iStack_128;
                piVar21[1] = iStack_128 >> 0x1f;
              }
              else if (bVar3) {
LAB_100212a6:
                *(int *)*puStack_124 = iStack_128;
              }
              else if (bVar4) {
                *(short *)*puStack_124 = (short)iStack_128;
              }
              else {
                if (!bVar5) goto LAB_100212a6;
                *(char *)*puStack_124 = (char)iStack_128;
              }
              puStack_124 = puStack_124 + 1;
              goto LAB_10020440;
            case 0x6f:
              if (bVar2) goto LAB_10020a82;
              uVar17 = *puStack_124;
              puVar16 = puStack_124 + 1;
              if (bVar3) goto LAB_10020f94;
              puStack_124 = puVar16;
              if (bVar4) {
                uVar17 = uVar17 & 0xffff;
                uVar8 = 0;
              }
              else if (bVar5) {
                uVar17 = uVar17 & 0xff;
                uVar8 = 0;
              }
              else {
                uVar8 = 0;
              }
LAB_10020a94:
              cStack_f5 = '\0';
              if (((-1 < (int)__n) && (uVar24 = uVar20 & 0xfffffb7f, uVar17 == 0 && uVar8 == 0)) &&
                 (__n == (char *)0x0)) {
                pcVar26 = (char *)(uint)bVar1;
                if (pcVar26 == (char *)0x0) {
                  pcVar9 = (char *)0x0;
                  psVar29 = (size_t *)(buf + 0x60);
                }
                else {
                  buf[0x5f] = '0';
                  psVar29 = (size_t *)(buf + 0x5f);
                  pcVar9 = pcVar26;
                }
                goto LAB_100204cc;
              }
              psVar29 = (size_t *)(buf + 0x60);
              do {
                psVar28 = psVar29;
                cStack_f5 = '\0';
                iVar27 = (uVar17 & 7) + 0x30;
                uVar17 = uVar17 >> 3 | uVar8 << 0x1d;
                uVar8 = uVar8 >> 3;
                *(char *)((int)psVar28 + -1) = (char)iVar27;
                psVar29 = (size_t *)((int)psVar28 + -1);
              } while (uVar17 != 0 || uVar8 != 0);
              if (!bVar1) goto LAB_10020d74;
              if (iVar27 == 0x30) {
                pcVar9 = buf + (0x60 - (int)psVar29);
                if ((int)__n < (int)pcVar9) {
                  pcVar26 = pcVar9;
                }
                goto LAB_100204cc;
              }
              psVar29 = (size_t *)((int)psVar28 + -2);
              *(undefined1 *)((int)psVar28 + -2) = 0x30;
              pcVar9 = buf + (0x60 - (int)psVar29);
              pcVar26 = pcVar9;
              if ((int)pcVar9 <= (int)__n) {
                pcVar26 = __n;
              }
LAB_10020afc:
              cStack_f5 = '\0';
              uVar20 = uVar24;
              if (uVar24 == 0) goto LAB_100204dc;
              goto LAB_10020520;
            case 0x70:
              uStack_f4 = 0x7830;
              cStack_f5 = '\0';
              puVar16 = puStack_124 + 1;
              uVar8 = 0;
              uVar22 = *puStack_124;
              puStack_124 = puVar16;
              if (-1 < (int)__n) {
                uVar24 = uVar20 & 0xffffff7f;
                if (uVar22 != 0) {
                  buf[0x5f] = "0123456789abcdef"[uVar22 & 0xf];
                  pcVar15 = "0123456789abcdef";
                  bVar7 = true;
                  break;
                }
                if (__n != (char *)0x0) {
                  buf[0x5f] = '0';
                  psVar29 = (size_t *)(buf + 0x5f);
                  pcVar9 = &DAT_00000001;
                  goto LAB_100209ea;
                }
                if ((uVar20 & 4) != 0) {
                  pcVar9 = (char *)0x0;
                  pcVar26 = (char *)0x2;
                  psVar29 = (size_t *)(buf + 0x60);
                  uVar20 = 4;
                  goto LAB_1002050a;
                }
                pcVar31 = pcVar25 + -2;
                if ((int)pcVar31 < 1) {
                  pcVar9 = (char *)0x0;
                  pcVar26 = (char *)0x2;
                  psVar29 = (size_t *)(buf + 0x60);
                  uVar20 = 0;
                  goto LAB_1002050a;
                }
                pcVar26 = (char *)0x2;
                bVar1 = true;
                pcVar9 = (char *)0x0;
                psVar29 = (size_t *)(buf + 0x60);
                goto LAB_10020e34;
              }
              buf[0x5f] = "0123456789abcdef"[uVar22 & 0xf];
              pcVar15 = "0123456789abcdef";
              bVar7 = true;
              break;
            case 0x74:
            case 0x7a:
              goto switchD_100204b4_caseD_74;
            case 0x75:
              if (!bVar2) {
                uVar17 = *puStack_124;
                if (bVar3) goto LAB_100208f6;
                if (bVar4) {
                  uVar17 = uVar17 & 0xffff;
                }
                else if (bVar5) {
                  uVar17 = uVar17 & 0xff;
                }
                if (-1 < (int)__n) goto joined_r0x10020f48;
                cStack_f5 = '\0';
                uVar8 = 0;
                puVar16 = puStack_124 + 1;
                goto LAB_100206f2;
              }
LAB_10020922:
              cStack_f5 = '\0';
              puVar16 = (uint *)((int)puStack_124 + 7U & 0xfffffff8);
              puStack_124 = puVar16 + 2;
              uVar8 = puVar16[1];
              uVar17 = *puVar16;
              if (((int)__n < 0) || (uVar24 = uVar20 & 0xffffff7f, uVar17 != 0 || uVar8 != 0))
              goto joined_r0x100206ee;
LAB_1002090e:
              uVar20 = uVar20 & 0xffffff7f;
              cStack_f5 = '\0';
              if (__n != (char *)0x0) {
                uVar17 = 0;
                goto LAB_100206f8;
              }
              goto LAB_10021022;
            case 0x78:
              pcVar15 = "0123456789abcdef";
LAB_10020fe8:
              if (bVar2) {
                puVar16 = (uint *)((int)puStack_124 + 7U & 0xfffffff8);
                puStack_124 = puVar16 + 2;
                uVar8 = puVar16[1];
                uVar22 = *puVar16;
              }
              else {
                uVar22 = *puStack_124;
                puStack_124 = puStack_124 + 1;
                if (bVar3) {
LAB_100211d2:
                  uVar8 = 0;
                }
                else if (bVar4) {
                  uVar22 = uVar22 & 0xffff;
                  uVar8 = 0;
                }
                else {
                  if (!bVar5) goto LAB_100211d2;
                  uVar22 = uVar22 & 0xff;
                  uVar8 = 0;
                }
              }
              pcVar26 = (char *)(uint)bVar1;
              if (pcVar26 == (char *)0x0) {
                if ((int)__n < 0) goto LAB_100211da;
                uVar24 = uVar20 & 0xfffffb7f;
                bVar7 = false;
                if (uVar22 == 0 && uVar8 == 0) {
                  if (__n == (char *)0x0) {
                    pcVar9 = (char *)0x0;
                    psVar29 = (size_t *)(buf + 0x60);
                  }
                  else {
                    buf[0x5f] = *pcVar15;
                    pcVar9 = &DAT_00000001;
                    psVar29 = (size_t *)(buf + 0x5f);
                    pcVar26 = __n;
                  }
                  goto LAB_10020afc;
                }
LAB_1002124a:
                buf[0x5f] = pcVar15[uVar22 & 0xf];
                uVar24 = uVar20 & 0xfffffb7f;
              }
              else {
                if (uVar22 == 0 && uVar8 == 0) {
                  pcVar9 = pcVar26;
                  if ((int)__n < 0) {
                    buf[0x5f] = *pcVar15;
                    psVar29 = (size_t *)(buf + 0x5f);
                    goto LAB_10020afc;
                  }
                  uVar20 = uVar20 & 0xfffffb7f;
                  if (__n != (char *)0x0) {
                    buf[0x5f] = *pcVar15;
                    psVar29 = (size_t *)(buf + 0x5f);
                    uVar24 = uVar20;
                    pcVar26 = __n;
                    goto LAB_10020afc;
                  }
LAB_10021022:
                  cStack_f5 = '\0';
LAB_10021024:
                  psVar29 = (size_t *)(buf + 0x60);
                  pcVar9 = (char *)0x0;
                  uVar24 = uVar20;
                  pcVar26 = (char *)0x0;
                  goto LAB_100204cc;
                }
                uStack_f4 = CONCAT11((char)uVar17,0x30);
                if (-1 < (int)__n) {
                  bVar7 = true;
                  goto LAB_1002124a;
                }
                bVar7 = true;
LAB_100211da:
                buf[0x5f] = pcVar15[uVar22 & 0xf];
              }
            }
            uVar20 = uVar22 >> 4 | uVar8 << 0x1c;
            uVar8 = uVar8 >> 4;
            psVar29 = (size_t *)(buf + 0x5f);
            if (uVar20 != 0 || uVar8 != 0) {
              do {
                uVar17 = uVar20 & 0xf;
                uVar20 = uVar20 >> 4 | uVar8 << 0x1c;
                uVar8 = uVar8 >> 4;
                *(char *)((int)psVar29 + -1) = pcVar15[uVar17];
                psVar29 = (size_t *)((int)psVar29 + -1);
              } while (uVar20 != 0 || uVar8 != 0);
            }
            pcVar9 = buf + (0x60 - (int)psVar29);
            pcVar26 = __n;
            if ((int)__n < (int)pcVar9) {
              pcVar26 = pcVar9;
            }
            if (!bVar7) goto LAB_10020afc;
LAB_100209ea:
            cStack_f5 = '\0';
            pcVar26 = pcVar26 + 2;
            uVar20 = uVar24;
            if (uVar24 == 0) {
              pcVar31 = pcVar25 + -(int)pcVar26;
              bVar1 = true;
              if ((int)pcVar31 < 1) goto LAB_1002050a;
              goto LAB_10020e34;
            }
            goto LAB_1002050a;
          }
        }
      }
LAB_10020572:
      if (uio.uio_iovcnt == 0) {
        uio.uio_iov = (__siov *)0x0;
      }
      else {
        iVar27 = __sprint_r(data,fp,(__suio *)ox);
        if (iVar27 == 0) {
          uio.uio_iov = (__siov *)0x0;
        }
      }
      goto LAB_1002057a;
    }
    iVar27 = __swsetup_r(data,fp);
    if (iVar27 == 0) {
      uVar20 = (uint)fp->_flags;
      goto joined_r0x10020da4;
    }
    uVar17 = fp->_flags2;
  }
  if ((uVar17 & 1) != 0) {
    return -1;
  }
LAB_10020df2:
  if ((fp->_flags & 0x200U) == 0) {
    __retarget_lock_release_recursive(&fp->_lock);
  }
  return -1;
switchD_100204b4_caseD_31:
  uVar24 = uVar17 - 0x30;
  pcVar25 = (char *)0x0;
  do {
    uVar17 = (uint)(byte)*fmt0;
    pcVar25 = (char *)(uVar24 + (int)pcVar25 * 10);
    uVar24 = uVar17 - 0x30;
    fmt0 = (char *)((byte *)fmt0 + 1);
  } while (uVar24 < 10);
  goto LAB_1002049e;
switchD_100204b4_caseD_20:
  if (cStack_f5 == '\0') {
    cStack_f5 = ' ';
    uVar17 = (uint)(byte)*fmt0;
  }
  else {
switchD_100204b4_caseD_74:
    uVar17 = (uint)(byte)*fmt0;
  }
  goto LAB_1002049c;
  while( true ) {
    uVar17 = uVar17 + (uVar17 < uVar22);
    uVar17 = uVar22 - (uVar17 - (((uint)((ulonglong)uVar17 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                uVar17 / 5));
    uVar23 = (uVar8 - (uVar22 < uVar17)) * -0x33333333 + uVar17 * -0x33333334 +
             (int)((ulonglong)uVar17 * 0xcccccccd >> 0x20);
    uVar32 = uVar23 >> 1;
    uVar17 = uVar23 * -0x80000000 | uVar17 * -0x33333333 >> 1;
    bVar1 = uVar8 == 0;
    uVar8 = uVar32;
    if ((bVar1) && (uVar22 < 10)) break;
LAB_10020862:
    uVar22 = uVar17;
    uVar17 = uVar22 + uVar8;
    uVar23 = (uVar17 < uVar22) + uVar17;
    uVar20 = uVar20 + 1;
    psVar28 = (size_t *)((int)psVar29 + -1);
    *(char *)((int)psVar29 + -1) =
         (char)uVar22 +
         (char)((uVar22 - (uVar23 - (((uint)((ulonglong)uVar23 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar23 / 5))) * -0x33333333 >> 1) * -10 + '0';
    psVar29 = psVar28;
    if (bVar6) {
      while ((psVar29 = psVar28, *pbStack_120 == uVar20 && (uVar20 != 0xff))) {
        if ((uVar8 == 0) && (uVar22 < 10)) goto LAB_10020d74;
        pcVar15 = (char *)((int)psVar28 - sStack_114);
        strncpy(pcVar15,pcStack_110,sStack_114);
        uVar20 = uVar22 + uVar8 + (uint)(uVar22 + uVar8 < uVar22);
        pbStack_120 = pbStack_120 + (pbStack_120[1] != 0);
        uVar20 = uVar22 - (uVar20 - (((uint)((ulonglong)uVar20 * 0xcccccccd >> 0x20) & 0xfffffffc) +
                                    uVar20 / 5));
        psVar28 = (size_t *)(pcVar15 + -1);
        uVar17 = (uVar8 - (uVar22 < uVar20)) * -0x33333333 + uVar20 * -0x33333334 +
                 (int)((ulonglong)uVar20 * 0xcccccccd >> 0x20);
        uVar8 = uVar17 >> 1;
        uVar23 = uVar20 * -0x33333333 >> 1;
        uVar22 = uVar17 * -0x80000000 | uVar23;
        uVar20 = uVar22 + uVar8 + (uint)(uVar22 + uVar8 < uVar22);
        pcVar15[-1] = (char)uVar23 +
                      (char)((uVar22 - (uVar20 - (((uint)((ulonglong)uVar20 * 0xcccccccd >> 0x20) &
                                                  0xfffffffc) + uVar20 / 5))) * -0x33333333 >> 1) *
                      -10 + '0';
        uVar20 = 1;
      }
      uVar17 = uVar22 + uVar8;
    }
  }
LAB_10020d74:
  pcVar9 = buf + (0x60 - (int)psVar29);
  if ((int)__n < (int)pcVar9) {
    pcVar26 = pcVar9;
  }
  if (cStack_f5 != '\0') {
    pcVar26 = pcVar26 + 1;
    uVar20 = uVar24;
LAB_1002071c:
    uVar24 = uVar20;
    if (uVar20 == 0) goto LAB_100204dc;
    bVar1 = false;
    goto LAB_100204ee;
  }
LAB_100204cc:
  __n = pcVar31;
  uVar20 = uVar24;
  if (uVar24 == 0) {
LAB_100204dc:
    pcVar31 = pcVar25 + -(int)pcVar26;
    if (0 < (int)pcVar31) {
      bVar1 = false;
LAB_10020e34:
      if (0x10 < (int)pcVar31) {
        do {
          while( true ) {
            pcVar15 = pcVar31;
            *psVar10 = (size_t)"                ";
            psVar10[1] = 0x10;
            uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar10 = psVar10 + 2;
            if ((int)uio.uio_iov < 8) break;
            iVar27 = __sprint_r(data,fp,(__suio *)ox);
            if (iVar27 != 0) goto LAB_1002057a;
            pcVar31 = pcVar15 + -0x10;
            psVar10 = psVar30;
            if ((int)(pcVar15 + -0x10) < 0x11) goto LAB_10020e94;
          }
          pcVar31 = pcVar15 + -0x10;
        } while (0x10 < (int)(pcVar15 + -0x10));
LAB_10020e94:
        pcVar31 = pcVar15 + -0x10;
      }
      *psVar10 = (size_t)"                ";
      psVar10[1] = (size_t)pcVar31;
      uio.uio_iovcnt = uio.uio_iovcnt + (int)pcVar31;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      if ((int)uio.uio_iov < 8) {
        psVar10 = psVar10 + 2;
        if (cStack_f5 != '\0') {
          uVar20 = 0;
          goto LAB_100204ee;
        }
        if (!bVar1) goto LAB_10020528;
        uVar20 = 0;
      }
      else {
        iVar27 = __sprint_r(data,fp,(__suio *)ox);
        if (iVar27 != 0) goto LAB_1002057a;
        uVar20 = 0;
        psVar10 = psVar30;
        if (cStack_f5 == '\0') {
          if (bVar1) goto LAB_1002050a;
          goto LAB_10020528;
        }
LAB_100204ee:
        *psVar10 = (size_t)&cStack_f5;
        psVar10[1] = 1;
        uio.uio_iovcnt = uio.uio_iovcnt + 1;
        uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
        psVar10 = psVar10 + 2;
        if ((7 < (int)uio.uio_iov) &&
           (iVar27 = __sprint_r(data,fp,(__suio *)ox), psVar10 = psVar30, iVar27 != 0))
        goto LAB_1002057a;
        if (!bVar1) goto LAB_10020520;
      }
LAB_1002050a:
      *psVar10 = (size_t)&uStack_f4;
      psVar10[1] = 2;
      uio.uio_iovcnt = uio.uio_iovcnt + 2;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      psVar10 = psVar10 + 2;
      if ((7 < (int)uio.uio_iov) &&
         (iVar27 = __sprint_r(data,fp,(__suio *)ox), psVar10 = psVar30, iVar27 != 0))
      goto LAB_1002057a;
      goto LAB_10020520;
    }
    if (cStack_f5 != '\0') {
      uVar20 = 0;
      bVar1 = false;
      goto LAB_100204ee;
    }
LAB_10020528:
    iVar27 = (int)__n - (int)pcVar9;
  }
  else {
LAB_10020520:
    if ((uVar20 != 0x80) || (iVar27 = (int)pcVar25 - (int)pcVar26, iVar27 < 1)) goto LAB_10020528;
    if (0x10 < iVar27) {
      do {
        while( true ) {
          iVar14 = iVar27;
          *psVar10 = (size_t)"0000000000000000";
          psVar10[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar27 = __sprint_r(data,fp,(__suio *)ox);
          if (iVar27 != 0) goto LAB_1002057a;
          iVar27 = iVar14 + -0x10;
          psVar10 = psVar30;
          if (iVar14 + -0x10 < 0x11) goto LAB_10020c20;
        }
        iVar27 = iVar14 + -0x10;
      } while (0x10 < iVar14 + -0x10);
LAB_10020c20:
      iVar27 = iVar14 + -0x10;
    }
    *psVar10 = (size_t)"0000000000000000";
    psVar10[1] = iVar27;
    uio.uio_iovcnt = uio.uio_iovcnt + iVar27;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    psVar10 = psVar10 + 2;
    if ((int)uio.uio_iov < 8) goto LAB_10020528;
    iVar27 = __sprint_r(data,fp,(__suio *)ox);
    if (iVar27 != 0) goto LAB_1002057a;
    iVar27 = (int)__n - (int)pcVar9;
    psVar10 = psVar30;
  }
  if (iVar27 < 1) {
LAB_10020530:
    *psVar10 = (size_t)psVar29;
    psVar10[1] = (size_t)pcVar9;
    psVar10 = psVar10 + 2;
  }
  else {
    if (0x10 < iVar27) {
      do {
        while( true ) {
          iVar14 = iVar27;
          *psVar10 = (size_t)"0000000000000000";
          psVar10[1] = 0x10;
          uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
          uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
          psVar10 = psVar10 + 2;
          if ((int)uio.uio_iov < 8) break;
          iVar27 = __sprint_r(data,fp,(__suio *)ox);
          if (iVar27 != 0) goto LAB_1002057a;
          iVar27 = iVar14 + -0x10;
          psVar10 = psVar30;
          if (iVar14 + -0x10 < 0x11) goto LAB_10020cb4;
        }
        iVar27 = iVar14 + -0x10;
      } while (0x10 < iVar14 + -0x10);
LAB_10020cb4:
      iVar27 = iVar14 + -0x10;
    }
    *psVar10 = (size_t)"0000000000000000";
    psVar10[1] = iVar27;
    uio.uio_iovcnt = uio.uio_iovcnt + iVar27;
    uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
    psVar10 = psVar10 + 2;
    if ((int)uio.uio_iov < 8) goto LAB_10020530;
    iVar27 = __sprint_r(data,fp,(__suio *)ox);
    if (iVar27 != 0) goto LAB_1002057a;
    psVar10 = &iov[0].iov_len;
    uio.uio_resid = (size_t)psVar29;
    iov[0].iov_base = pcVar9;
  }
  uio.uio_iovcnt = uio.uio_iovcnt + (int)pcVar9;
  uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
  if (((int)uio.uio_iov < 8) ||
     (iVar27 = __sprint_r(data,fp,(__suio *)ox), psVar10 = psVar30, iVar27 == 0)) {
    if (((uVar24 & 4) != 0) && (iVar27 = (int)pcVar25 - (int)pcVar26, 0 < iVar27)) {
      if (0x10 < iVar27) {
        do {
          while( true ) {
            iVar14 = iVar27;
            *psVar10 = (size_t)"                ";
            psVar10[1] = 0x10;
            uio.uio_iovcnt = uio.uio_iovcnt + 0x10;
            uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
            psVar10 = psVar10 + 2;
            if ((int)uio.uio_iov < 8) break;
            iVar27 = __sprint_r(data,fp,(__suio *)ox);
            if (iVar27 != 0) goto LAB_1002057a;
            iVar27 = iVar14 + -0x10;
            psVar10 = psVar30;
            if (iVar14 + -0x10 < 0x11) goto LAB_10020668;
          }
          iVar27 = iVar14 + -0x10;
        } while (0x10 < iVar14 + -0x10);
LAB_10020668:
        iVar27 = iVar14 + -0x10;
      }
      *psVar10 = (size_t)"                ";
      psVar10[1] = iVar27;
      uio.uio_iovcnt = uio.uio_iovcnt + iVar27;
      uio.uio_iov = (__siov *)((int)&(uio.uio_iov)->iov_base + 1);
      if ((7 < (int)uio.uio_iov) && (iVar27 = __sprint_r(data,fp,(__suio *)ox), iVar27 != 0))
      goto LAB_1002057a;
    }
    if ((int)pcVar25 < (int)pcVar26) {
      pcVar25 = pcVar26;
    }
    iStack_128 = iStack_128 + (int)pcVar25;
    if ((uio.uio_iovcnt == 0) || (iVar27 = __sprint_r(data,fp,(__suio *)ox), iVar27 == 0)) {
      uio.uio_iov = (__siov *)0x0;
      bVar18 = *fmt0;
      psVar10 = psVar30;
      goto joined_r0x10020444;
    }
  }
LAB_1002057a:
  uVar19 = fp->_flags;
  if (((fp->_flags2 & 1U) == 0) && ((uVar19 & 0x200) == 0)) {
    __retarget_lock_release_recursive(&fp->_lock);
    uVar19 = fp->_flags;
  }
  if ((uVar19 & 0x40) == 0) {
    return iStack_128;
  }
  return -1;
}



// WARNING: Unknown calling convention

int vfiprintf(FILE *fp,char *fmt0,va_list ap)

{
  _reent *data;
  int iVar1;
  
  gp = &__global_pointer_;
  data = __wrap___getreent();
  iVar1 = _vfiprintf_r(data,fp,fmt0,ap);
  return iVar1;
}



// WARNING: Unknown calling convention

int __sbprintf(_reent *rptr,FILE *fp,char *fmt,va_list ap)

{
  int iVar1;
  int iVar2;
  undefined1 local_490 [4];
  FILE fake;
  uchar buf [1024];
  
  gp = &__global_pointer_;
  fake._w._2_2_ = fp->_file;
  fake._data = (_reent *)fp->_cookie;
  fake._read = fp->_write;
  fake._mbstate.__value = (anon_union_4_2_91654ee9_for___value)fp->_flags2;
  fake._w._0_2_ = fp->_flags & 0xfffd;
  local_490 = (undefined1  [4])&fake.field_0x6c;
  fake._r = 0x400;
  fake._bf._base = (uchar *)0x400;
  fake._bf._size = 0;
  fake._12_4_ = local_490;
  __retarget_lock_init_recursive((_LOCK_T)&fake._offset);
  iVar1 = _vfiprintf_r(rptr,(FILE *)local_490,fmt,ap);
  if ((-1 < iVar1) && (iVar2 = _fflush_r(rptr,(FILE *)local_490), iVar2 != 0)) {
    iVar1 = -1;
  }
  if (((ushort)fake._w & 0x40) != 0) {
    fp->_flags = fp->_flags | 0x40;
  }
  __retarget_lock_close_recursive((_LOCK_T)&fake._offset);
  return iVar1;
}



// WARNING: Unknown calling convention

int __ssputs_r(_reent *ptr,FILE *fp,char *buf,size_t len)

{
  ushort uVar1;
  uchar *__dest;
  uchar *puVar2;
  uint uVar3;
  size_t __n;
  uint bytes;
  size_t __n_00;
  
  gp = &__global_pointer_;
  __dest = fp->_p;
  __n = len;
  if (((uint)fp->_w <= len) && (__n = fp->_w, (fp->_flags & 0x480U) != 0)) {
    puVar2 = (fp->_bf)._base;
    __n_00 = (int)__dest - (int)puVar2;
    bytes = ((fp->_bf)._size * 3) / 2;
    uVar3 = len + 1 + __n_00;
    if (bytes < uVar3) {
      bytes = uVar3;
    }
    if ((fp->_flags & 0x400U) == 0) {
      puVar2 = (uchar *)_realloc_r(ptr,puVar2,bytes);
      if (puVar2 == (uchar *)0x0) {
        _free_r(ptr,(fp->_bf)._base);
        goto LAB_1002161c;
      }
    }
    else {
      puVar2 = (uchar *)_malloc_r(ptr,bytes);
      if (puVar2 == (uchar *)0x0) {
LAB_1002161c:
        uVar1 = fp->_flags;
        ptr->_errno = 0xc;
        fp->_flags = uVar1 | 0x40;
        return -1;
      }
      memcpy(puVar2,(fp->_bf)._base,__n_00);
      fp->_flags = fp->_flags & 0xfb7fU | 0x80;
    }
    __dest = puVar2 + __n_00;
    (fp->_bf)._base = puVar2;
    fp->_w = bytes - __n_00;
    (fp->_bf)._size = bytes;
    fp->_p = __dest;
    __n = len;
  }
  memmove(__dest,buf,__n);
  fp->_w = fp->_w - __n;
  fp->_p = fp->_p + __n;
  return 0;
}



// WARNING: Unknown calling convention

int __swsetup_r(_reent *ptr,FILE *fp)

{
  _reent *s;
  uchar *puVar1;
  ushort uVar2;
  int iVar3;
  
  gp = &__global_pointer_;
  s = __wrap___getreent();
  if ((s != (_reent *)0x0) && (s->__cleanup == (_func_void__reent_ptr *)0x0)) {
    __sinit(s);
  }
  uVar2 = fp->_flags;
  if ((uVar2 & 8) == 0) {
    if ((uVar2 & 0x10) == 0) {
      ptr->_errno = 9;
      fp->_flags = uVar2 | 0x40;
      gp = &__global_pointer_;
      return -1;
    }
    if ((uVar2 & 4) == 0) {
      puVar1 = (fp->_bf)._base;
    }
    else {
      puVar1 = (fp->_ub)._base;
      if (puVar1 != (uchar *)0x0) {
        if (puVar1 != fp->_ubuf) {
          _free_r(ptr,puVar1);
          uVar2 = fp->_flags;
        }
        (fp->_ub)._base = (uchar *)0x0;
      }
      puVar1 = (fp->_bf)._base;
      uVar2 = uVar2 & 0xffdb;
      fp->_r = 0;
      fp->_p = puVar1;
    }
    uVar2 = uVar2 | 8;
    fp->_flags = uVar2;
  }
  else {
    puVar1 = (fp->_bf)._base;
  }
  if (puVar1 != (uchar *)0x0) {
    if ((uVar2 & 1) == 0) {
      if ((uVar2 & 2) == 0) {
        fp->_w = (fp->_bf)._size;
        return 0;
      }
LAB_100216f2:
      fp->_w = 0;
      return 0;
    }
LAB_10021660:
    iVar3 = (fp->_bf)._size;
    fp->_w = 0;
    fp->_lbfsize = -iVar3;
    return 0;
  }
  if (((uVar2 & 0x200) == 0) || ((uVar2 & 0x80) != 0)) {
    __smakebuf_r(ptr,fp);
    uVar2 = fp->_flags;
    puVar1 = (fp->_bf)._base;
    if ((uVar2 & 1) != 0) {
      iVar3 = (fp->_bf)._size;
      fp->_w = 0;
      fp->_lbfsize = -iVar3;
      goto LAB_100216ac;
    }
    iVar3 = 0;
    if ((uVar2 & 2) == 0) {
      iVar3 = (fp->_bf)._size;
    }
  }
  else {
    if ((uVar2 & 1) != 0) goto LAB_10021660;
    if ((uVar2 & 2) != 0) goto LAB_100216f2;
    iVar3 = (fp->_bf)._size;
    puVar1 = (uchar *)0x0;
  }
  fp->_w = iVar3;
LAB_100216ac:
  if ((puVar1 == (uchar *)0x0) && ((uVar2 & 0x80) != 0)) {
    fp->_flags = uVar2 | 0x40;
    gp = &__global_pointer_;
    return -1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void __call_exitprocs(int code,void *d)

{
  _atexit *p_Var1;
  uint uVar2;
  int iVar3;
  _func_void **pp_Var4;
  uint uVar5;
  _func_void *p_Var6;
  int iVar7;
  void **ppvVar8;
  _on_exit_args *p_Var9;
  
  gp = &__global_pointer_;
  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);
  if (__atexit != (_atexit *)0x0) {
LAB_10021770:
    p_Var1 = __atexit;
    iVar3 = __atexit->_ind;
    p_Var9 = __atexit->_on_exit_args_ptr;
    uVar2 = iVar3 - 1;
    if (-1 < (int)uVar2) {
      ppvVar8 = p_Var9->_fnargs + iVar3;
      pp_Var4 = __atexit->_fns + iVar3 + -2;
      do {
        if (d != (void *)0x0) {
          if (p_Var9 == (_on_exit_args *)0x0) goto LAB_100217c4;
          while (ppvVar8[0x1f] != d) {
            uVar2 = uVar2 - 1;
            ppvVar8 = ppvVar8 + -1;
            pp_Var4 = pp_Var4 + -1;
            if (uVar2 == 0xffffffff) goto LAB_100217b0;
          }
        }
        p_Var6 = pp_Var4[1];
        if (p_Var1->_ind - 1U == uVar2) {
          p_Var1->_ind = uVar2;
        }
        else {
          pp_Var4[1] = (_func_void *)0x0;
        }
        if (p_Var6 != (_func_void *)0x0) {
          iVar3 = p_Var1->_ind;
          if ((p_Var9 == (_on_exit_args *)0x0) ||
             (uVar5 = 1 << (uVar2 & 0x1f), (p_Var9->_fntypes & uVar5) == 0)) {
            (*p_Var6)();
            iVar7 = p_Var1->_ind;
          }
          else {
            if ((uVar5 & p_Var9->_is_cxa) == 0) {
              (*p_Var6)(code);
            }
            else {
              (*p_Var6)(ppvVar8[-1]);
            }
            iVar7 = p_Var1->_ind;
          }
          if ((iVar7 != iVar3) || (__atexit != p_Var1)) goto LAB_10021832;
        }
        uVar2 = uVar2 - 1;
        ppvVar8 = ppvVar8 + -1;
        pp_Var4 = pp_Var4 + -1;
        if (uVar2 == 0xffffffff) break;
      } while( true );
    }
  }
  goto LAB_100217b0;
LAB_10021832:
  if (__atexit == (_atexit *)0x0) goto LAB_100217b0;
  goto LAB_10021770;
  while (uVar2 = uVar2 - 2, uVar2 != 0xffffffff) {
LAB_100217c4:
    if (uVar2 == 0) break;
  }
LAB_100217b0:
  __retarget_lock_release_recursive(__atexit_recursive_mutex);
  return;
}



// WARNING: Unknown calling convention

_ssize_t _write_r(_reent *ptr,int fd,void *buf,size_t cnt)

{
  ssize_t sVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  sVar1 = _write(fd,buf,cnt);
  if ((sVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return sVar1;
}



// WARNING: Unknown calling convention

int _close_r(_reent *ptr,int fd)

{
  int iVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  iVar1 = _close(fd);
  if ((iVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

_off_t _lseek_r(_reent *ptr,int fd,_off_t pos,int whence)

{
  __off_t _Var1;
  
  gp = &__global_pointer_;
  errno = 0;
  _Var1 = _lseek(fd,pos,whence);
  if ((_Var1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return _Var1;
}



// WARNING: Unknown calling convention

_ssize_t _read_r(_reent *ptr,int fd,void *buf,size_t cnt)

{
  int iVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  iVar1 = _read(fd,(char *)buf,cnt);
  if ((iVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: st
// WARNING: Unknown calling convention

void __smakebuf_r(_reent *ptr,FILE *fp)

{
  size_t bytes;
  int iVar1;
  uchar *puVar2;
  ushort uVar3;
  ushort uVar4;
  undefined1 auStack_68 [4];
  stat st;
  
  gp = &__global_pointer_;
  uVar4 = fp->_flags;
  if ((uVar4 & 2) != 0) {
    fp->_p = fp->_nbuf;
    (fp->_bf)._base = fp->_nbuf;
    (fp->_bf)._size = 1;
    return;
  }
  if (-1 < fp->_file) {
    iVar1 = _fstat_r(ptr,(int)fp->_file,(stat *)auStack_68);
    if (-1 < iVar1) {
      puVar2 = (uchar *)_malloc_r(ptr,0x400);
      uVar4 = fp->_flags;
      if (puVar2 != (uchar *)0x0) {
        uVar4 = uVar4 | 0x80;
        fp->_flags = uVar4;
        fp->_p = puVar2;
        (fp->_bf)._base = puVar2;
        (fp->_bf)._size = 0x400;
        if ((st._0_4_ & 0xf000) == 0x2000) {
          iVar1 = _isatty_r(ptr,(int)fp->_file);
          uVar4 = fp->_flags;
          uVar3 = 0x800;
          if (iVar1 != 0) {
            uVar4 = uVar4 & 0xfffc | 1;
          }
        }
        else {
          uVar3 = 0x800;
        }
        goto LAB_100219de;
      }
      goto LAB_100219f0;
    }
    uVar4 = fp->_flags;
  }
  bytes = (-(uint)((uVar4 & 0x80) == 0) & 0x3c0) + 0x40;
  puVar2 = (uchar *)_malloc_r(ptr,bytes);
  uVar4 = fp->_flags;
  if (puVar2 != (uchar *)0x0) {
    uVar4 = uVar4 | 0x80;
    fp->_p = puVar2;
    (fp->_bf)._base = puVar2;
    (fp->_bf)._size = bytes;
    uVar3 = 0;
LAB_100219de:
    fp->_flags = uVar4 | uVar3;
    return;
  }
LAB_100219f0:
  if ((uVar4 & 0x200) == 0) {
    fp->_flags = uVar4 & 0xfffc | 2;
    fp->_p = fp->_nbuf;
    (fp->_bf)._base = fp->_nbuf;
    (fp->_bf)._size = 1;
  }
  return;
}



// WARNING: Variable defined which should be unmapped: st
// WARNING: Unknown calling convention

int __swhatbuf_r(_reent *ptr,FILE *fp,size_t *bufsize,int *couldbetty)

{
  int iVar1;
  undefined1 auStack_68 [4];
  stat st;
  
  gp = &__global_pointer_;
  if ((-1 < fp->_file) && (iVar1 = _fstat_r(ptr,(int)fp->_file,(stat *)auStack_68), -1 < iVar1)) {
    *couldbetty = (uint)((st._0_4_ & 0xf000) == 0x2000);
    *bufsize = 0x400;
    return 0x800;
  }
  if ((fp->_flags & 0x80U) != 0) {
    *couldbetty = 0;
    *bufsize = 0x40;
    return 0;
  }
  *couldbetty = (ushort)fp->_flags & 0x80;
  *bufsize = 0x400;
  return 0;
}



// WARNING: Unknown calling convention

int _kill_r(_reent *ptr,int pid,int sig)

{
  int iVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  iVar1 = _kill(pid,sig);
  if ((iVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _getpid_r(_reent *ptr)

{
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



// WARNING: Unknown calling convention

int __sprint_r(_reent *ptr,FILE *fp,__suio *uio)

{
  int iVar1;
  
  gp = &__global_pointer_;
  if (uio->uio_resid == 0) {
    uio->uio_iovcnt = 0;
    return 0;
  }
  iVar1 = __sfvwrite_r(ptr,fp,uio);
  uio->uio_resid = 0;
  uio->uio_iovcnt = 0;
  return iVar1;
}



// WARNING: Unknown calling convention

int _fstat_r(_reent *ptr,int fd,stat *pstat)

{
  int iVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  iVar1 = _fstat(fd,(stat *)pstat);
  if ((iVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int _isatty_r(_reent *ptr,int fd)

{
  int iVar1;
  
  gp = &__global_pointer_;
  errno = 0;
  iVar1 = _isatty(fd);
  if ((iVar1 == -1) && (errno != 0)) {
    ptr->_errno = errno;
    return -1;
  }
  return iVar1;
}



void __retarget_lock_init_recursive(_LOCK_T lock)

{
  _LOCK_T lock_local;
  
  gp = &__global_pointer_;
  recursive_mutex_init((recursive_mutex_t *)lock);
  return;
}



void __retarget_lock_close_recursive(_LOCK_T lock)

{
  _LOCK_T lock_local;
  
  gp = &__global_pointer_;
  return;
}



void __retarget_lock_acquire_recursive(_LOCK_T lock)

{
  _LOCK_T lock_local;
  
  gp = &__global_pointer_;
  recursive_mutex_enter_blocking((recursive_mutex_t *)lock);
  return;
}



void __retarget_lock_release_recursive(_LOCK_T lock)

{
  _LOCK_T lock_local;
  
  gp = &__global_pointer_;
  recursive_mutex_exit((recursive_mutex_t *)lock);
  return;
}



ssize_t _write(int fd,void *buf,size_t count)

{
  size_t count_local;
  void *buf_local;
  int fd_local;
  
  gp = &__global_pointer_;
  return 0;
}



int _close(int __fd)

{
  int fd_local;
  
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



int _fstat(int __fd,stat *__buf)

{
  stat *st_local;
  int fd_local;
  
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t _getpid(void)

{
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



int _isatty(int __fd)

{
  int file_local;
  
  gp = &__global_pointer_;
  errno = 0x58;
  return 0;
}



int _kill(__pid_t __pid,int __sig)

{
  int sig_local;
  int pid_local;
  
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



__off_t _lseek(int __fd,__off_t __offset,int __whence)

{
  int dir_local;
  int ptr_local;
  int file_local;
  
  gp = &__global_pointer_;
  errno = 0x58;
  return -1;
}



int _read(int file,char *ptr,int len)

{
  int len_local;
  char *ptr_local;
  int file_local;
  
  gp = &__global_pointer_;
  return -1;
}



void _exit(int __status)

{
  int status_local;
  
  do {
    ebreak();
  } while( true );
}



void * _sbrk(intptr_t __delta)

{
  char *pcVar1;
  char *pcVar2;
  int incr_local;
  char *next_heap_end;
  char *prev_heap_end;
  
  gp = &__global_pointer_;
  if (_sbrk::heap_end == (char *)0x0) {
    _sbrk::heap_end = &end;
  }
  pcVar2 = _sbrk::heap_end;
  pcVar1 = _sbrk::heap_end + __delta;
  if ((char *)((int)core1_stack + 1U) <= _sbrk::heap_end + __delta) {
    pcVar2 = (char *)0xffffffff;
    pcVar1 = _sbrk::heap_end;
  }
  _sbrk::heap_end = pcVar1;
  return pcVar2;
}



// WARNING: Removing unreachable block (ram,0x10021d78)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void runtime_init(void)

{
  int iVar1;
  uint in_csrbe5;
  uint32_t meicontext;
  _func_void **p;
  
  gp = &__global_pointer_;
  if ((in_csrbe5 & 0x8000) == 0) {
    iVar1 = (in_csrbe5 >> 4 & 0x1ff) + 0x34;
  }
  else {
    iVar1 = 0;
  }
  if (iVar1 != 0) {
    ebreak();
  }
  runtime_run_initializers();
  for (meicontext = (uint32_t)&__preinit_array_end; meicontext < check_pins;
      meicontext = meicontext + 4) {
    (**(code **)meicontext)(*(code **)meicontext);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x20000034)

void _MFIFO::_irq(void)

{
  bool bVar1;
  undefined3 extraout_var;
  
  gp = &__global_pointer_;
  bVar1 = multicore_doorbell_is_set_current_core((uint)_doorbell);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    return;
  }
  noInterrupts();
  do {
  } while( true );
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void mutex_enter_blocking(mutex_t *mtx)

{
  int8_t caller;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void recursive_mutex_enter_blocking(recursive_mutex_t *mtx)

{
  int8_t caller;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

_Bool mutex_try_enter(mutex_t *mtx,uint32_t *owner_out)

{
  uint32_t save;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool mutex_enter_block_until(mutex_t *mtx,absolute_time_t until)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool mutex_enter_timeout_ms(mutex_t *mtx,uint32_t timeout_ms)

{
  _Bool _Var1;
  
  gp = &__global_pointer_;
  time_us_64();
  _Var1 = mutex_enter_block_until(mtx,aRam00000010);
  return _Var1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void mutex_exit(mutex_t *mtx)

{
  uint32_t save;
  
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void recursive_mutex_exit(recursive_mutex_t *mtx)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void flash_init_boot2_copyout(void)

{
  uint32_t uVar1;
  uint32_t *puVar2;
  uint32_t *puVar3;
  
  gp = &__global_pointer_;
  if (!boot2_copyout_valid) {
    puVar2 = (uint32_t *)&DAT_400e0000;
    puVar3 = boot2_copyout;
    do {
      uVar1 = *puVar2;
      puVar2 = puVar2 + 1;
      *puVar3 = uVar1;
      puVar3 = puVar3 + 1;
    } while (puVar2 != (uint32_t *)0x400e0100);
    boot2_copyout_valid = true;
  }
  return;
}



// WARNING: Control flow encountered bad instruction data
// WARNING: Unknown calling convention -- yet parameter storage is locked

void flash_enable_xip_via_boot2(void)

{
  gp = &__global_pointer_;
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void flash_rp2350_save_qmi_cs1(flash_rp2350_qmi_save_state_t *state)

{
  gp = &__global_pointer_;
  state->timing = _DAT_400d0020;
  state->rcmd = _DAT_400d0028;
  state->rfmt = _DAT_400d0024;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

io_rw_16 * flash_devinfo_ptr(void)

{
  undefined4 *puVar1;
  
  gp = &__global_pointer_;
  puVar1 = (undefined4 *)(*(code *)(uint)_DAT_00007df8)(0x4446,0x40,(code *)(uint)_DAT_00007df8);
  return (io_rw_16 *)*puVar1;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void flash_save_hardware_state(flash_hardware_save_state_t *state)

{
  gp = &__global_pointer_;
  xip_cache_clean_all();
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention
// WARNING: Enum "flash_devinfo_size_t": Some values do not have unique names

flash_devinfo_size_t flash_devinfo_get_cs_size(uint cs)

{
  io_rw_16 *piVar1;
  flash_devinfo_size_t fVar2;
  
  gp = &__global_pointer_;
  piVar1 = flash_devinfo_ptr();
  if (cs == 0) {
    fVar2 = FLASH_DEVINFO_SIZE_16M;
  }
  else {
    fVar2 = (flash_devinfo_size_t)(*piVar1 >> 0xc);
  }
  return fVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention
// WARNING: Enum "flash_devinfo_size_t": Some values do not have unique names

void flash_rp2350_restore_qmi_cs1(flash_rp2350_qmi_save_state_t *state)

{
  flash_devinfo_size_t fVar1;
  
  gp = &__global_pointer_;
  fVar1 = flash_devinfo_get_cs_size(1);
  if (fVar1 == FLASH_DEVINFO_SIZE_NONE) {
    _DAT_400d0020 = state->timing;
    _DAT_400d0028 = state->rcmd;
    _DAT_400d0024 = state->rfmt;
  }
  else {
    _DAT_400d002c = 0x1000;
    _DAT_400d0030 = 0xa002;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void flash_restore_hardware_state(flash_hardware_save_state_t *state)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void flash_range_erase(uint32_t flash_offs,size_t count)

{
  code *pcVar1;
  code *pcVar2;
  code *pcVar3;
  code *pcVar4;
  undefined1 auStack_44 [4];
  flash_hardware_save_state_t state;
  
  gp = &__global_pointer_;
  if (0x1000000 < flash_offs + count) {
    hard_assertion_failure();
  }
  pcVar1 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x4649,1,(code *)(uint)_DAT_00007dfa);
  pcVar2 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x5845,1,(code *)(uint)_DAT_00007dfa);
  pcVar3 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x4552,1,(code *)(uint)_DAT_00007dfa);
  pcVar4 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x4346,1,(code *)(uint)_DAT_00007dfa);
  flash_init_boot2_copyout();
  flash_save_hardware_state((flash_hardware_save_state_t *)auStack_44);
  (*pcVar1)();
  (*pcVar2)();
  (*pcVar3)(flash_offs,count,0x10000,0xd8);
  (*pcVar4)();
  flash_enable_xip_via_boot2();
  flash_restore_hardware_state((flash_hardware_save_state_t *)auStack_44);
  return;
}



// WARNING: Variable defined which should be unmapped: state
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void flash_range_program(uint32_t flash_offs,uint8_t *data,size_t count)

{
  code *pcVar1;
  code *pcVar2;
  code *pcVar3;
  code *pcVar4;
  undefined1 auStack_44 [4];
  flash_hardware_save_state_t state;
  
  gp = &__global_pointer_;
  if (0x1000000 < flash_offs + count) {
    hard_assertion_failure();
  }
  pcVar1 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x4649,1,(code *)(uint)_DAT_00007dfa);
  pcVar2 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x5845,1,(code *)(uint)_DAT_00007dfa);
  pcVar3 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x5052,1,(code *)(uint)_DAT_00007dfa);
  pcVar4 = (code *)(*(code *)(uint)_DAT_00007dfa)(0x4346,1,(code *)(uint)_DAT_00007dfa);
  flash_init_boot2_copyout();
  flash_save_hardware_state((flash_hardware_save_state_t *)auStack_44);
  (*pcVar1)();
  (*pcVar2)();
  (*pcVar3)(flash_offs,data,count);
  (*pcVar4)();
  flash_enable_xip_via_boot2();
  flash_restore_hardware_state((flash_hardware_save_state_t *)auStack_44);
  return;
}



// WARNING: Unknown calling convention
// WARNING: Enum "cache_op_t": Some values do not have unique names

void xip_cache_maintain(uintptr_t start_offset,uintptr_t size_bytes,cache_op_t op)

{
  uint uVar1;
  
  gp = &__global_pointer_;
  uVar1 = size_bytes + start_offset;
  for (; start_offset < uVar1; start_offset = start_offset + 8) {
    *(undefined1 *)(op + 0x18000000 + start_offset) = 0;
  }
  fence();
  fence.i();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked
// WARNING: Enum "cache_op_t": Some values do not have unique names

void xip_cache_clean_all(void)

{
  gp = &__global_pointer_;
  xip_cache_maintain(0x3ffc000,0x4000,XIP_CACHE_CLEAN_BY_SET_WAY);
  return;
}



// WARNING: Unknown calling convention

int spi_write_read_blocking(spi_inst_t *spi,uint8_t *src,uint8_t *dst,size_t len)

{
  byte bVar1;
  size_t sVar2;
  size_t sVar3;
  
  gp = &__global_pointer_;
  sVar2 = len;
  sVar3 = len;
LAB_2000051c:
  do {
    if (len == 0 && sVar3 == 0) {
      return sVar2;
    }
    do {
      if (((sVar3 != 0) && ((*(uint *)(spi + 0xc) & 2) != 0)) && (len < sVar3 + 8)) {
        bVar1 = *src;
        sVar3 = sVar3 - 1;
        src = src + 1;
        *(uint *)(spi + 8) = (uint)bVar1;
      }
      if (len == 0) goto LAB_2000051c;
    } while ((*(uint *)(spi + 0xc) & 4) == 0);
    len = len - 1;
    *dst = (uint8_t)*(undefined4 *)(spi + 8);
    dst = dst + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int spi_write_blocking(spi_inst_t *spi,uint8_t *src,size_t len)

{
  size_t sVar1;
  
  gp = &__global_pointer_;
  for (sVar1 = 0; sVar1 != len; sVar1 = sVar1 + 1) {
    do {
    } while ((*(uint *)(spi + 0xc) & 2) == 0);
    *(uint *)(spi + 8) = (uint)src[sVar1];
  }
  do {
  } while ((*(uint *)(spi + 0xc) & 4) != 0);
  do {
  } while ((*(uint *)(spi + 0xc) & 0x10) != 0);
  do {
  } while ((*(uint *)(spi + 0xc) & 4) != 0);
  *(undefined4 *)(spi + 0x20) = 1;
  return len;
}



// WARNING: Unknown calling convention

int spi_read_blocking(spi_inst_t *spi,uint8_t repeated_tx_data,uint8_t *dst,size_t len)

{
  size_t sVar1;
  undefined3 in_register_0000202d;
  size_t sVar2;
  
  gp = &__global_pointer_;
  sVar1 = len;
  sVar2 = len;
LAB_200005a8:
  do {
    if (len == 0 && sVar2 == 0) {
      return sVar1;
    }
    do {
      if (((sVar2 != 0) && ((*(uint *)(spi + 0xc) & 2) != 0)) && (len < sVar2 + 8)) {
        *(uint *)(spi + 8) = CONCAT31(in_register_0000202d,repeated_tx_data);
        sVar2 = sVar2 - 1;
      }
      if (len == 0) goto LAB_200005a8;
    } while ((*(uint *)(spi + 0xc) & 4) == 0);
    len = len - 1;
    *dst = (uint8_t)*(undefined4 *)(spi + 8);
    dst = dst + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int spi_write16_read16_blocking(spi_inst_t *spi,uint16_t *src,uint16_t *dst,size_t len)

{
  ushort uVar1;
  size_t sVar2;
  size_t sVar3;
  
  gp = &__global_pointer_;
  sVar2 = len;
  sVar3 = len;
LAB_200005ee:
  do {
    if (len == 0 && sVar3 == 0) {
      return sVar2;
    }
    do {
      if (((sVar3 != 0) && ((*(uint *)(spi + 0xc) & 2) != 0)) && (len < sVar3 + 8)) {
        uVar1 = *src;
        sVar3 = sVar3 - 1;
        src = src + 1;
        *(uint *)(spi + 8) = (uint)uVar1;
      }
      if (len == 0) goto LAB_200005ee;
    } while ((*(uint *)(spi + 0xc) & 4) == 0);
    len = len - 1;
    *dst = (uint16_t)*(undefined4 *)(spi + 8);
    dst = dst + 1;
  } while( true );
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

void dcd_event_handler(dcd_event_t *event,_Bool in_isr)

{
  dcd_event_t event_resume;
  
  gp = &__global_pointer_;
  if (4 < (byte)(event->event_id - 2)) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x20000904)
// WARNING: Removing unreachable block (ram,0x2000094a)

void __riscv_exception_table(void)

{
  int in_mscratch;
  uint in_mcause;
  
  gp = &__global_pointer_;
  if (in_mscratch != 0) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (in_mcause < 0xc) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x20000904)
// WARNING: Removing unreachable block (ram,0x2000094a)

void isr_riscv_machine_exception(void)

{
  int in_mscratch;
  uint in_mcause;
  
  gp = &__global_pointer_;
  if (in_mscratch != 0) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (in_mcause < 0xc) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x2000094a)

void isr_riscv_machine_ecall_mmode_exception(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void __halt_on_unhandled_exception(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention -- yet parameter storage is locked

void reset_non_control_endpoints(void)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void hw_handle_buff_status(void)

{
  int iVar1;
  uint uVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  uint uVar4;
  undefined1 auStack_3c [4];
  dcd_event_t event;
  
  gp = &__global_pointer_;
  uVar4 = 1;
  for (uVar2 = 0; (_DAT_50110058 != 0 && (uVar2 != 0x20)); uVar2 = uVar2 + 1 & 0xff) {
    if ((_DAT_50110058 & uVar4) != 0) {
      iVar1 = (uVar2 & 0xfe) + (~uVar2 & 1);
      _DAT_50113058 = uVar4;
      _Var3 = hw_endpoint_xfer_continue(hw_endpoints[0] + iVar1);
      if (CONCAT31(extraout_var,_Var3) != 0) {
        event.rhport = hw_endpoints[0][iVar1].ep_addr;
        event.field_2._2_2_ = 0;
        event.field_2._0_2_ = hw_endpoints[0][iVar1].xferred_len;
        auStack_3c[0] = '\0';
        auStack_3c[1] = '\a';
        event.event_id = '\0';
        dcd_event_handler((dcd_event_t *)auStack_3c,true);
        hw_endpoint_reset_transfer(hw_endpoints[0] + iVar1);
      }
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    uVar4 = uVar4 << 1;
  }
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void dcd_rp2040_irq(void)

{
  _Bool _Var1;
  uint uVar2;
  uint uVar3;
  hw_endpoint (*pahVar4) [2];
  char cVar5;
  undefined1 auStack_2c [4];
  dcd_event_t event;
  
  uVar2 = _DAT_50110098;
  gp = &__global_pointer_;
  uVar3 = _DAT_50110098 & 0x20000;
  if (uVar3 != 0) {
    pahVar4 = hw_endpoints;
    e15_last_sof = _DAT_400b0028;
    cVar5 = '\0';
    do {
      if ((((*pahVar4)[1].transfer_type == '\x02') && (_Var1 = (*pahVar4)[1].active, _Var1 != false)
          ) && (cVar5 = _Var1, (*pahVar4)[1].pending != '\0')) {
        (*pahVar4)[1].pending = '\0';
        hw_endpoint_start_next_buffer(*pahVar4 + 1);
      }
      pahVar4 = pahVar4 + 1;
    } while ((String *)pahVar4 != &pinStatesRow1);
    if ((cVar5 == '\0') && (_sof_enable == false)) {
      _DAT_50113090 = 0x20000;
    }
    event._0_4_ = _DAT_50110048 & 0x7ff;
    auStack_2c[0] = '\0';
    auStack_2c[1] = '\x03';
    uVar3 = 0x20000;
    dcd_event_handler((dcd_event_t *)auStack_2c,true);
  }
  if ((uVar2 & 0x10) != 0) {
    uVar3 = uVar3 | 0x10;
    hw_handle_buff_status();
  }
  if ((int)(uVar2 << 0xf) < 0) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if ((int)(uVar2 << 0x13) < 0) {
    _DAT_50110000 = 0;
    reset_non_control_endpoints();
    auStack_2c[0] = '\0';
    auStack_2c[1] = '\x01';
    event.rhport = '\0';
    event.event_id = '\0';
    event._2_2_ = 0;
    dcd_event_handler((dcd_event_t *)auStack_2c,true);
    _DAT_50113050 = 0x80000;
    if (_DAT_5011004c << 0xf < 0) {
      rp2040_usb_device_enumeration_fix();
    }
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  if (-1 < (int)(uVar2 << 0x11)) {
    if ((int)(uVar2 << 0x10) < 0) {
      auStack_2c[0] = '\0';
      auStack_2c[1] = '\x05';
      dcd_event_handler((dcd_event_t *)auStack_2c,true);
                    // WARNING: Unimplemented instruction - Truncating control flow here
      halt_unimplemented();
    }
    if (uVar3 == uVar2) {
      return;
    }
                    // WARNING: Subroutine does not return
    panic("Unhandled IRQ 0x%x\n",uVar3 ^ uVar2);
  }
  auStack_2c[0] = '\0';
  auStack_2c[1] = '\x04';
  dcd_event_handler((dcd_event_t *)auStack_2c,true);
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Unknown calling convention

uint32_t prepare_ep_buffer(hw_endpoint *ep,uint8_t buf_id)

{
  gp = &__global_pointer_;
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

_Bool e15_is_bulkin_ep(hw_endpoint *ep)

{
  gp = &__global_pointer_;
  if (((_DAT_50110040 & 2) == 0) && ((char)ep->ep_addr < '\0')) {
    return ep->transfer_type == '\x02';
  }
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

_Bool e15_is_critical_frame_period(hw_endpoint *ep)

{
  _Bool _Var1;
  undefined3 extraout_var;
  uint uVar2;
  
  gp = &__global_pointer_;
  _Var1 = e15_is_bulkin_ep(ep);
  uVar2 = CONCAT31(extraout_var,_Var1);
  if (uVar2 != 0) {
    uVar2 = (uint)((_DAT_400b0028 + -800) - e15_last_sof < 199);
  }
  return SUB41(uVar2,0);
}



// WARNING: Unknown calling convention

uint16_t sync_ep_buffer(hw_endpoint *ep,uint8_t buf_id)

{
  uint16_t uVar1;
  uint uVar2;
  undefined3 in_register_0000202d;
  uint8_t *puVar3;
  uint uVar4;
  uint8_t *puVar5;
  
  gp = &__global_pointer_;
  uVar2 = *ep->buffer_control;
  if (CONCAT31(in_register_0000202d,buf_id) != 0) {
    uVar2 = uVar2 >> 0x10;
  }
  uVar2 = uVar2 & 0x3ff;
  uVar1 = (uint16_t)uVar2;
  if (ep->rx == false) {
    ep->xferred_len = ep->xferred_len + uVar1;
  }
  else {
    puVar3 = ep->user_buf;
    puVar5 = ep->hw_data_buf;
    for (uVar4 = 0; uVar2 != uVar4; uVar4 = uVar4 + 1) {
      puVar3[uVar4] = puVar5[CONCAT31(in_register_0000202d,buf_id) * 0x40 + uVar4];
    }
    ep->xferred_len = ep->xferred_len + uVar1;
    ep->user_buf = ep->user_buf + uVar2;
  }
  if (uVar2 < ep->wMaxPacketSize) {
    ep->remaining_len = 0;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void _hw_endpoint_xfer_sync(hw_endpoint *ep)

{
  uint16_t uVar1;
  undefined2 extraout_var;
  
  gp = &__global_pointer_;
  uVar1 = sync_ep_buffer(ep,'\0');
  if (((int)(*ep->endpoint_control << 1) < 0) &&
     ((uint)ep->wMaxPacketSize == CONCAT22(extraout_var,uVar1))) {
    sync_ep_buffer(ep,'\x01');
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void hw_endpoint_reset_transfer(hw_endpoint *ep)

{
  gp = &__global_pointer_;
  ep->active = false;
  ep->user_buf = (uint8_t *)0x0;
  ep->remaining_len = 0;
  ep->xferred_len = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void _hw_endpoint_buffer_control_update32(hw_endpoint *ep,uint32_t and_mask,uint32_t or_mask)

{
  io_rw_32 *piVar1;
  int iVar2;
  
  gp = &__global_pointer_;
  piVar1 = ep->buffer_control;
  if (and_mask != 0) {
    and_mask = and_mask & *piVar1;
  }
  if (or_mask != 0) {
    and_mask = and_mask | or_mask;
    if ((or_mask & 0x400) != 0) {
      if ((*piVar1 & 0x400) != 0) {
                    // WARNING: Subroutine does not return
        panic("ep %02X was already available",(uint)ep->ep_addr);
      }
      *piVar1 = and_mask & 0xfffffbff;
      if ((_DAT_50110040 & 2) == 0) {
        iVar2 = 0xc;
        do {
          iVar2 = iVar2 + -2;
        } while (-1 < iVar2);
      }
    }
  }
  *ep->buffer_control = and_mask;
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention

void hw_endpoint_start_next_buffer(hw_endpoint *ep)

{
  gp = &__global_pointer_;
  prepare_ep_buffer(ep,'\0');
                    // WARNING: Unimplemented instruction - Truncating control flow here
  halt_unimplemented();
}



// WARNING: Unknown calling convention

_Bool hw_endpoint_xfer_continue(hw_endpoint *ep)

{
  char cVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  
  gp = &__global_pointer_;
  cVar1 = ep->active;
  if ((_Bool)cVar1 == false) {
                    // WARNING: Subroutine does not return
    panic("Can\'t continue xfer on inactive ep %02X",(uint)ep->ep_addr);
  }
  _hw_endpoint_xfer_sync(ep);
  if (ep->remaining_len != 0) {
    _Var2 = e15_is_critical_frame_period(ep);
    if (CONCAT31(extraout_var,_Var2) == 0) {
      hw_endpoint_start_next_buffer(ep);
    }
    else {
      ep->pending = '\x01';
    }
    cVar1 = '\0';
  }
  return (_Bool)cVar1;
}



uint __udivdi3(UDItype n,UDItype d)

{
  uint in_a0;
  uint in_a1;
  uint uVar1;
  uint in_a2;
  uint uVar2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  
  gp = &__global_pointer_;
  if (in_a3 == 0) {
    if (in_a1 < in_a2) {
      if (in_a2 < 0x10000) {
        iVar3 = (uint)(0xff < in_a2) << 3;
      }
      else {
        iVar3 = 0x18;
        if (in_a2 < 0x1000000) {
          iVar3 = 0x10;
        }
      }
      uVar7 = (uint)__clz_tab[in_a2 >> iVar3] + iVar3;
      uVar4 = 0x20 - uVar7;
      if (uVar7 != 0x20) {
        in_a1 = in_a1 << (uVar4 & 0x1f) | in_a0 >> (uVar7 & 0x1f);
        in_a2 = in_a2 << (uVar4 & 0x1f);
        in_a0 = in_a0 << (uVar4 & 0x1f);
      }
      uVar2 = in_a2 >> 0x10;
      uVar7 = in_a1 / uVar2;
      uVar1 = (in_a2 & 0xffff) * uVar7;
      uVar8 = in_a0 >> 0x10 | in_a1 % uVar2 << 0x10;
      uVar4 = uVar7;
      if (uVar8 < uVar1) {
        uVar8 = uVar8 + in_a2;
        uVar4 = uVar7 - 1;
        if ((in_a2 <= uVar8) && (uVar8 < uVar1)) {
          uVar4 = uVar7 - 2;
          uVar8 = uVar8 + in_a2;
        }
      }
      uVar6 = (uVar8 - uVar1) / uVar2;
      uVar5 = (in_a2 & 0xffff) * uVar6;
      uVar1 = in_a0 & 0xffff | (uVar8 - uVar1) % uVar2 << 0x10;
      uVar7 = uVar6;
      if (uVar1 < uVar5) {
        uVar1 = uVar1 + in_a2;
        if ((uVar1 < in_a2) || (uVar7 = uVar6 - 2, uVar5 <= uVar1)) {
          uVar7 = uVar6 - 1;
        }
      }
      return uVar4 << 0x10 | uVar7;
    }
    if (in_a2 == 0) {
      uVar4 = (uint)__clz_tab[0];
    }
    else {
      if (in_a2 < 0x10000) {
        iVar3 = (uint)(0xff < in_a2) << 3;
        uVar4 = in_a2 >> iVar3;
      }
      else if (in_a2 < 0x1000000) {
        uVar4 = in_a2 >> 0x10;
        iVar3 = 0x10;
      }
      else {
        uVar4 = in_a2 >> 0x18;
        iVar3 = 0x18;
      }
      uVar4 = (uint)__clz_tab[uVar4] + iVar3;
    }
    if (uVar4 == 0x20) {
      uVar4 = in_a1 - in_a2;
      uVar2 = in_a2 >> 0x10;
      uVar1 = in_a2 & 0xffff;
    }
    else {
      uVar5 = 0x20 - uVar4;
      in_a2 = in_a2 << (uVar5 & 0x1f);
      uVar7 = in_a1 >> (uVar4 & 0x1f);
      uVar2 = in_a2 >> 0x10;
      uVar1 = in_a2 & 0xffff;
      uVar8 = in_a0 >> (uVar4 & 0x1f) | in_a1 << (uVar5 & 0x1f);
      in_a0 = in_a0 << (uVar5 & 0x1f);
      uVar4 = uVar1 * (uVar7 / uVar2);
      uVar7 = uVar8 >> 0x10 | uVar7 % uVar2 << 0x10;
      if (((uVar7 < uVar4) && (uVar7 = uVar7 + in_a2, in_a2 <= uVar7)) && (uVar7 < uVar4)) {
        uVar7 = uVar7 + in_a2;
      }
      uVar5 = uVar1 * ((uVar7 - uVar4) / uVar2);
      uVar4 = uVar8 & 0xffff | (uVar7 - uVar4) % uVar2 << 0x10;
      if (((uVar4 < uVar5) && (uVar4 = uVar4 + in_a2, in_a2 <= uVar4)) && (uVar4 < uVar5)) {
        uVar4 = uVar4 + in_a2;
      }
      uVar4 = uVar4 - uVar5;
    }
    uVar8 = uVar4 / uVar2;
    uVar7 = uVar8 * uVar1;
    uVar5 = uVar4 % uVar2 << 0x10 | in_a0 >> 0x10;
    uVar4 = uVar8;
    if (uVar5 < uVar7) {
      uVar5 = uVar5 + in_a2;
      uVar4 = uVar8 - 1;
      if ((in_a2 <= uVar5) && (uVar5 < uVar7)) {
        uVar4 = uVar8 - 2;
        uVar5 = uVar5 + in_a2;
      }
    }
    uVar8 = (uVar5 - uVar7) / uVar2;
    uVar2 = in_a0 & 0xffff | (uVar5 - uVar7) % uVar2 << 0x10;
    uVar7 = uVar8;
    if (uVar2 < uVar8 * uVar1) {
      uVar2 = uVar2 + in_a2;
      if ((uVar2 < in_a2) || (uVar7 = uVar8 - 2, uVar8 * uVar1 <= uVar2)) {
        uVar7 = uVar8 - 1;
      }
    }
    return uVar4 << 0x10 | uVar7;
  }
  if (in_a1 < in_a3) {
    return 0;
  }
  if (in_a3 < 0x10000) {
    iVar3 = (uint)(0xff < in_a3) << 3;
  }
  else {
    iVar3 = 0x18;
    if (in_a3 < 0x1000000) {
      iVar3 = 0x10;
    }
  }
  uVar4 = (uint)__clz_tab[in_a3 >> iVar3] + iVar3;
  uVar7 = 0x20 - uVar4;
  if (uVar4 == 0x20) {
    if (in_a1 <= in_a3) {
      return (uint)(in_a2 <= in_a0);
    }
    return 1;
  }
  uVar10 = in_a2 >> (uVar4 & 0x1f) | in_a3 << (uVar7 & 0x1f);
  uVar8 = in_a1 >> (uVar4 & 0x1f);
  uVar11 = uVar10 >> 0x10;
  uVar6 = uVar8 / uVar11;
  uVar5 = in_a0 >> (uVar4 & 0x1f) | in_a1 << (uVar7 & 0x1f);
  uVar2 = in_a2 << (uVar7 & 0x1f);
  uVar1 = (uVar10 & 0xffff) * uVar6;
  uVar8 = uVar5 >> 0x10 | uVar8 % uVar11 << 0x10;
  uVar4 = uVar6;
  if (uVar8 < uVar1) {
    uVar8 = uVar8 + uVar10;
    uVar4 = uVar6 - 1;
    if ((uVar10 <= uVar8) && (uVar8 < uVar1)) {
      uVar4 = uVar6 - 2;
      uVar8 = uVar8 + uVar10;
    }
  }
  uVar9 = (uVar8 - uVar1) / uVar11;
  uVar6 = (uVar10 & 0xffff) * uVar9;
  uVar8 = uVar5 & 0xffff | (uVar8 - uVar1) % uVar11 << 0x10;
  uVar1 = uVar9;
  if (uVar8 < uVar6) {
    uVar8 = uVar8 + uVar10;
    uVar1 = uVar9 - 1;
    if ((uVar10 <= uVar8) && (uVar8 < uVar6)) {
      uVar1 = uVar9 - 2;
      uVar8 = uVar8 + uVar10;
    }
  }
  uVar5 = uVar4 << 0x10 | uVar1;
  uVar4 = uVar2 & 0xffff;
  uVar2 = uVar2 >> 0x10;
  uVar10 = (uVar5 >> 0x10) * uVar4;
  uVar4 = (uVar1 & 0xffff) * uVar4;
  uVar1 = (uVar1 & 0xffff) * uVar2 + uVar10 + (uVar4 >> 0x10);
  iVar3 = (uVar5 >> 0x10) * uVar2;
  if (uVar1 < uVar10) {
    iVar3 = iVar3 + 0x10000;
  }
  uVar2 = (uVar1 >> 0x10) + iVar3;
  if ((uVar2 <= uVar8 - uVar6) &&
     ((uVar8 - uVar6 != uVar2 || (uVar1 * 0x10000 + (uVar4 & 0xffff) <= in_a0 << (uVar7 & 0x1f)))))
  {
    return uVar5;
  }
  return uVar5 - 1;
}



// WARNING: Removing unreachable block (ram,0x20001352)
// WARNING: Type propagation algorithm not settling

uint __adddf3(DFtype a,DFtype b)

{
  uint in_a0;
  int iVar1;
  uint in_a1;
  uint uVar2;
  uint in_a2;
  uint in_a3;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  USItype x;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  
  gp = &__global_pointer_;
  uVar5 = in_a1 & 0xfffff;
  uVar7 = in_a3 & 0xfffff;
  uVar10 = in_a1 >> 0x14 & 0x7ff;
  uVar8 = in_a0 >> 0x1d;
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  uVar3 = in_a2 >> 0x1d;
  uVar9 = uVar8 | uVar5 << 3;
  uVar6 = uVar10 - uVar2;
  uVar4 = uVar3 | uVar7 << 3;
  uVar11 = in_a0 * 8;
  uVar12 = in_a2 * 8;
  if (in_a1 >> 0x1f == in_a3 >> 0x1f) {
    if (0 < (int)uVar6) {
      if (uVar2 == 0) {
        if (uVar4 == 0 && uVar12 == 0) goto LAB_20001590;
        uVar2 = uVar6 - 1;
        if (uVar2 == 0) {
LAB_2000189a:
          uVar12 = uVar12 + uVar11;
          uVar6 = uVar4 + uVar9 + (uint)(uVar12 < uVar11);
          if (-1 < (int)(uVar6 * 0x100)) {
            return uVar6 * 0x20000000 | uVar12 >> 3;
          }
          uVar12 = uVar12 >> 1;
          uVar2 = (uVar6 & 0xff7fffff) << 0x1f | uVar12;
          uVar4 = (uVar6 & 0xff7fffff) >> 1;
          if (((uVar12 & 7) == 0) || ((uVar12 & 0xf) == 4)) {
            return uVar4 << 0x1d | uVar2 >> 3;
          }
          uVar4 = (uVar2 + 4 < uVar2) + uVar4;
          uVar3 = uVar2 + 4 >> 3;
          uVar6 = 2;
          goto LAB_20001596;
        }
        if (uVar6 == 0x7ff) goto LAB_20001958;
        if (0x38 < (int)uVar2) {
          uVar3 = uVar11 + 1;
          uVar4 = uVar9;
          uVar2 = uVar6;
          goto LAB_2000138e;
        }
LAB_200014f0:
        if ((int)uVar2 < 0x20) {
          uVar6 = uVar4 << (0x20 - uVar2 & 0x1f) | uVar12 >> (uVar2 & 0x1f) |
                  (uint)(uVar12 << (0x20 - uVar2 & 0x1f) != 0);
          uVar9 = uVar9 + (uVar4 >> (uVar2 & 0x1f));
        }
        else {
          if (uVar2 != 0x20) {
            uVar12 = uVar12 | uVar4 << (0x40 - uVar2 & 0x1f);
          }
          uVar6 = (uint)(uVar12 != 0) | uVar4 >> (uVar2 - 0x20 & 0x1f);
        }
        uVar3 = uVar11 + uVar6;
        uVar4 = uVar9 + (uVar3 < uVar6);
LAB_20001524:
        uVar6 = uVar10;
        if (-1 < (int)(uVar4 << 8)) goto LAB_2000152c;
      }
      else {
        if (uVar10 == 0x7ff) goto LAB_2000164a;
        if ((int)uVar6 < 0x39) {
          uVar4 = uVar4 | 0x800000;
          uVar2 = uVar6;
          goto LAB_200014f0;
        }
        uVar4 = 0;
        if (-1 < (int)(uVar9 << 8)) {
          uVar3 = uVar11 + 1;
          uVar4 = uVar9;
          uVar2 = uVar10;
          goto LAB_2000138e;
        }
        uVar3 = 0;
      }
      uVar6 = uVar10 + 1;
      if (uVar6 == 0x7ff) {
        return 0;
      }
      uVar2 = uVar4 & 0xff7fffff;
      uVar4 = uVar2 >> 1;
      uVar3 = uVar2 << 0x1f | uVar3 >> 1 | uVar3 & 1;
LAB_2000137e:
      if ((uVar3 & 7) != 0) {
LAB_20001384:
        uVar2 = uVar6;
        if ((uVar3 & 0xf) != 4) {
LAB_2000138e:
          uVar4 = uVar4 + (uVar3 + 4 < uVar3);
          uVar3 = uVar3 + 4;
          uVar6 = uVar2;
        }
      }
      if ((int)(uVar4 << 8) < 0) {
        if (uVar6 == 0x7fe) {
          return 0;
        }
LAB_200013be:
        return uVar4 << 0x1d | uVar3 >> 3;
      }
      goto LAB_20001540;
    }
    if (uVar6 != 0) {
      uVar6 = uVar2 - uVar10;
      if (uVar10 == 0) {
        if (uVar9 == 0 && uVar11 == 0) {
          uVar3 = in_a2 & 0x1fffffff;
          goto LAB_20001596;
        }
        uVar10 = uVar6 - 1;
        if (uVar10 == 0) goto LAB_2000189a;
        if (uVar6 != 0x7ff) {
          if ((int)uVar10 < 0x39) goto LAB_200019f2;
          uVar3 = uVar12 + 1;
          uVar2 = uVar6;
          goto LAB_2000138e;
        }
      }
      else if (uVar2 != 0x7ff) {
        if (0x38 < (int)uVar6) {
          uVar3 = uVar12 + 1;
          goto LAB_2000138e;
        }
        uVar9 = uVar9 | 0x800000;
        uVar10 = uVar6;
LAB_200019f2:
        if ((int)uVar10 < 0x20) {
          uVar6 = uVar9 << (0x20 - uVar10 & 0x1f) | uVar11 >> (uVar10 & 0x1f) |
                  (uint)(uVar11 << (0x20 - uVar10 & 0x1f) != 0);
          uVar4 = uVar4 + (uVar9 >> (uVar10 & 0x1f));
        }
        else {
          if (uVar10 != 0x20) {
            uVar11 = uVar11 | uVar9 << (0x40 - uVar10 & 0x1f);
          }
          uVar6 = (uint)(uVar11 != 0) | uVar9 >> (uVar10 - 0x20 & 0x1f);
        }
        uVar3 = uVar12 + uVar6;
        uVar4 = (uVar3 < uVar6) + uVar4;
        uVar10 = uVar2;
        goto LAB_20001524;
      }
LAB_2000196c:
      uVar3 = uVar3 << 0x1d | in_a2 & 0x1fffffff;
      goto LAB_200015a8;
    }
    uVar2 = uVar10 + 1;
    if ((uVar2 & 0x7fe) != 0) {
      if (uVar2 == 0x7ff) {
        return 0;
      }
      uVar4 = uVar4 + uVar9 + (uint)(uVar12 + uVar11 < uVar11);
      uVar6 = uVar12 + uVar11 >> 1;
      uVar3 = uVar4 * -0x80000000 | uVar6;
      uVar4 = uVar4 >> 1;
      if (((uVar6 & 7) == 0) || ((uVar6 & 0xf) == 4)) {
        return uVar4 << 0x1d | uVar3 >> 3;
      }
      goto LAB_2000138e;
    }
    if (uVar10 != 0) {
      if (uVar9 != 0 || uVar11 != 0) {
        if (uVar4 != 0 || uVar12 != 0) {
          return 0;
        }
        goto LAB_20001958;
      }
      goto LAB_2000196c;
    }
    if (uVar9 != 0 || uVar11 != 0) {
      uVar6 = uVar11;
      if (uVar4 != 0 || uVar12 != 0) {
        uVar6 = uVar12 + uVar11;
        uVar9 = uVar4 + uVar9 + (uint)(uVar6 < uVar11);
        if ((int)(uVar9 * 0x100) < 0) {
          return uVar9 * 0x20000000 | uVar6 >> 3;
        }
        if (uVar6 == 0 && uVar9 == 0) {
          return 0;
        }
      }
      goto LAB_2000169a;
    }
    if (uVar4 == 0 && uVar12 == 0) {
      return 0;
    }
    uVar6 = 0;
    uVar3 = in_a2 & 0x1fffffff;
  }
  else {
    if (0 < (int)uVar6) {
      if (uVar2 == 0) {
        if (uVar4 == 0 && uVar12 == 0) {
LAB_20001590:
          uVar3 = in_a0 & 0x1fffffff;
          uVar4 = uVar9;
          goto LAB_20001596;
        }
        uVar2 = uVar6 - 1;
        if (uVar2 == 0) {
          uVar3 = uVar11 + in_a2 * -8;
          uVar4 = (uVar9 - uVar4) - (uint)(uVar11 < uVar3);
          if (-1 < (int)(uVar4 * 0x100)) {
            return uVar4 * 0x20000000 | uVar3 >> 3;
          }
LAB_20001916:
          uVar2 = 1;
LAB_200015fe:
          x = uVar4 & 0x7fffff;
          uVar10 = uVar2;
          goto LAB_20001604;
        }
        if (uVar6 != 0x7ff) {
          if (0x38 < (int)uVar2) {
            uVar3 = uVar11 - 1;
            uVar4 = uVar9 - (uVar11 < uVar3);
            uVar2 = uVar6;
joined_r0x2000130a:
            if ((int)(uVar4 * 0x100) < 0) {
              x = 0x7fffff;
              uVar3 = 0xffffffff;
              goto LAB_20001418;
            }
            goto LAB_2000138e;
          }
          goto LAB_200015c0;
        }
      }
      else if (uVar10 != 0x7ff) {
        if (0x38 < (int)uVar6) {
          uVar3 = uVar11 - 1;
          uVar4 = uVar9 - (uVar11 < uVar3);
          uVar2 = uVar10;
          if (-1 < (int)(uVar4 * 0x100)) goto LAB_2000138e;
LAB_20001412:
          x = 0x7fffff;
          uVar3 = 0xffffffff;
          goto LAB_20001418;
        }
        uVar4 = uVar4 | 0x800000;
        uVar2 = uVar6;
LAB_200015c0:
        if ((int)uVar2 < 0x20) {
          uVar3 = uVar4 << (0x20 - uVar2 & 0x1f) | uVar12 >> (uVar2 & 0x1f) |
                  (uint)(uVar12 << (0x20 - uVar2 & 0x1f) != 0);
          uVar9 = uVar9 - (uVar4 >> (uVar2 & 0x1f));
        }
        else {
          if (uVar2 != 0x20) {
            uVar12 = uVar12 | uVar4 << (0x40 - uVar2 & 0x1f);
          }
          uVar3 = (uint)(uVar12 != 0) | uVar4 >> (uVar2 - 0x20 & 0x1f);
        }
        uVar3 = uVar11 - uVar3;
        uVar4 = uVar9 - (uVar11 < uVar3);
        uVar2 = uVar10;
LAB_200015f6:
        uVar6 = uVar2;
        if ((int)(uVar4 << 8) < 0) goto LAB_200015fe;
LAB_2000152c:
        if ((uVar3 & 7) == 0) {
          uVar3 = uVar3 >> 3;
          goto LAB_20001596;
        }
LAB_20001534:
        uVar2 = uVar6;
        if ((uVar3 & 0xf) != 4) goto LAB_2000138e;
        goto LAB_20001540;
      }
LAB_2000164a:
      uVar3 = uVar8 << 0x1d | in_a0 & 0x1fffffff;
      uVar7 = uVar5;
      goto LAB_200015a8;
    }
    if (uVar6 != 0) {
      uVar6 = uVar2 - uVar10;
      if (uVar10 == 0) {
        if (uVar9 == 0 && uVar11 == 0) {
          uVar3 = in_a2 & 0x1fffffff;
          goto LAB_20001596;
        }
        uVar10 = uVar6 - 1;
        if (uVar10 == 0) {
          uVar3 = uVar12 + in_a0 * -8;
          uVar4 = (uVar4 - uVar9) - (uint)(uVar12 < uVar3);
          if (-1 < (int)(uVar4 * 0x100)) {
            return uVar3 >> 3 | uVar4 * 0x20000000;
          }
          goto LAB_20001916;
        }
        if (uVar6 != 0x7ff) {
          if (0x38 < (int)uVar10) {
            uVar3 = uVar12 - 1;
            uVar4 = uVar4 - (uVar12 < uVar3);
            uVar2 = uVar6;
            goto joined_r0x2000130a;
          }
          goto LAB_200016c6;
        }
      }
      else if (uVar2 != 0x7ff) {
        if (0x38 < (int)uVar6) {
          uVar3 = uVar12 - 1;
          uVar4 = uVar4 - (uVar12 < uVar3);
          if ((int)(uVar4 * 0x100) < 0) goto LAB_20001412;
          goto LAB_2000138e;
        }
        uVar9 = uVar9 | 0x800000;
        uVar10 = uVar6;
LAB_200016c6:
        if ((int)uVar10 < 0x20) {
          uVar3 = uVar9 << (0x20 - uVar10 & 0x1f) | uVar11 >> (uVar10 & 0x1f) |
                  (uint)(uVar11 << (0x20 - uVar10 & 0x1f) != 0);
          uVar4 = uVar4 - (uVar9 >> (uVar10 & 0x1f));
        }
        else {
          if (uVar10 != 0x20) {
            uVar11 = uVar11 | uVar9 << (0x40 - uVar10 & 0x1f);
          }
          uVar3 = (uint)(uVar11 != 0) | uVar9 >> (uVar10 - 0x20 & 0x1f);
        }
        uVar3 = uVar12 - uVar3;
        uVar4 = uVar4 - (uVar12 < uVar3);
        goto LAB_200015f6;
      }
      uVar3 = uVar3 << 0x1d | in_a2 & 0x1fffffff;
      goto LAB_200015a8;
    }
    if ((uVar10 + 1 & 0x7fe) == 0) {
      uVar2 = uVar4 | uVar12;
      if (uVar10 == 0) {
        uVar6 = uVar12;
        if (uVar9 != 0 || uVar11 != 0) {
          uVar6 = uVar11;
          if (uVar2 == 0) goto LAB_2000169a;
          uVar6 = uVar11 + in_a2 * -8;
          uVar7 = (uVar9 - uVar4) - (uint)(uVar11 < uVar6);
          if ((int)(uVar7 * 0x100) < 0) {
            uVar3 = uVar12 + in_a0 * -8;
            uVar4 = (uVar4 - uVar9) - (uint)(uVar12 < uVar3);
            if (uVar3 == 0 && uVar4 == 0) {
              return 0;
            }
            if (-1 < (int)(uVar4 * 0x100)) {
              return uVar3 >> 3 | uVar4 * 0x20000000;
            }
            goto LAB_200013be;
          }
          uVar2 = uVar6 | uVar7;
          uVar4 = uVar7;
        }
        uVar9 = uVar4;
        if (uVar2 == 0) {
          return 0;
        }
LAB_2000169a:
        return uVar9 << 0x1d | uVar6 >> 3;
      }
      if (uVar9 == 0 && uVar11 == 0) {
        if (uVar2 == 0) {
          return 0;
        }
        uVar3 = in_a2 & 0x1fffffff | uVar3 << 0x1d;
        goto LAB_200015a8;
      }
      if (uVar2 != 0) {
        return 0;
      }
LAB_20001958:
      uVar3 = uVar8 << 0x1d | in_a0 & 0x1fffffff;
      uVar7 = uVar5;
      goto LAB_200015a8;
    }
    uVar3 = uVar11 + in_a2 * -8;
    x = (uVar9 - uVar4) - (uint)(uVar11 < uVar3);
    if ((int)(x * 0x100) < 0) {
      uVar3 = uVar12 + in_a0 * -8;
      x = (uVar4 - uVar9) - (uint)(uVar12 < uVar3);
    }
    else if (uVar3 == 0 && x == 0) {
      return 0;
    }
LAB_20001604:
    uVar2 = uVar10;
    if (x == 0) {
      iVar1 = __clzsi2(uVar3);
      uVar6 = iVar1 + 0x18;
      if ((int)uVar6 < 0x20) goto LAB_20001422;
      uVar4 = uVar3 << (iVar1 - 8U & 0x1f);
      if ((int)uVar6 < (int)uVar10) {
        return uVar4 << 0x1d;
      }
      uVar9 = (uVar6 - uVar10) + 1;
      if ((int)uVar9 < 0x20) {
        uVar2 = 0x20 - uVar9;
        uVar6 = 0;
        uVar3 = 0;
        goto LAB_20001452;
      }
      uVar3 = uVar4 >> ((uVar6 - uVar10) - 0x1f & 0x1f);
      if (uVar9 != 0x20) {
        uVar3 = uVar3 | uVar4 << (0x40 - uVar9 & 0x1f) != 0;
      }
      if (uVar3 == 0) {
        return 0;
      }
      uVar6 = 0;
      uVar4 = 0;
      if ((uVar3 & 7) == 0) {
        uVar3 = uVar3 >> 3;
        uVar6 = 0;
        uVar4 = 0;
        goto LAB_20001596;
      }
      goto LAB_20001384;
    }
LAB_20001418:
    iVar1 = __clzsi2(x);
    uVar6 = iVar1 - 8;
LAB_20001422:
    uVar4 = uVar3 >> (0x20 - uVar6 & 0x1f) | x << (uVar6 & 0x1f);
    uVar3 = uVar3 << (uVar6 & 0x1f);
    if ((int)uVar2 <= (int)uVar6) {
      uVar9 = (uVar6 - uVar2) + 1;
      uVar2 = 0x20 - uVar9;
      uVar6 = (uint)(uVar3 << (uVar2 & 0x1f) != 0);
      uVar3 = uVar3 >> (uVar9 & 0x1f);
LAB_20001452:
      uVar3 = uVar4 << (uVar2 & 0x1f) | uVar6 | uVar3;
      uVar4 = uVar4 >> (uVar9 & 0x1f);
      uVar6 = 0;
      if (uVar3 == 0 && uVar4 == 0) {
        return 0;
      }
      goto LAB_2000137e;
    }
    uVar6 = uVar2 - uVar6;
    uVar4 = uVar4 & 0xff7fffff;
    if ((uVar3 & 7) != 0) goto LAB_20001534;
LAB_20001540:
    uVar3 = uVar3 >> 3;
  }
LAB_20001596:
  uVar3 = uVar4 << 0x1d | uVar3;
  uVar7 = uVar4 >> 3;
  if (uVar6 != 0x7ff) {
    return uVar3;
  }
LAB_200015a8:
  if (uVar3 != 0 || uVar7 != 0) {
    return 0;
  }
  return 0;
}



// WARNING: Type propagation algorithm not settling

uint __divdf3(DFtype a,DFtype b)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  USItype in_a0;
  int iVar5;
  uint in_a1;
  uint in_a2;
  uint uVar6;
  uint in_a3;
  int iVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  USItype UVar17;
  int iVar18;
  uint uVar19;
  
  gp = &__global_pointer_;
  uVar10 = in_a1 >> 0x14 & 0x7ff;
  uVar4 = in_a1 & 0xfffff;
  if (uVar10 == 0) {
    if (uVar4 == 0 && in_a0 == 0) {
      in_a0 = 0;
      uVar10 = 4;
      iVar15 = 0;
      iVar18 = 1;
      uVar4 = 0;
      goto LAB_20001b54;
    }
    if (uVar4 == 0) {
      iVar18 = __clzsi2(in_a0);
      iVar7 = iVar18 + 0x15;
      iVar15 = iVar18 + 0x20;
      if (iVar7 < 0x1d) goto LAB_20001c74;
      uVar4 = in_a0 << (iVar18 - 8U & 0x1f);
      in_a0 = 0;
    }
    else {
      iVar15 = __clzsi2(uVar4);
      iVar7 = iVar15 + -0xb;
LAB_20001c74:
      uVar4 = in_a0 >> (0x1dU - iVar7 & 0x1f) | uVar4 << (iVar15 - 8U & 0x1f);
      in_a0 = in_a0 << (iVar15 - 8U & 0x1f);
    }
    iVar15 = -0x3f3 - iVar15;
    uVar10 = 0;
    iVar18 = 0;
LAB_20001b54:
    uVar11 = in_a3 >> 0x14 & 0x7ff;
    uVar2 = uVar10;
    uVar16 = uVar4;
    UVar17 = in_a0;
    iVar7 = iVar18;
    if (uVar11 != 0) goto LAB_20001b68;
LAB_20001bca:
    uVar16 = in_a3 & 0xfffff;
    if (uVar16 == 0 && in_a2 == 0) {
      uVar10 = uVar10 | 1;
      uVar2 = 0;
      iVar7 = 1;
      in_a2 = 0;
    }
    else {
      if (uVar16 == 0) {
        iVar5 = __clzsi2(in_a2);
        iVar12 = iVar5 + 0x15;
        iVar7 = iVar5 + 0x20;
        if (iVar12 < 0x1d) goto LAB_20001be2;
        uVar2 = in_a2 << (iVar5 - 8U & 0x1f);
        in_a2 = 0;
      }
      else {
        iVar7 = __clzsi2(uVar16);
        iVar12 = iVar7 + -0xb;
LAB_20001be2:
        uVar2 = uVar16 << (iVar7 - 8U & 0x1f) | in_a2 >> (0x1dU - iVar12 & 0x1f);
        in_a2 = in_a2 << (iVar7 - 8U & 0x1f);
      }
      iVar15 = iVar7 + iVar15 + 0x3f3;
      iVar7 = 0;
    }
  }
  else {
    if (uVar10 != 0x7ff) {
      uVar16 = in_a0 >> 0x1d;
      iVar15 = uVar10 - 0x3ff;
      in_a0 = in_a0 << 3;
      uVar4 = uVar16 | uVar4 << 3 | 0x800000;
      uVar10 = 0;
      iVar18 = 0;
      goto LAB_20001b54;
    }
    iVar15 = 0x7ff;
    if (uVar4 != 0 || in_a0 != 0) {
      uVar10 = 0xc;
      iVar18 = 3;
      goto LAB_20001b54;
    }
    uVar11 = in_a3 >> 0x14 & 0x7ff;
    UVar17 = 0;
    in_a0 = 0;
    uVar10 = 8;
    iVar7 = 2;
    iVar18 = 2;
    uVar4 = 0;
    uVar16 = 0;
    uVar2 = 8;
    if (uVar11 == 0) goto LAB_20001bca;
LAB_20001b68:
    uVar10 = uVar2;
    uVar2 = in_a3 & 0xfffff;
    in_a0 = UVar17;
    uVar4 = uVar16;
    iVar18 = iVar7;
    if (uVar11 == 0x7ff) {
      iVar15 = iVar15 + -0x7ff;
      if (uVar2 == 0 && in_a2 == 0) {
        uVar10 = uVar10 | 2;
        uVar2 = 0;
        iVar7 = 2;
        in_a2 = 0;
      }
      else {
        uVar10 = uVar10 | 3;
        iVar7 = 3;
      }
    }
    else {
      iVar15 = iVar15 - (uVar11 - 0x3ff);
      uVar2 = in_a2 >> 0x1d | uVar2 << 3 | 0x800000;
      in_a2 = in_a2 << 3;
      iVar7 = 0;
    }
  }
  switch(uVar10) {
  default:
    if ((uVar2 < uVar4) || ((uVar4 == uVar2 && (in_a2 <= in_a0)))) {
      uVar10 = uVar4 << 0x1f;
      uVar4 = uVar4 >> 1;
      uVar10 = uVar10 | in_a0 >> 1;
      uVar16 = in_a0 << 0x1f;
    }
    else {
      iVar15 = iVar15 + -1;
      uVar16 = 0;
      uVar10 = in_a0;
    }
    uVar2 = uVar2 << 8;
    uVar1 = uVar2 >> 0x10;
    uVar3 = uVar4 / uVar1;
    uVar6 = in_a2 >> 0x18 | uVar2;
    uVar14 = in_a2 >> 0x18 | uVar2 & 0xffff;
    uVar11 = in_a2 * 0x100;
    uVar2 = uVar14 * uVar3;
    uVar13 = uVar10 >> 0x10 | uVar4 % uVar1 << 0x10;
    uVar4 = uVar3;
    if (uVar13 < uVar2) {
      uVar13 = uVar13 + uVar6;
      uVar4 = uVar3 - 1;
      if ((uVar6 <= uVar13) && (uVar13 < uVar2)) {
        uVar4 = uVar3 - 2;
        uVar13 = uVar13 + uVar6;
      }
    }
    uVar8 = (uVar13 - uVar2) / uVar1;
    uVar19 = uVar14 * uVar8;
    uVar3 = uVar10 & 0xffff | (uVar13 - uVar2) % uVar1 << 0x10;
    uVar10 = uVar8;
    if (uVar3 < uVar19) {
      uVar3 = uVar3 + uVar6;
      uVar10 = uVar8 - 1;
      if ((uVar6 <= uVar3) && (uVar3 < uVar19)) {
        uVar10 = uVar8 - 2;
        uVar3 = uVar3 + uVar6;
      }
    }
    uVar4 = uVar4 << 0x10 | uVar10;
    uVar13 = (in_a2 << 0x18) >> 0x10;
    uVar8 = uVar11 >> 0x10;
    uVar3 = uVar3 - uVar19;
    uVar2 = (uVar10 & 0xffff) * uVar13;
    uVar19 = (uVar4 >> 0x10) * uVar13;
    uVar10 = (uVar2 >> 0x10) + uVar8 * (uVar10 & 0xffff) + uVar19;
    iVar18 = (uVar4 >> 0x10) * uVar8;
    if (uVar10 < uVar19) {
      iVar18 = iVar18 + 0x10000;
    }
    uVar19 = (uVar10 >> 0x10) + iVar18;
    uVar10 = uVar10 * 0x10000 + (uVar2 & 0xffff);
    if ((uVar3 < uVar19) || ((uVar2 = uVar4, uVar9 = uVar16, uVar3 == uVar19 && (uVar16 < uVar10))))
    {
      uVar9 = uVar16 + uVar11;
      uVar3 = uVar3 + (uVar9 < uVar16) + uVar6;
      uVar2 = uVar4 - 1;
      if (((uVar6 < uVar3) || ((uVar6 == uVar3 && (uVar9 < uVar16 == 0)))) &&
         ((uVar3 < uVar19 || ((uVar19 == uVar3 && (uVar9 < uVar10)))))) {
        uVar9 = uVar9 + uVar11;
        uVar2 = uVar4 - 2;
        uVar3 = uVar3 + (uVar9 < uVar11) + uVar6;
      }
    }
    uVar10 = uVar9 - uVar10;
    iVar18 = iVar15 + 0x3ff;
    uVar4 = (uVar3 - uVar19) - (uint)(uVar9 < uVar10);
    if (uVar6 != uVar4) {
      uVar19 = uVar4 / uVar1;
      uVar16 = uVar14 * uVar19;
      uVar3 = uVar4 % uVar1 << 0x10 | uVar10 >> 0x10;
      uVar4 = uVar19;
      if (uVar3 < uVar16) {
        uVar3 = uVar3 + uVar6;
        uVar4 = uVar19 - 1;
        if ((uVar6 <= uVar3) && (uVar3 < uVar16)) {
          uVar4 = uVar19 - 2;
          uVar3 = uVar3 + uVar6;
        }
      }
      uVar19 = (uVar3 - uVar16) / uVar1;
      uVar14 = uVar14 * uVar19;
      uVar10 = uVar10 & 0xffff | (uVar3 - uVar16) % uVar1 << 0x10;
      uVar16 = uVar19;
      if (uVar10 < uVar14) {
        uVar10 = uVar10 + uVar6;
        uVar16 = uVar19 - 1;
        if ((uVar6 <= uVar10) && (uVar10 < uVar14)) {
          uVar16 = uVar19 - 2;
          uVar10 = uVar10 + uVar6;
        }
      }
      uVar1 = uVar4 << 0x10 | uVar16;
      uVar10 = uVar10 - uVar14;
      uVar4 = (uVar1 >> 0x10) * uVar13;
      uVar13 = uVar13 * (uVar16 & 0xffff);
      uVar16 = (uVar13 >> 0x10) + uVar8 * (uVar16 & 0xffff) + uVar4;
      iVar7 = uVar8 * (uVar1 >> 0x10);
      if (uVar16 < uVar4) {
        iVar7 = iVar7 + 0x10000;
      }
      uVar4 = (uVar16 >> 0x10) + iVar7;
      uVar16 = uVar16 * 0x10000 + (uVar13 & 0xffff);
      if (uVar10 < uVar4) {
LAB_20001f60:
        uVar10 = uVar10 + uVar6;
        in_a0 = uVar1 - 1;
        if (uVar10 < uVar6) {
joined_r0x20001fe0:
          if (uVar10 != uVar4) goto LAB_20001eba;
        }
        else {
          if (uVar10 < uVar4) {
LAB_200020a0:
            uVar10 = (in_a2 << 9 < uVar11) + uVar6 + uVar10;
            in_a0 = uVar1 - 2;
            uVar11 = in_a2 << 9;
            goto joined_r0x20001fe0;
          }
          if (uVar10 != uVar4) goto LAB_20001eba;
          if (uVar11 < uVar16) goto LAB_200020a0;
        }
        if (uVar16 != uVar11) goto LAB_20001eba;
        goto LAB_20001cb8;
      }
      in_a0 = uVar1;
      if (uVar10 == uVar4) {
        if (uVar16 != 0) goto LAB_20001f60;
        goto LAB_20001cb8;
      }
LAB_20001eba:
      uVar4 = in_a0 | 1;
      if (iVar15 < -0x3fe) {
        if (iVar15 != -0x3ff) goto LAB_2000200e;
        uVar4 = uVar2 << 0x1f | in_a0 >> 1 | 1;
        uVar2 = uVar2 >> 1;
        goto LAB_20001f92;
      }
      goto LAB_20001ec6;
    }
    uVar4 = 0;
    uVar10 = 1;
    if (iVar18 < 1) {
      if (iVar18 != 0) {
        uVar4 = 0xffffffff;
        goto LAB_2000200e;
      }
      uVar4 = uVar2 << 0x1f | 0x7fffffff;
      uVar2 = uVar2 >> 1;
      goto LAB_20001f92;
    }
    goto LAB_20001ed0;
  case 1:
  case 8:
  case 9:
    goto LAB_20001c0a;
  case 2:
  case 4:
  case 6:
    goto LAB_20001c0a;
  case 3:
  case 7:
  case 0xb:
    in_a0 = in_a2;
    break;
  case 5:
  case 10:
  case 0xf:
    goto LAB_20001c0a;
  case 0xc:
  case 0xd:
  case 0xe:
    uVar2 = uVar4;
    iVar7 = iVar18;
  }
  if (iVar7 == 2) {
LAB_20001c0a:
    return 0;
  }
  if (iVar7 == 3) {
LAB_20001c0a:
    return 0;
  }
  if (iVar7 == 1) {
LAB_20001c0a:
    return 0;
  }
  iVar18 = iVar15 + 0x3ff;
LAB_20001cb8:
  if (0 < iVar18) {
    if (((in_a0 & 7) == 0) || (uVar4 = in_a0, (in_a0 & 0xf) == 4)) {
      uVar4 = in_a0 >> 3;
    }
    else {
LAB_20001ec6:
      uVar10 = (uint)(uVar4 + 4 < uVar4);
      uVar4 = uVar4 + 4 >> 3;
LAB_20001ed0:
      uVar2 = uVar2 + uVar10;
    }
    if ((int)(uVar2 << 7) < 0) {
      iVar18 = iVar15 + 0x400;
      uVar2 = uVar2 & 0xfeffffff;
    }
    if (0x7fe < iVar18) {
      return 0;
    }
    return uVar2 << 0x1d | uVar4;
  }
  uVar4 = in_a0;
  if (iVar18 == 0) {
    uVar10 = in_a0 & 7;
    uVar4 = in_a0 >> 1;
    uVar11 = 0x1f;
    uVar16 = 1;
    if (uVar10 != 0) {
      uVar10 = in_a0 & 1;
    }
  }
  else {
LAB_2000200e:
    uVar16 = 1 - iVar18;
    if (0x38 < (int)uVar16) {
      return 0;
    }
    if (0x1f < (int)uVar16) {
      uVar10 = uVar2 >> (-iVar18 - 0x1fU & 0x1f);
      if (uVar16 != 0x20) {
        uVar4 = uVar4 | uVar2 << (iVar15 + 0x43eU & 0x1f);
      }
      uVar16 = (uint)(uVar4 != 0);
      uVar11 = uVar16 | uVar10;
      uVar2 = uVar16 | uVar10 & 7;
      uVar4 = uVar11;
      if ((uVar2 != 0) && (uVar2 = 0, (uVar16 | uVar10 & 0xf) != 4)) {
        uVar4 = uVar11 + 4;
        uVar2 = (uint)(uVar4 < uVar11) << 0x1d;
      }
      goto LAB_20002066;
    }
    uVar11 = iVar15 + 0x41e;
    uVar10 = (uint)(uVar4 << (uVar11 & 0x1f) != 0);
    uVar4 = uVar4 >> (uVar16 & 0x1f);
  }
  uVar4 = uVar4 | uVar10 | uVar2 << (uVar11 & 0x1f);
  uVar2 = uVar2 >> (uVar16 & 0x1f);
  if (((uVar4 & 7) != 0) && ((uVar4 & 0xf) != 4)) {
LAB_20001f92:
    uVar2 = uVar2 + (uVar4 + 4 < uVar4);
    uVar4 = uVar4 + 4;
  }
  if ((int)(uVar2 << 8) < 0) {
    return 0;
  }
  uVar2 = uVar2 << 0x1d;
LAB_20002066:
  return uVar2 | uVar4 >> 3;
}



__gcc_CMPtype __eqdf2(DFtype a,DFtype b)

{
  int in_a0;
  __gcc_CMPtype r;
  uint in_a1;
  int in_a2;
  ulong B_f0;
  uint in_a3;
  long A_e;
  uint uVar1;
  long B_e;
  uint uVar2;
  
  gp = &__global_pointer_;
  A_e = in_a1 >> 0x14;
  uVar1 = A_e & 0x7ff;
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  if (uVar1 == 0x7ff) {
    if ((uVar2 == 0x7ff) && ((((in_a1 | in_a3) & 0xfffff) == 0 && in_a2 == 0) && in_a0 == 0)) {
      return (uint)(-((int)in_a1 >> 0x1f) != -((int)in_a3 >> 0x1f));
    }
  }
  else {
    if (uVar2 == 0x7ff) {
      return 1;
    }
    if (((uVar1 == uVar2) && ((in_a1 & 0xfffff) == (in_a3 & 0xfffff))) && (in_a2 == in_a0)) {
      if (-((int)in_a1 >> 0x1f) == -((int)in_a3 >> 0x1f)) {
        return 0;
      }
      if (uVar1 == 0) {
        return (uint)((in_a1 & 0xfffff) != 0 || in_a2 != 0);
      }
    }
  }
  return 1;
}



__gcc_CMPtype __gedf2(DFtype a,DFtype b)

{
  uint uVar1;
  uint in_a0;
  __gcc_CMPtype r;
  uint uVar2;
  uint in_a1;
  int iVar3;
  uint in_a2;
  uint in_a3;
  long B_s;
  int iVar4;
  uint uVar5;
  uint uVar6;
  long A_e;
  uint uVar7;
  
  gp = &__global_pointer_;
  A_e = in_a1 >> 0x14;
  uVar7 = A_e & 0x7ff;
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  uVar5 = in_a1 & 0xfffff;
  uVar6 = in_a3 & 0xfffff;
  uVar1 = (int)in_a1 >> 0x1f;
  iVar3 = -uVar1;
  iVar4 = -((int)in_a3 >> 0x1f);
  if (uVar7 == 0x7ff) {
    if (uVar5 != 0 || in_a0 != 0) {
      return -2;
    }
    if (uVar2 == 0x7ff) {
      if (uVar6 != 0 || in_a2 != 0) {
        return -2;
      }
      if (iVar3 == iVar4) {
        return 0;
      }
    }
    goto LAB_200021c2;
  }
  if (uVar2 == 0x7ff) {
    if (in_a2 != 0 || uVar6 != 0) {
      return -2;
    }
    if ((uVar7 == 0) && (uVar5 == 0 && in_a0 == 0)) goto LAB_20002196;
LAB_200021ac:
    if (iVar3 == iVar4) goto LAB_200021b0;
  }
  else {
    if (uVar7 == 0) {
      if (uVar2 != 0) {
        if (uVar5 == 0 && in_a0 == 0) {
LAB_20002196:
          return ((int)in_a3 >> 0x1f) * -2 + -1;
        }
        goto LAB_200021ac;
      }
      if (in_a2 == 0 && uVar6 == 0) {
        if (uVar5 == 0 && in_a0 == 0) {
          return 0;
        }
        goto LAB_200021c2;
      }
      if (uVar5 == 0 && in_a0 == 0) goto LAB_20002196;
      if (iVar3 != iVar4) goto LAB_200021c2;
    }
    else {
      if (((uVar2 == 0) || (iVar3 != iVar4)) || (uVar2 < uVar7)) goto LAB_200021c2;
      if (uVar7 < uVar2) goto LAB_200021b0;
    }
    if (uVar5 <= uVar6) {
      if (uVar5 == uVar6) {
        if (in_a2 < in_a0) goto LAB_200021c2;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
LAB_200021b0:
      return uVar1 * -2 + -1;
    }
  }
LAB_200021c2:
  return uVar1 | 1;
}



__gcc_CMPtype __ledf2(DFtype a,DFtype b)

{
  uint uVar1;
  uint in_a0;
  __gcc_CMPtype r;
  uint uVar2;
  uint in_a1;
  int iVar3;
  uint in_a2;
  uint in_a3;
  long B_s;
  int iVar4;
  uint uVar5;
  uint uVar6;
  long A_e;
  uint uVar7;
  
  gp = &__global_pointer_;
  A_e = in_a1 >> 0x14;
  uVar7 = A_e & 0x7ff;
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  uVar5 = in_a1 & 0xfffff;
  uVar6 = in_a3 & 0xfffff;
  uVar1 = (int)in_a1 >> 0x1f;
  iVar3 = -uVar1;
  iVar4 = -((int)in_a3 >> 0x1f);
  if (uVar7 == 0x7ff) {
    if (uVar5 != 0 || in_a0 != 0) {
      return 2;
    }
    if (uVar2 == 0x7ff) {
      if (uVar6 != 0 || in_a2 != 0) {
        return 2;
      }
      if (iVar3 == iVar4) {
        return 0;
      }
    }
    goto LAB_20002270;
  }
  if (uVar2 == 0x7ff) {
    if (in_a2 != 0 || uVar6 != 0) {
      return 2;
    }
    if ((uVar7 == 0) && (uVar5 == 0 && in_a0 == 0)) goto LAB_20002254;
LAB_2000226c:
    if (iVar3 == iVar4) goto LAB_200022b8;
  }
  else {
    if (uVar7 == 0) {
      if (uVar2 != 0) {
        if (uVar5 == 0 && in_a0 == 0) {
LAB_20002254:
          return ((int)in_a3 >> 0x1f) * -2 + -1;
        }
        goto LAB_2000226c;
      }
      if (in_a2 == 0 && uVar6 == 0) {
        if (uVar5 == 0 && in_a0 == 0) {
          return 0;
        }
        goto LAB_20002270;
      }
      if (uVar5 == 0 && in_a0 == 0) goto LAB_20002254;
      if (iVar3 != iVar4) goto LAB_20002270;
    }
    else {
      if (((uVar2 == 0) || (iVar3 != iVar4)) || (uVar2 < uVar7)) goto LAB_20002270;
      if (uVar7 < uVar2) goto LAB_200022b8;
    }
    if (uVar5 <= uVar6) {
      if (uVar5 == uVar6) {
        if (in_a2 < in_a0) goto LAB_20002270;
        if (in_a2 <= in_a0) {
          return 0;
        }
      }
LAB_200022b8:
      return uVar1 * -2 + -1;
    }
  }
LAB_20002270:
  return uVar1 | 1;
}



// WARNING: Type propagation algorithm not settling

uint __muldf3(DFtype a,DFtype b)

{
  uint uVar1;
  USItype in_a0;
  uint uVar2;
  uint in_a1;
  USItype in_a2;
  uint in_a3;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  int iVar14;
  uint uVar15;
  USItype UVar16;
  int iVar17;
  uint uVar18;
  
  gp = &__global_pointer_;
  uVar5 = in_a1 >> 0x14 & 0x7ff;
  uVar1 = in_a1 & 0xfffff;
  if (uVar5 == 0) {
    if (uVar1 == 0 && in_a0 == 0) {
      uVar1 = 0;
      uVar5 = 4;
      iVar14 = 0;
      iVar17 = 1;
      in_a0 = 0;
      goto LAB_20002328;
    }
    if (uVar1 == 0) {
      iVar17 = __clzsi2(in_a0);
      iVar7 = iVar17 + 0x15;
      iVar14 = iVar17 + 0x20;
      if (iVar7 < 0x1d) goto LAB_2000265e;
      uVar1 = in_a0 << (iVar17 - 8U & 0x1f);
      in_a0 = 0;
    }
    else {
      iVar14 = __clzsi2(uVar1);
      iVar7 = iVar14 + -0xb;
LAB_2000265e:
      uVar1 = uVar1 << (iVar14 - 8U & 0x1f) | in_a0 >> (0x1dU - iVar7 & 0x1f);
      in_a0 = in_a0 << (iVar14 - 8U & 0x1f);
    }
    iVar14 = -0x3f3 - iVar14;
    uVar5 = 0;
    iVar17 = 0;
LAB_20002328:
    uVar6 = in_a3 >> 0x14 & 0x7ff;
    uVar3 = uVar1;
    UVar16 = in_a0;
    uVar8 = uVar5;
    iVar7 = iVar17;
    if (uVar6 == 0) goto LAB_20002558;
LAB_2000233e:
    uVar12 = in_a3 & 0xfffff;
    uVar1 = uVar3;
    in_a0 = UVar16;
    iVar17 = iVar7;
    if (uVar6 == 0x7ff) {
      iVar14 = iVar14 + 0x7ff;
      if (uVar12 == 0 && in_a2 == 0) {
        uVar5 = uVar8 | 2;
        if (10 < uVar5) goto joined_r0x200025aa;
        if (uVar8 == 0) {
          iVar7 = 2;
          goto LAB_200026a6;
        }
        uVar12 = 0;
        iVar7 = 2;
        in_a2 = 0;
        goto LAB_20002376;
      }
      if (10 < (uVar8 | 3)) {
        return 0;
      }
      uVar5 = 1 << (uVar8 | 3);
      iVar17 = 3;
joined_r0x200026d8:
      uVar3 = uVar12;
      UVar16 = in_a2;
      if ((uVar5 & 0x88) != 0) goto joined_r0x200025aa;
    }
    else {
      iVar14 = iVar14 + (uVar6 - 0x3ff);
      if (10 < uVar8) goto joined_r0x200025aa;
      uVar12 = in_a2 >> 0x1d | uVar12 << 3 | 0x800000;
      in_a2 = in_a2 << 3;
      iVar7 = 0;
      uVar5 = uVar8;
      if (2 < uVar8) goto LAB_20002376;
    }
LAB_20002394:
    uVar8 = in_a0 & 0xffff;
    uVar3 = in_a2 & 0xffff;
    uVar15 = in_a0 >> 0x10;
    uVar6 = in_a2 >> 0x10;
    uVar5 = (uVar8 * uVar3 >> 0x10) + uVar6 * uVar8 + uVar15 * uVar3;
    iVar17 = uVar15 * uVar6;
    if (uVar5 < uVar15 * uVar3) {
      iVar17 = iVar17 + 0x10000;
    }
    uVar18 = uVar12 & 0xffff;
    uVar12 = uVar12 >> 0x10;
    uVar2 = (uVar8 * uVar18 >> 0x10) + uVar12 * uVar8 + uVar15 * uVar18;
    iVar7 = uVar15 * uVar12;
    if (uVar2 < uVar15 * uVar18) {
      iVar7 = iVar7 + 0x10000;
    }
    uVar9 = uVar1 & 0xffff;
    uVar1 = uVar1 >> 0x10;
    uVar4 = uVar2 * 0x10000 + (uVar8 * uVar18 & 0xffff);
    uVar15 = (uVar9 * uVar3 >> 0x10) + uVar6 * uVar9 + uVar1 * uVar3;
    iVar10 = uVar6 * uVar1;
    if (uVar15 < uVar1 * uVar3) {
      iVar10 = iVar10 + 0x10000;
    }
    uVar6 = (uVar9 * uVar18 >> 0x10) + uVar12 * uVar9 + uVar1 * uVar18;
    iVar13 = uVar12 * uVar1;
    if (uVar6 < uVar1 * uVar18) {
      iVar13 = iVar13 + 0x10000;
    }
    uVar11 = (uVar5 >> 0x10) + uVar4 + iVar17;
    uVar18 = uVar6 * 0x10000 + (uVar9 * uVar18 & 0xffff);
    uVar1 = (uVar2 >> 0x10) + iVar7 + uVar18;
    uVar9 = uVar11 + (uVar9 * uVar3 & 0xffff) + uVar15 * 0x10000;
    uVar2 = (uVar11 < uVar4) + uVar1;
    uVar12 = (uVar15 >> 0x10) + iVar10 + uVar2;
    uVar15 = (uVar9 < uVar11) + uVar12;
    iVar13 = (uint)(uVar12 < uVar2 || uVar15 < uVar12) +
             (uint)(uVar1 < uVar18 || uVar2 < uVar1) + (uVar6 >> 0x10) + iVar13;
    uVar1 = (uint)((uVar9 & 0x7fffff) != 0 || uVar5 * 0x10000 + (uVar8 * uVar3 & 0xffff) != 0);
    uVar9 = uVar9 >> 0x17;
    uVar3 = uVar15 >> 0x17 | iVar13 * 0x200;
    UVar16 = uVar1 | uVar9 | uVar15 * 0x200;
    if (iVar13 * 0x10000 < 0) {
      UVar16 = UVar16 >> 1 | uVar1 | uVar9 & 1 | (uVar15 >> 0x17) << 0x1f;
      uVar3 = uVar3 >> 1;
      goto LAB_20002600;
    }
    iVar17 = iVar14 + 0x3ff;
    if (0 < iVar17) {
      if ((uVar1 == 0 && (uVar9 & 7) == 0) || ((uVar1 | uVar9 & 0xf) == 4)) goto LAB_20002514;
      goto LAB_200024f4;
    }
  }
  else {
    if (uVar5 != 0x7ff) {
      uVar3 = in_a0 >> 0x1d;
      iVar14 = uVar5 - 0x3ff;
      in_a0 = in_a0 << 3;
      uVar1 = uVar3 | uVar1 << 3 | 0x800000;
      uVar5 = 0;
      iVar17 = 0;
      goto LAB_20002328;
    }
    iVar14 = 0x7ff;
    if (uVar1 != 0 || in_a0 != 0) {
      uVar5 = 0xc;
      iVar17 = 3;
      goto LAB_20002328;
    }
    uVar6 = in_a3 >> 0x14 & 0x7ff;
    uVar3 = 0;
    uVar1 = 0;
    uVar8 = 8;
    uVar5 = 8;
    iVar7 = 2;
    iVar17 = 2;
    in_a0 = 0;
    UVar16 = 0;
    if (uVar6 != 0) goto LAB_2000233e;
LAB_20002558:
    uVar8 = in_a3 & 0xfffff;
    uVar3 = uVar1;
    UVar16 = in_a0;
    if (uVar8 == 0 && in_a2 == 0) {
      uVar5 = uVar5 | 1;
      if (uVar5 < 0xb) {
        uVar12 = 0;
        iVar7 = 1;
        in_a2 = 0;
        if (uVar5 < 3) {
LAB_200026a6:
          if (iVar7 != 2) {
            return 0;
          }
          return 0;
        }
        goto LAB_20002376;
      }
    }
    else {
      if (uVar8 == 0) {
        iVar10 = __clzsi2(in_a2);
        iVar13 = iVar10 + 0x15;
        iVar7 = iVar10 + 0x20;
        if (iVar13 < 0x1d) goto LAB_20002570;
        uVar12 = in_a2 << (iVar10 - 8U & 0x1f);
        in_a2 = 0;
      }
      else {
        iVar7 = __clzsi2(uVar8);
        iVar13 = iVar7 + -0xb;
LAB_20002570:
        uVar12 = in_a2 >> (0x1dU - iVar13 & 0x1f) | uVar8 << (iVar7 - 8U & 0x1f);
        in_a2 = in_a2 << (iVar7 - 8U & 0x1f);
      }
      iVar14 = (iVar14 - iVar7) + -0x3f3;
      if (uVar5 < 0xb) {
        if (uVar5 < 3) goto LAB_20002394;
        iVar7 = 0;
LAB_20002376:
        uVar5 = 1 << uVar5;
        uVar3 = uVar1;
        UVar16 = in_a0;
        if ((uVar5 & 0x530) == 0) {
          iVar17 = iVar7;
          if ((uVar5 & 0x240) != 0) {
            return 0;
          }
          goto joined_r0x200026d8;
        }
      }
    }
joined_r0x200025aa:
    if (iVar17 == 2) {
      return 0;
    }
    if (iVar17 == 3) {
      return 0;
    }
    if (iVar17 == 1) {
      return 0;
    }
LAB_20002600:
    iVar17 = iVar14 + 0x400;
    iVar14 = iVar14 + 1;
    if (0 < iVar17) {
      if (((UVar16 & 7) != 0) && ((UVar16 & 0xf) != 4)) {
LAB_200024f4:
        uVar3 = uVar3 + (UVar16 + 4 < UVar16);
        UVar16 = UVar16 + 4;
      }
      if ((int)(uVar3 << 7) < 0) {
        iVar17 = iVar14 + 0x400;
        uVar3 = uVar3 & 0xfeffffff;
      }
LAB_20002514:
      if (iVar17 < 0x7ff) {
        uVar1 = uVar3 << 0x1d | UVar16 >> 3;
      }
      else {
        uVar1 = 0;
      }
      return uVar1;
    }
  }
  uVar1 = 1;
  if (iVar17 != 0) {
    uVar1 = 1 - iVar17;
    if (0x38 < (int)uVar1) {
      return 0;
    }
    if (0x1f < (int)uVar1) {
      uVar5 = uVar3 >> (-iVar17 - 0x1fU & 0x1f);
      if (uVar1 != 0x20) {
        UVar16 = UVar16 | uVar3 << (iVar14 + 0x43eU & 0x1f);
      }
      uVar8 = (uint)(UVar16 != 0);
      uVar6 = uVar8 | uVar5;
      uVar3 = uVar8 | uVar5 & 7;
      uVar1 = uVar6;
      if ((uVar3 != 0) && (uVar3 = 0, (uVar8 | uVar5 & 0xf) != 4)) {
        uVar1 = uVar6 + 4;
        uVar3 = (uint)(uVar1 < uVar6) << 0x1d;
      }
      goto LAB_20002804;
    }
  }
  uVar5 = UVar16 >> (uVar1 & 0x1f) |
          (uint)(UVar16 << (iVar14 + 0x41eU & 0x1f) != 0) | uVar3 << (iVar14 + 0x41eU & 0x1f);
  uVar3 = uVar3 >> (uVar1 & 0x1f);
  uVar1 = uVar5;
  if (((uVar5 & 7) != 0) && ((uVar5 & 0xf) != 4)) {
    uVar1 = uVar5 + 4;
    uVar3 = uVar3 + (uVar1 < uVar5);
  }
  if ((int)(uVar3 << 8) < 0) {
    return 0;
  }
  uVar3 = uVar3 << 0x1d;
LAB_20002804:
  return uVar1 >> 3 | uVar3;
}



// WARNING: Type propagation algorithm not settling

uint __subdf3(DFtype a,DFtype b)

{
  uint uVar1;
  uint in_a0;
  int iVar2;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  
  gp = &__global_pointer_;
  uVar9 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  uVar11 = in_a0 >> 0x1d;
  uVar6 = in_a2 >> 0x1d;
  uVar1 = in_a1 >> 0x1f;
  uVar8 = in_a3 >> 0x14 & 0x7ff;
  uVar12 = uVar11 | uVar9 << 3;
  uVar7 = uVar6 | uVar5 << 3;
  uVar3 = in_a3 >> 0x1f;
  uVar13 = in_a1 >> 0x14 & 0x7ff;
  uVar14 = in_a0 * 8;
  uVar10 = in_a2 * 8;
  if (uVar8 == 0x7ff) {
    if (uVar7 == 0 && uVar10 == 0) {
      if (uVar1 != (uVar3 ^ 1)) goto LAB_200029fa;
LAB_20002ac6:
      if (uVar13 == 0x7ff) {
LAB_20002c44:
        uVar1 = uVar13 + 1;
        if ((uVar1 & 0x7fe) != 0) {
          if (uVar1 == 0x7ff) {
            return 0;
          }
          uVar7 = uVar7 + uVar12 + (uint)(uVar10 + uVar14 < uVar14);
          uVar12 = uVar10 + uVar14 >> 1;
          uVar3 = uVar7 * -0x80000000 | uVar12;
          uVar7 = uVar7 >> 1;
          if ((uVar12 & 7) == 0) {
            return uVar7 << 0x1d | uVar3 >> 3;
          }
          if ((uVar12 & 0xf) == 4) {
            return uVar7 << 0x1d | uVar3 >> 3;
          }
          goto LAB_200028f6;
        }
        if (uVar13 == 0) {
          if (uVar12 != 0 || uVar14 != 0) {
            uVar13 = uVar14;
            if (uVar7 != 0 || uVar10 != 0) {
              uVar13 = uVar10 + uVar14;
              uVar12 = uVar7 + uVar12 + (uint)(uVar13 < uVar14);
              if ((int)(uVar12 * 0x100) < 0) {
                return uVar12 * 0x20000000 | uVar13 >> 3;
              }
              if (uVar13 == 0 && uVar12 == 0) {
                return 0;
              }
            }
LAB_20002c80:
            return uVar12 << 0x1d | uVar13 >> 3;
          }
          if (uVar7 == 0 && uVar10 == 0) {
            return 0;
          }
          uVar3 = in_a2 & 0x1fffffff;
          goto LAB_20002ba0;
        }
        if (uVar12 != 0 || uVar14 != 0) {
          if (uVar7 != 0 || uVar10 != 0) {
            return 0;
          }
          goto LAB_20002f34;
        }
      }
      else {
        uVar1 = uVar8;
        if (uVar13 == 0) {
LAB_20002ad0:
          if (uVar12 == 0 && uVar14 == 0) {
            uVar3 = in_a2 & 0x1fffffff;
            uVar13 = uVar1;
            goto LAB_20002ba0;
          }
          uVar3 = uVar1 - 1;
          if (uVar3 == 0) goto LAB_20002de0;
          if (uVar1 != 0x7ff) {
            if ((int)uVar3 < 0x39) goto LAB_20002fb2;
            uVar3 = uVar10 + 1;
            goto LAB_200028f6;
          }
        }
      }
      uVar3 = uVar6 << 0x1d | in_a2 & 0x1fffffff;
      goto LAB_20002a12;
    }
    if (uVar1 == uVar3) goto LAB_20002ac6;
LAB_200029fa:
    if (uVar13 != 0x7ff) {
      uVar1 = uVar8;
      if (uVar13 == 0) goto LAB_20002cd6;
LAB_20002a02:
      uVar3 = uVar6 << 0x1d | in_a2 & 0x1fffffff;
      goto LAB_20002a12;
    }
LAB_20002b08:
    if ((uVar13 + 1 & 0x7fe) == 0) {
      uVar8 = uVar7 | uVar10;
      if (uVar13 == 0) {
        uVar13 = uVar10;
        if (uVar12 != 0 || uVar14 != 0) {
          uVar13 = uVar14;
          if (uVar8 == 0) goto LAB_20002c80;
          uVar13 = uVar14 + in_a2 * -8;
          uVar5 = (uVar12 - uVar7) - (uint)(uVar14 < uVar13);
          if ((int)(uVar5 * 0x100) < 0) {
            uVar3 = uVar10 + in_a0 * -8;
            uVar7 = (uVar7 - uVar12) - (uint)(uVar10 < uVar3);
            if (uVar3 == 0 && uVar7 == 0) {
              return 0;
            }
            if (-1 < (int)(uVar7 * 0x100)) {
              return uVar7 * 0x20000000 | uVar3 >> 3;
            }
            goto LAB_20002928;
          }
          uVar8 = uVar13 | uVar5;
          uVar7 = uVar5;
        }
        uVar12 = uVar7;
        if (uVar8 == 0) {
          return 0;
        }
        goto LAB_20002c80;
      }
      if (uVar12 == 0 && uVar14 == 0) {
        if (uVar8 == 0) {
          return 0;
        }
        uVar3 = in_a2 & 0x1fffffff | uVar6 << 0x1d;
        goto LAB_20002a12;
      }
      if (uVar8 != 0) {
        return 0;
      }
LAB_20002f34:
      uVar3 = uVar11 << 0x1d | in_a0 & 0x1fffffff;
      uVar5 = uVar9;
      goto LAB_20002a12;
    }
    uVar3 = uVar14 + in_a2 * -8;
    uVar5 = (uVar12 - uVar7) - (uint)(uVar14 < uVar3);
    if ((int)(uVar5 * 0x100) < 0) {
      uVar3 = uVar10 + in_a0 * -8;
      uVar5 = (uVar7 - uVar12) - (uint)(uVar10 < uVar3);
    }
    else if (uVar3 == 0 && uVar5 == 0) {
      return 0;
    }
LAB_20002bcc:
    if (uVar5 != 0) goto LAB_20002a60;
    iVar2 = __clzsi2(uVar3);
    uVar12 = iVar2 + 0x18;
    if ((int)uVar12 < 0x20) goto LAB_20002a6a;
    uVar7 = uVar3 << (iVar2 - 8U & 0x1f);
    if ((int)uVar12 < (int)uVar13) {
      return uVar7 << 0x1d;
    }
    uVar5 = (uVar12 - uVar13) + 1;
    if ((int)uVar5 < 0x20) {
      uVar13 = 0x20 - uVar5;
      uVar12 = 0;
      uVar3 = 0;
      goto LAB_20002a9a;
    }
    uVar3 = uVar7 >> ((uVar12 - uVar13) - 0x1f & 0x1f);
    if (uVar5 != 0x20) {
      uVar3 = uVar3 | uVar7 << (0x40 - uVar5 & 0x1f) != 0;
    }
    if (uVar3 == 0) {
      return 0;
    }
    uVar1 = 0;
    uVar13 = 0;
    uVar7 = 0;
    if ((uVar3 & 7) == 0) {
      uVar7 = 0;
      goto LAB_20002c24;
    }
LAB_200029e0:
    uVar13 = uVar1;
    if ((uVar3 & 0xf) != 4) {
LAB_200028f6:
      uVar7 = uVar7 + (uVar3 + 4 < uVar3);
      uVar3 = uVar3 + 4;
      uVar13 = uVar1;
    }
LAB_20002902:
    if ((int)(uVar7 << 8) < 0) {
      if (uVar13 == 0x7fe) {
        return 0;
      }
LAB_20002928:
      return uVar7 << 0x1d | uVar3 >> 3;
    }
LAB_20002c24:
    uVar3 = uVar3 >> 3;
  }
  else {
    uVar4 = uVar13 - uVar8;
    if (uVar1 == (uVar3 ^ 1)) {
      if ((int)uVar4 < 1) {
        if (uVar4 == 0) goto LAB_20002c44;
        uVar3 = uVar8 - uVar13;
        uVar1 = uVar3;
        if (uVar13 == 0) goto LAB_20002ad0;
        if (0x38 < (int)uVar3) {
          uVar3 = uVar10 + 1;
          uVar1 = uVar8;
          goto LAB_200028f6;
        }
        uVar12 = uVar12 | 0x800000;
LAB_20002fb2:
        if ((int)uVar3 < 0x20) {
          uVar13 = uVar12 << (0x20 - uVar3 & 0x1f) | uVar14 >> (uVar3 & 0x1f) |
                   (uint)(uVar14 << (0x20 - uVar3 & 0x1f) != 0);
          uVar7 = uVar7 + (uVar12 >> (uVar3 & 0x1f));
        }
        else {
          if (uVar3 != 0x20) {
            uVar14 = uVar14 | uVar12 << (0x40 - uVar3 & 0x1f);
          }
          uVar13 = (uint)(uVar14 != 0) | uVar12 >> (uVar3 - 0x20 & 0x1f);
        }
        uVar3 = uVar10 + uVar13;
        uVar7 = (uVar3 < uVar13) + uVar7;
        uVar13 = uVar8;
LAB_200029aa:
        if (-1 < (int)(uVar7 << 8)) goto LAB_200028e4;
      }
      else {
        if (uVar8 == 0) {
          if (uVar7 == 0 && uVar10 == 0) goto LAB_20002b9a;
          uVar4 = uVar13 - 1;
          if (uVar4 != 0) {
            if (uVar13 != 0x7ff) {
              if ((int)uVar4 < 0x39) goto LAB_20002976;
              goto LAB_20002b82;
            }
            goto LAB_20002f34;
          }
LAB_20002de0:
          uVar10 = uVar10 + uVar14;
          uVar7 = uVar7 + uVar12 + (uint)(uVar10 < uVar14);
          if (-1 < (int)(uVar7 * 0x100)) {
            return uVar7 * 0x20000000 | uVar10 >> 3;
          }
          uVar10 = uVar10 >> 1;
          uVar12 = (uVar7 & 0xff7fffff) << 0x1f | uVar10;
          uVar7 = (uVar7 & 0xff7fffff) >> 1;
          if (((uVar10 & 7) == 0) || ((uVar10 & 0xf) == 4)) {
            return uVar7 << 0x1d | uVar12 >> 3;
          }
          uVar7 = (uVar12 + 4 < uVar12) + uVar7;
          uVar3 = uVar12 + 4 >> 3;
          uVar13 = 2;
          goto LAB_20002ba0;
        }
        if (uVar13 == 0x7ff) goto LAB_20002c34;
        if ((int)uVar4 < 0x39) {
          uVar7 = uVar7 | 0x800000;
LAB_20002976:
          if ((int)uVar4 < 0x20) {
            uVar5 = uVar7 << (0x20 - uVar4 & 0x1f) | uVar10 >> (uVar4 & 0x1f) |
                    (uint)(uVar10 << (0x20 - uVar4 & 0x1f) != 0);
            uVar12 = uVar12 + (uVar7 >> (uVar4 & 0x1f));
          }
          else {
            if (uVar4 != 0x20) {
              uVar10 = uVar10 | uVar7 << (0x40 - uVar4 & 0x1f);
            }
            uVar5 = (uint)(uVar10 != 0) | uVar7 >> (uVar4 - 0x20 & 0x1f);
          }
          uVar3 = uVar14 + uVar5;
          uVar7 = uVar12 + (uVar3 < uVar5);
          goto LAB_200029aa;
        }
LAB_20002b82:
        uVar7 = 0;
        if (-1 < (int)(uVar12 << 8)) {
          uVar3 = uVar14 + 1;
          uVar7 = uVar12;
          uVar1 = uVar13;
          goto LAB_200028f6;
        }
        uVar3 = 0;
      }
      uVar1 = uVar13 + 1;
      if (uVar1 == 0x7ff) {
        return 0;
      }
      uVar12 = uVar7 & 0xff7fffff;
      uVar7 = uVar12 >> 1;
      uVar3 = uVar12 << 0x1f | uVar3 >> 1 | uVar3 & 1;
LAB_200029da:
      uVar13 = uVar1;
      if ((uVar3 & 7) != 0) goto LAB_200029e0;
      goto LAB_20002902;
    }
    if ((int)uVar4 < 1) {
      if (uVar4 == 0) goto LAB_20002b08;
      uVar9 = uVar8 - uVar13;
      uVar1 = uVar9;
      if (uVar13 == 0) {
LAB_20002cd6:
        uVar13 = uVar1;
        if (uVar12 == 0 && uVar14 == 0) {
          uVar3 = in_a2 & 0x1fffffff;
          goto LAB_20002ba0;
        }
        uVar9 = uVar1 - 1;
        if (uVar9 == 0) {
          uVar3 = uVar10 + in_a0 * -8;
          uVar7 = (uVar7 - uVar12) - (uint)(uVar10 < uVar3);
          if (-1 < (int)(uVar7 * 0x100)) {
            return uVar7 * 0x20000000 | uVar3 >> 3;
          }
          goto LAB_20002bc4;
        }
        if (uVar1 == 0x7ff) goto LAB_20002a02;
        if ((int)uVar9 < 0x39) goto LAB_20002ecc;
        uVar3 = uVar10 - 1;
        uVar7 = uVar7 - (uVar10 < uVar3);
      }
      else {
        if ((int)uVar9 < 0x39) {
          uVar12 = uVar12 | 0x800000;
LAB_20002ecc:
          if ((int)uVar9 < 0x20) {
            uVar3 = uVar12 << (0x20 - uVar9 & 0x1f) | uVar14 >> (uVar9 & 0x1f) |
                    (uint)(uVar14 << (0x20 - uVar9 & 0x1f) != 0);
            uVar7 = uVar7 - (uVar12 >> (uVar9 & 0x1f));
          }
          else {
            if (uVar9 != 0x20) {
              uVar14 = uVar14 | uVar12 << (0x40 - uVar9 & 0x1f);
            }
            uVar3 = (uint)(uVar14 != 0) | uVar12 >> (uVar9 - 0x20 & 0x1f);
          }
          uVar3 = uVar10 - uVar3;
          uVar7 = uVar7 - (uVar10 < uVar3);
          goto LAB_200028dc;
        }
        uVar3 = uVar10 - 1;
        uVar7 = uVar7 - (uVar10 < uVar3);
        uVar13 = uVar8;
      }
joined_r0x20002d0c:
      uVar1 = uVar13;
      if ((int)(uVar7 * 0x100) < 0) {
        uVar5 = 0x7fffff;
        uVar3 = 0xffffffff;
LAB_20002a60:
        iVar2 = __clzsi2(uVar5);
        uVar12 = iVar2 - 8;
LAB_20002a6a:
        uVar7 = uVar3 >> (0x20 - uVar12 & 0x1f) | uVar5 << (uVar12 & 0x1f);
        uVar3 = uVar3 << (uVar12 & 0x1f);
        if ((int)uVar13 <= (int)uVar12) {
          uVar5 = (uVar12 - uVar13) + 1;
          uVar13 = 0x20 - uVar5;
          uVar12 = (uint)(uVar3 << (uVar13 & 0x1f) != 0);
          uVar3 = uVar3 >> (uVar5 & 0x1f);
LAB_20002a9a:
          uVar3 = uVar7 << (uVar13 & 0x1f) | uVar12 | uVar3;
          uVar7 = uVar7 >> (uVar5 & 0x1f);
          uVar1 = 0;
          if (uVar3 == 0 && uVar7 == 0) {
            return 0;
          }
          goto LAB_200029da;
        }
        uVar13 = uVar13 - uVar12;
        uVar7 = uVar7 & 0xff7fffff;
        if ((uVar3 & 7) == 0) {
          uVar3 = uVar3 >> 3;
          goto LAB_20002ba0;
        }
LAB_200028ec:
        uVar1 = uVar13;
        if ((uVar3 & 0xf) == 4) goto LAB_20002c24;
      }
      goto LAB_200028f6;
    }
    if (uVar8 != 0) {
      if (uVar13 == 0x7ff) {
LAB_20002c34:
        uVar3 = uVar11 << 0x1d | in_a0 & 0x1fffffff;
        uVar5 = uVar9;
        goto LAB_20002a12;
      }
      if (0x38 < (int)uVar4) {
LAB_20002a42:
        uVar3 = uVar14 - 1;
        uVar7 = uVar12 - (uVar14 < uVar3);
        goto joined_r0x20002d0c;
      }
      uVar7 = uVar7 | 0x800000;
LAB_200028a6:
      if ((int)uVar4 < 0x20) {
        uVar3 = uVar7 << (0x20 - uVar4 & 0x1f) | uVar10 >> (uVar4 & 0x1f) |
                (uint)(uVar10 << (0x20 - uVar4 & 0x1f) != 0);
        uVar12 = uVar12 - (uVar7 >> (uVar4 & 0x1f));
      }
      else {
        if (uVar4 != 0x20) {
          uVar10 = uVar10 | uVar7 << (0x40 - uVar4 & 0x1f);
        }
        uVar3 = (uint)(uVar10 != 0) | uVar7 >> (uVar4 - 0x20 & 0x1f);
      }
      uVar3 = uVar14 - uVar3;
      uVar7 = uVar12 - (uVar14 < uVar3);
      uVar8 = uVar13;
LAB_200028dc:
      uVar13 = uVar8;
      if ((int)(uVar7 << 8) < 0) {
LAB_20002bc6:
        uVar5 = uVar7 & 0x7fffff;
        uVar13 = uVar8;
        goto LAB_20002bcc;
      }
LAB_200028e4:
      if ((uVar3 & 7) != 0) goto LAB_200028ec;
      goto LAB_20002c24;
    }
    if (uVar7 != 0 || uVar10 != 0) {
      uVar4 = uVar13 - 1;
      if (uVar4 != 0) {
        if (uVar13 == 0x7ff) goto LAB_20002c34;
        if (0x38 < (int)uVar4) goto LAB_20002a42;
        goto LAB_200028a6;
      }
      uVar3 = uVar14 + in_a2 * -8;
      uVar7 = (uVar12 - uVar7) - (uint)(uVar14 < uVar3);
      if (-1 < (int)(uVar7 * 0x100)) {
        return uVar3 >> 3 | uVar7 * 0x20000000;
      }
LAB_20002bc4:
      uVar8 = 1;
      goto LAB_20002bc6;
    }
LAB_20002b9a:
    uVar3 = in_a0 & 0x1fffffff;
    uVar7 = uVar12;
  }
LAB_20002ba0:
  uVar3 = uVar7 << 0x1d | uVar3;
  uVar5 = uVar7 >> 3;
  if (uVar13 != 0x7ff) {
    return uVar3;
  }
LAB_20002a12:
  if (uVar3 != 0 || uVar5 != 0) {
    return 0;
  }
  return 0;
}



__gcc_CMPtype __unorddf2(DFtype a,DFtype b)

{
  int in_a0;
  uint in_a1;
  int in_a2;
  uint in_a3;
  
  gp = &__global_pointer_;
  if (((~(in_a1 >> 0x14) & 0x7ff) == 0) && ((in_a1 & 0xfffff) != 0 || in_a0 != 0)) {
    return 1;
  }
  if ((in_a3 >> 0x14 & 0x7ff) != 0x7ff) {
    return 0;
  }
  return (uint)((in_a3 & 0xfffff) != 0 || in_a2 != 0);
}



SItype __fixdfsi(DFtype a)

{
  uint in_a0;
  SItype SVar1;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  
  gp = &__global_pointer_;
  uVar3 = in_a1 >> 0x14 & 0x7ff;
  if (uVar3 < 0x3ff) {
    SVar1 = 0;
  }
  else {
    if (0x41d < uVar3) {
      return -((int)in_a1 >> 0x1f) + 0x7fffffff;
    }
    uVar2 = in_a1 & 0xfffff | 0x100000;
    if ((int)(0x433 - uVar3) < 0x20) {
      uVar2 = uVar2 << (uVar3 - 0x413 & 0x1f) | in_a0 >> (0x433 - uVar3 & 0x1f);
    }
    else {
      uVar2 = uVar2 >> (0x413 - uVar3 & 0x1f);
    }
    SVar1 = -uVar2;
    if (-((int)in_a1 >> 0x1f) == 0) {
      return uVar2;
    }
  }
  return SVar1;
}



// WARNING: Unknown calling convention

int __floatsidf(SItype i)

{
  USItype x;
  int iVar1;
  
  gp = &__global_pointer_;
  if (i == 0) {
    iVar1 = 0;
  }
  else {
    x = (i >> 0x1f ^ i) - (i >> 0x1f);
    iVar1 = __clzsi2(x);
    if (iVar1 < 0xb) {
      iVar1 = x << (iVar1 + 0x15U & 0x1f);
    }
    else {
      iVar1 = 0;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int __floatunsidf(USItype i)

{
  int iVar1;
  
  gp = &__global_pointer_;
  if (i == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = __clzsi2(i);
    if (iVar1 < 0xb) {
      iVar1 = i << (iVar1 + 0x15U & 0x1f);
    }
    else {
      iVar1 = 0;
    }
  }
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

uint __trunctfdf2(TFtype a)

{
  int *in_a0;
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint *puVar7;
  uint *puVar8;
  uint *puVar9;
  uint *puVar10;
  uint *puVar11;
  uint uVar12;
  uint auStack_88c [540];
  _FP_UNION_Q _FP_UNPACK_RAW_4_flo;
  uint auStack_c [3];
  
  gp = &__global_pointer_;
  _FP_UNPACK_RAW_4_flo._8_4_ = in_a0[3];
  _FP_UNPACK_RAW_4_flo._12_4_ = *in_a0;
  uVar3 = _FP_UNPACK_RAW_4_flo._8_4_ & 0xffff;
  _FP_UNPACK_RAW_4_flo._4_4_ = in_a0[2];
  auStack_c[1] = in_a0[2];
  auStack_c[2] = uVar3;
  uVar5 = (uint)(_FP_UNPACK_RAW_4_flo._8_4_ << 1) >> 0x11;
  _FP_UNPACK_RAW_4_flo._0_4_ = in_a0[1];
  auStack_c[0] = in_a0[1];
  puVar10 = (uint *)((int)&_FP_UNPACK_RAW_4_flo + 0xc);
  puVar9 = auStack_c + 2;
  do {
    puVar8 = puVar9;
    uVar1 = uVar3 << 3;
    uVar3 = puVar8[-1];
    puVar9 = puVar8 + -1;
    *puVar8 = uVar3 >> 0x1d | uVar1;
  } while (puVar10 != puVar9);
  _FP_UNPACK_RAW_4_flo._12_4_ = _FP_UNPACK_RAW_4_flo._12_4_ << 3;
  if ((uVar5 + 1) * 0x20000 >> 0x12 == 0) {
    if (uVar5 != 0) {
      if (((auStack_c[1] == 0 && auStack_c[0] == 0) && auStack_c[2] == 0) &&
          _FP_UNPACK_RAW_4_flo._12_4_ == 0) {
        return 0;
      }
      uVar5 = auStack_c[1] >> 0x1c;
      uVar3 = auStack_c[0] >> 0x1c & 0xfffffff8 | auStack_c[1] << 4;
      if ((auStack_c[2] & 0x80000) == 0) {
        return 0;
      }
      goto LAB_2000336c;
    }
    if (((auStack_c[1] == 0 && auStack_c[0] == 0) && auStack_c[2] == 0) &&
        _FP_UNPACK_RAW_4_flo._12_4_ == 0) {
      return 0;
    }
LAB_200032d2:
    uVar3 = 0;
    auStack_c[0] = 0;
LAB_200032d6:
    return auStack_c[0] << 0x1d | uVar3 >> 3;
  }
  iVar6 = uVar5 - 0x3c00;
  if (0x7fe < iVar6) {
    return 0;
  }
  if (iVar6 < 1) {
    if (iVar6 < -0x34) goto LAB_200032d2;
    iVar2 = (int)(0x3dU - iVar6) >> 5;
    uVar1 = auStack_c[2] | 0x80000;
    uVar5 = 0x3dU - iVar6 & 0x1f;
    auStack_c[2] = uVar1;
    uVar3 = 0;
    puVar7 = puVar10;
    do {
      uVar12 = *puVar7;
      puVar7 = puVar7 + 1;
      uVar3 = uVar3 | uVar12;
    } while (puVar10 + iVar2 != puVar7);
    iVar6 = 3 - iVar2;
    if (uVar5 == 0) {
      iVar4 = 1;
      puVar8[-1] = puVar10[iVar2];
      if (0 < iVar6) {
        do {
          iVar4 = iVar4 + 1;
          *puVar8 = puVar8[iVar2];
          puVar8 = puVar8 + 1;
        } while (iVar4 <= iVar6);
      }
      iVar2 = 4 - iVar2;
    }
    else {
      puVar8 = puVar10 + iVar2;
      uVar3 = uVar3 | *puVar8 << (0x20 - uVar5 & 0x1f);
      if (iVar6 == 0) {
        iVar2 = 1;
        iVar4 = 0;
      }
      else {
        iVar4 = iVar6 * 4;
        puVar7 = puVar9;
        do {
          puVar11 = puVar7 + 1;
          *puVar7 = *puVar8 >> uVar5 | puVar8[1] << (0x20 - uVar5 & 0x1f);
          puVar8 = puVar8 + 1;
          puVar7 = puVar11;
        } while (puVar9 + iVar6 != puVar11);
        iVar2 = 4 - iVar2;
      }
      *(uint *)(iVar4 + (int)puVar10) = uVar1 >> uVar5;
    }
    uVar5 = (4 - iVar2) * 4;
    puVar10 = puVar10 + iVar2;
    if (7 < uVar5) {
      *puVar10 = 0;
      auStack_c[iVar2] = 0;
      uVar5 = uVar5 - 8;
      puVar10 = auStack_c + iVar2 + 1;
    }
    if (3 < uVar5) {
      *puVar10 = 0;
    }
    uVar5 = (uint)(uVar3 != 0);
    uVar3 = uVar5 | _FP_UNPACK_RAW_4_flo._12_4_;
    if (uVar3 == 0 && auStack_c[0] == 0) {
      return 0;
    }
    if ((uVar5 != 0 || (_FP_UNPACK_RAW_4_flo._12_4_ & 7) != 0) &&
       ((uVar5 | _FP_UNPACK_RAW_4_flo._12_4_ & 0xf) != 4)) {
      iVar6 = 0;
      goto LAB_20003460;
    }
    if (-1 < (int)(auStack_c[0] << 8)) goto LAB_200032d6;
  }
  else {
    uVar1 = auStack_c[0] >> 0x1c;
    uVar5 = (uint)((auStack_c[0] & 0xfffffff) != 0 || _FP_UNPACK_RAW_4_flo._12_4_ != 0);
    uVar3 = uVar5 | uVar1 | auStack_c[1] << 4;
    auStack_c[0] = auStack_c[2] << 4 | auStack_c[1] >> 0x1c;
    if ((uVar5 != 0 || (uVar1 & 7) != 0) && ((uVar5 | uVar1) != 4)) {
LAB_20003460:
      auStack_c[0] = auStack_c[0] + (uVar3 + 4 < uVar3);
      uVar3 = uVar3 + 4;
    }
    if ((auStack_c[0] & 0x800000) == 0) goto LAB_200032d6;
    if (iVar6 == 0x7fe) {
      return 0;
    }
  }
  uVar5 = auStack_c[0] & 0xff7fffff;
LAB_2000336c:
  return uVar5 << 0x1d | uVar3 >> 3;
}



// WARNING: Unknown calling convention

int __clzsi2(USItype x)

{
  gp = &__global_pointer_;
  if (x < 0x10000) {
    return ((uint)(0xff < x) * -8 + 0x20) - (uint)__clz_tab[x >> (uint)(0xff < x) * 8];
  }
  if (x < 0x1000000) {
    return 0x10 - (uint)__clz_tab[x >> 0x10];
  }
  return 8 - (uint)__clz_tab[x >> 0x18];
}



void irq_handler_chain_first_slot(void)

{
  undefined4 *in_t0;
  
  gp = &__global_pointer_;
                    // WARNING: Could not recover jumptable at 0x200036ea. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)*in_t0)();
  return;
}



// WARNING: Control flow encountered unimplemented instructions
// WARNING: Removing unreachable block (ram,0x20000904)
// WARNING: Removing unreachable block (ram,0x2000094a)

void __vectors(void)

{
  int in_mscratch;
  uint in_mcause;
  
  gp = &__global_pointer_;
  if (in_mscratch != 0) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (in_mcause < 0xc) {
                    // WARNING: Unimplemented instruction - Truncating control flow here
    halt_unimplemented();
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x20003792)
// WARNING: Removing unreachable block (ram,0x2000378e)
// WARNING: Removing unreachable block (ram,0x200037f6)

undefined4 isr_riscv_machine_external_irq(undefined4 param_1)

{
  uint in_csrbe4;
  uint uVar1;
  
  gp = &__global_pointer_;
  do {
    while (uVar1 = in_csrbe4 | 1, -1 < (int)in_csrbe4) {
      (*(code *)(*(uint *)((int)&__soft_vector_table + in_csrbe4) & 0xfffffffe))();
      in_csrbe4 = uVar1;
    }
    in_csrbe4 = uVar1;
  } while (-1 < (int)uVar1);
  return param_1;
}



// WARNING: Control flow encountered bad instruction data

void isr_irqIRQN(void)

{
  gp = &__global_pointer_;
  ebreak();
                    // WARNING: Bad instruction - Truncating control flow here
  halt_baddata();
}


